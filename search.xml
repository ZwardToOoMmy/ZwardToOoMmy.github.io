<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[è’Ÿè’»â„(â„ â„â€¢â„Ï‰â„â€¢â„ â„)â„æŠ¥é“ (ç½®é¡¶)(ç½®é¡¶)]]></title>
    <url>%2F2099%2F12%2F31%2F%E8%92%9F%E8%92%BB%E6%8A%A5%E9%81%93!(%E5%8D%9A%E5%AE%A2%E5%BA%8F%E6%9B%B2)%2F</url>
    <content type="text"><![CDATA[è¿™ç¯‡æ–‡ç« çš„å‡ºç°ï¼Œé¢„ç¤ºç€æ—¶éš”å¤šå¹´ï¼Œæˆ‘çš„åšå®¢ç»ˆäºè¦å¯ç”¨å•¦ï¼æ’’èŠ±èŠ±]]></content>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#715 C.Digit Tree]]></title>
    <url>%2F2019%2F02%2F18%2FCodeForces-715-C-Digit-Tree%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜E.Digit Treeé¢˜é¢ZS the Coder has a large tree. It can be represented as an undirected connected graph of $n$ vertices numbered from $0$ to $n - 1$ and $n - 1$ edges between them. There is a single nonzero digit written on each edge. One day, ZS the Coder was bored and decided to investigate some properties of the tree. He chose a positive integer $M$, which is coprime to $10$, $i.e$. $gcd(M,10)=1$. ZS consider an ordered pair of distinct vertices $(u, v)$ interesting when if he would follow the shortest path from vertex $u$ to vertex $v$ and write down all the digits he encounters on his path in the same order, he will get a decimal representaion of an integer divisible by $M$. Formally, ZS consider an ordered pair of distinct vertices $(u, v)$ interesting if the following states true: Let $a_1 = u, a_2, â€¦, a_k = v$ be the sequence of vertices on the shortest path from $u$ to $v$ in the order of encountering them; Let $d_i$ ($1 â‰¤ i &lt; k$) be the digit written on the edge between vertices $a_i$ and $a_i$ + 1; The integer $\overline{d_1d_2d_3â€¦d_{k-1}}=\sum_{i=1}^{k-1}d_iÂ·10^{k-1-i}$ is divisible by $M$. Help ZS the Coder find the number of interesting pairs! ç®€è¦ç¿»è¯‘ç»™å®šä¸€ä¸ªæœ‰$N$ä¸ªç‚¹çš„æ ‘ï¼Œé—®å…¶ä¸­æœ‰å¤šå°‘æ¡è·¯å¾„æ»¡è¶³ä»–ä»¬çš„è¾¹æƒè¿æˆçš„æ•°å¯¹$M$å–ä½™ä¸º$0$ã€‚ å…¶ä¸­$gcd(M,10)=1$ã€‚ Inputç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•°$n$å’Œ$M$ã€‚ ä¸‹é¢åŒ…å«$n-1$è¡Œï¼Œæ¯è¡ŒåŒ…å«$3$ä¸ªæ•´æ•°ã€‚ç¬¬$i$è¡ŒåŒ…å«$u_i,v_i,w_i$åˆ†åˆ«ä»£è¡¨ä¸€æ¡è¾¹çš„å‡ºç‚¹ï¼Œå…¥ç‚¹ï¼Œæƒå€¼ã€‚ Outputè¾“å‡ºä¸€è¡Œä¸€ä¸ªæ•´æ•°è¡¨ç¤ºæ•°å¯¹ä¸ªæ•°ã€‚ Sample Input 16 70 1 24 2 42 0 13 0 92 5 7 Sample Output 17 Sample Input 25 111 2 32 0 33 0 34 3 3 Sample Output 28 Hint$2\le n\le 100,000,1\le M\le 10^9,gcd(M,10)=1$ã€‚ $0\le u_i,v_i\le n,1\le w_i\le 9$ã€‚ Sample Explainåœ¨ç¬¬ä¸€ä¸ªä¾‹å­ä¸­ï¼Œæ‰€æ±‚æ•°å¯¹æ˜¯$(0,4),(1.2),(1.5),(3,2),(2.5),(5,2),(3,5)$ï¼Œç”±è¿™äº›æ•°å¯¹ç»„æˆçš„æ•°åˆ†åˆ«æ˜¯$14,21,217,91,7,7,917$ï¼Œéƒ½æ˜¯$7$çš„å€æ•°ã€‚æ³¨æ„$(2,5)$å’Œ$(5,2)$æ˜¯ä¸åŒçš„æ•°å¯¹ã€‚ åœ¨ç¬¬äºŒä¸ªä¾‹å­ä¸­ï¼Œæ‰€æ±‚æ•°å¯¹æ˜¯$(4,0),(0,4),(3,2),(2,3),(0,1),(1,0),(4,1),(1,4)$ï¼Œå…¶ä¸­6å¯¹ç»™å‡ºäº†æ•°å­—$33$è€Œå…¶ä¸­$2$å¯¹ç»™å‡ºäº†æ•°å­—$3333$ï¼Œå®ƒä»¬éƒ½æ˜¯$11â€‹$çš„å€æ•°ã€‚ æˆ‘ä»¬ç‚¹åˆ†æ²»å¥—è·¯ä¸€æ³¢ã€‚ ç„¶ååˆ†æä¸€ä¸‹å¦‚ä½•ç»Ÿè®¡ç­”æ¡ˆã€‚ å¯¹äº$xâ†’y$çš„è·¯å¾„ï¼Œç­‰ä»·äº$xâ†’rootâ†’y$ï¼Œæˆ‘ä»¬è¦å¤„ç†å‡º$dis[x]$å’Œ$dis[y]$åˆ†åˆ«è¡¨ç¤º$x$åˆ°$root$,$root$åˆ°$y$è¿æˆçš„æ•°å¯¹$mod$å–æ¨¡åçš„ç»“æœã€‚ åœ¨åˆå¹¶æ—¶ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œå¦‚æœè·¯å¾„æ˜¯åˆæ³•çš„ï¼Œé‚£ä¹ˆè‚¯å®šæ»¡è¶³$dis[x]Ã—10^{deep[y]}+dis[y]â‰¡0\ \pmod{M}â€‹$ ä¹Ÿå°±æ˜¯$dis[x]â‰¡-dis[y]Ã—10^{-deep[y]}\pmod{M}$ ç”¨$dfsâ€‹$æ¥ç»Ÿè®¡ç­”æ¡ˆå³å¯ã€‚ Code12]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4025 äºŒåˆ†å›¾]]></title>
    <url>%2F2019%2F02%2F18%2Fbzoj-4025-%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜B.äºŒåˆ†å›¾é¢˜é¢ç¥çŠ‡æœ‰ä¸€ä¸ª$n$ä¸ªèŠ‚ç‚¹çš„å›¾ã€‚å› ä¸ºç¥çŠ‡æ˜¯ç¥çŠ‡ï¼Œæ‰€ä»¥åœ¨Tæ—¶é—´å†…ä¸€äº›è¾¹ä¼šå‡ºç°åæ¶ˆå¤±ã€‚ç¥çŠ‡è¦æ±‚å‡ºæ¯ä¸€æ—¶é—´æ®µå†…è¿™ä¸ªå›¾æ˜¯å¦æ˜¯äºŒåˆ†å›¾ã€‚è¿™ä¹ˆç®€å•çš„é—®é¢˜ç¥çŠ‡å½“ç„¶ä¼šåšäº†ï¼Œäºæ˜¯ä»–æƒ³è€ƒè€ƒä½ ã€‚ Inputè¾“å…¥æ•°æ®çš„ç¬¬ä¸€è¡Œæ˜¯ä¸‰ä¸ªæ•´æ•°$n,m,T$ã€‚ ç¬¬$2$è¡Œåˆ°ç¬¬$m+1$è¡Œï¼Œæ¯è¡Œ$4$ä¸ªæ•´æ•°$u,v,start,end$ã€‚ç¬¬$i+1$è¡Œçš„å››ä¸ªæ•´æ•°è¡¨ç¤ºç¬¬iæ¡è¾¹è¿æ¥$u,v$ä¸¤ä¸ªç‚¹ï¼Œè¿™æ¡è¾¹åœ¨$start$æ—¶åˆ»å‡ºç°ï¼Œåœ¨ç¬¬$end$æ—¶åˆ»æ¶ˆå¤±ã€‚ Outputè¾“å‡ºåŒ…å«$T$è¡Œã€‚åœ¨ç¬¬$i$è¡Œä¸­ï¼Œå¦‚æœç¬¬$i$æ—¶é—´æ®µå†…è¿™ä¸ªå›¾æ˜¯äºŒåˆ†å›¾ï¼Œé‚£ä¹ˆè¾“å‡ºâ€œ$Yes$â€ï¼Œå¦åˆ™è¾“å‡ºâ€œ$No$â€ï¼Œä¸å«å¼•å·ã€‚ Sample Input3 3 31 2 0 22 3 0 31 3 1 2 Sample OutputYesNoYes Hint$1\le n\le 100000ï¼Œ1\le m\le 200000ï¼Œ1\le T\le 100000ï¼Œ1\le u,v\le nï¼Œ0\le start\le end\le Tã€‚$ Sample Explain 0æ—¶åˆ»ï¼Œå‡ºç°ä¸¤æ¡è¾¹1-2å’Œ2-3ã€‚ ç¬¬1æ—¶é—´æ®µå†…ï¼Œè¿™ä¸ªå›¾æ˜¯äºŒåˆ†å›¾ï¼Œè¾“å‡ºYesã€‚ 1æ—¶åˆ»ï¼Œå‡ºç°ä¸€æ¡è¾¹1-3ã€‚ ç¬¬2æ—¶é—´æ®µå†…ï¼Œè¿™ä¸ªå›¾ä¸æ˜¯äºŒåˆ†å›¾ï¼Œè¾“å‡ºNoã€‚ 2æ—¶åˆ»ï¼Œ1-2å’Œ1-3ä¸¤æ¡è¾¹æ¶ˆå¤±ã€‚ ç¬¬3æ—¶é—´æ®µå†…ï¼Œåªæœ‰ä¸€æ¡è¾¹2-3ï¼Œè¿™ä¸ªå›¾æ˜¯äºŒåˆ†å›¾ï¼Œè¾“å‡ºYesã€‚ å¦‚é¢˜ï¼šäºŒåˆ†å›¾çš„è¯ï¼Œå°±ç­‰ä»·äºä¸å­˜åœ¨å¥‡ç¯ï¼Œæˆ‘ä»¬ç›´æ¥çº¿æ®µæ ‘åˆ†æ²»ï¼Œç”¨å¹¶æŸ¥é›†ç»´æŠ¤æ¯ä¸ªç‚¹ä¸æ ¹èŠ‚ç‚¹é—´çš„è·ç¦»å³å¯ã€‚ æˆ‘ä»¬å»ºç«‹ä¸€æ£µçº¿æ®µæ ‘ï¼Œç”¨æ—¶é—´è½´æ¥å½“åšçº¿æ®µæ ‘çš„å·¦å³ç«¯ç‚¹ï¼Œæ¯ä¸€æ¡è¾¹å‡ºç°æ¶ˆå¤±çš„æ—¶é—´åŒºé—´å°±å¯¹åº”ç€çº¿æ®µæ ‘ä¸Šçš„ä¸€å¯¹$[l,r]$ï¼Œå°†æ¯ä¸€æ¡è¾¹æ’åˆ°å¯¹åº”çš„æ—¶é—´åŒºé—´ä¸­ï¼Œæœ€åç»Ÿè®¡ç­”æ¡ˆæ—¶ï¼Œåªè¦ç”¨çº¿æ®µæ ‘åˆ†æ²»ï¼Œä»$[1,r_{max}]$å„ä¸ªç‚¹éƒ½ä¾æ¬¡è®¿é—®,å­˜å‚¨ç­”æ¡ˆï¼Œæœ€åè¾“å‡ºã€‚ å½“ç„¶äº†ï¼Œç”±äºæˆ‘ä»¬è¦æ”¯æŒæ’¤é”€æ“ä½œï¼Œæ‰€ä»¥ä¸èƒ½å°†å¹¶æŸ¥é›†è·¯å¾„å‹ç¼©ï¼Œè¿™æ ·å°±æ²¡æœ‰åŠæ³•æ’¤é”€äº†ã€‚ å…·ä½“æ“ä½œè§ä»£ç å§ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x=0,w=0; char ch=0; while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return w? -x:x;&#125;const int N=100010;struct edge&#123; int u,v;&#125;;vector&lt;edge&gt; t[N&lt;&lt;2];bool Answer[N];int fa[N],sz[N],dist[N],n,m;int q;int getfa(int x)&#123; while(x!=fa[x]) x=fa[x]; return x;&#125;int dis(int x)&#123; int d=0; while(x!=fa[x]) d^=dist[x],x=fa[x]; return d;&#125;void change(int root,int l,int r,int ll,int rr,edge e)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123;t[root].push_back(e);return;&#125; int mid=l+r&gt;&gt;1; if(ll&lt;=mid) change(root&lt;&lt;1,l,mid,ll,rr,e); if(rr&gt;mid) change(root&lt;&lt;1|1,mid+1,r,ll,rr,e);&#125;void divide_(int root,int l,int r)&#123; vector&lt;edge&gt; p; p.clear(); int mid=l+r&gt;&gt;1; bool have_ans=0; for(int i=0,len=t[root].size();i&lt;len;++i) &#123; int u=t[root][i].u,v=t[root][i].v; int a=getfa(u),b=getfa(v); if(a==b) if((dis(u)^dis(v))==0) &#123; have_ans=1; break; &#125;else; else &#123; if(sz[a]&gt;sz[b]) swap(a,b),swap(u,v); sz[b]+=sz[a],dist[a]=dist[u]^dist[v]^1; fa[a]=b; p.push_back((edge)&#123;a,b&#125;); &#125; &#125; if(!have_ans) &#123; if(l==r) Answer[l]=1; else &#123; divide_(root&lt;&lt;1,l,mid); divide_(root&lt;&lt;1|1,mid+1,r); &#125; &#125; for(int i=p.size()-1;~i;--i) &#123; int u=p[i].u,v=p[i].v; sz[v]-=sz[u]; dist[u]=0,fa[u]=u; &#125;&#125;int main(int argc, char const *argv[])&#123; n=read(),m=read(),q=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); edge e=(edge)&#123;u,v&#125;; int l=read(),r=read(); if(l&lt;r) change(1,1,q,l+1,r,e); &#125; for(int i=1;i&lt;=n;++i) fa[i]=i,sz[i]=1; divide_(1,1,q); for(int i=1;i&lt;=q;++i) if(Answer[i]) puts("Yes"); else puts("No"); return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ›¼å“ˆé¡¿è·ç¦»-æ¬§å¼è·ç¦»]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB-%E6%AC%A7%E5%BC%8F%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~ 1ã€æ›¼å“ˆé¡¿è·ç¦»åˆå«é©¬æ°è·ç¦»ã€‚ ç®€å•æ¥è¯´å°±æ˜¯ç‚¹ä¸ç‚¹ä¹‹é—´åœ¨$n$ç»´ç©ºé—´ä¸Šçš„åæ ‡å·®çš„ç»å¯¹å€¼ã€‚ ä»¥äºŒç»´å¹³é¢ä¸ºä¾‹å­ï¼šåˆ™$Manhattan\ distance=|x_1-x_2|+|y_1-y_2|$ã€‚ 2ã€æ¬§å¼è·ç¦»åˆå«æ¬§å‡ é‡Œå¾—è·ç¦»ã€‚ ç®€å•æ¥è¯´å°±æ˜¯ç‚¹ä¸ç‚¹åœ¨ç©ºé—´ä¸Šçš„ç›´çº¿è·ç¦»ã€‚ ä»¥äºŒç»´å¹³é¢ä¸ºä¾‹å­ï¼šåˆ™$Euclidean\ Metric=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$ã€‚ åº¦å¨˜ç™¾ç§‘é‡Œæœ‰è¿™ä¹ˆä¸€ä¸ªå›¾ã€‚ é‚£ä¹ˆç»¿è‰²ä»£è¡¨æ¬§å¼è·ç¦»ï¼Œè“ã€çº¢ã€é»„å…¶å®æ±‚å‡ºçš„éƒ½æ˜¯æ›¼å“ˆé¡¿è·ç¦»ã€‚]]></content>
      <categories>
        <category>çŸ¥è¯†ç‚¹</category>
      </categories>
      <tags>
        <tag>Math Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[çº¿æ®µæ ‘åˆ†æ²»-é™ˆä¸¹çª(cdq)åˆ†æ²»]]></title>
    <url>%2F2019%2F02%2F18%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB-%E9%99%88%E4%B8%B9%E7%90%AA-cdq-%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[æˆ‘ä»¬å…ˆæ¥äº†è§£ä¸€ä¸‹çº¿æ®µæ ‘åˆ†æ²»å¾ˆæ˜¾ç„¶ï¼Œæˆ‘ä»¬åœ¨è¿›è¡Œæ“ä½œçš„æ—¶å€™ï¼ŒæŠŠæ‰€æœ‰æ“ä½œéƒ½æ”¾åœ¨ä¸€æ£µæ ‘é‡Œé¢ï¼Œå°±åƒéå†ä¸€æ£µæ ‘ä¸€æ ·éå†ä¸€æ•´æ£µæ ‘ï¼Œè¿™ä¸ªç®—æ³•ä¸å›æº¯+$dfs$ä¸åŒçš„åœ°æ–¹åœ¨äºä¸€å±‚é€’å½’ä¸­æœ‰å¯èƒ½æ¨ªè·¨å¤šä¸ªèŠ‚ç‚¹ã€‚å¦‚æœä¸€ä¸ªæ“ä½œéœ€è¦ç”¨åˆ°å¤šä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆå°±æŠŠè¿™ä¸ªæ“ä½œæ‹†å¼€ï¼Œåˆ†æ²»è¿™ä¸ªæ“ä½œï¼Œæœ€å¤šèƒ½åˆ†æˆ$log$çº§åˆ«æ•°é‡çš„æ“ä½œã€‚ æ¨¡ä»¿çº¿æ®µæ ‘ï¼Œå°†è¿™ä¸ªæ“ä½œè¦†ç›–æ•´ä¸ªåŒºé—´ï¼Œç„¶åè¿›è¡Œæ‹†åˆ†æ“ä½œï¼Œé€’å½’å­æ ‘æ±‚è§£ã€‚ ä¾‹é¢˜â€”BZOJ4025äºŒåˆ†å›¾ æˆ‘ä»¬å†äº†è§£ä¸€ä¸‹CDQåˆ†æ²»CDQåˆ†æ²»å®ƒåªæ”¯æŒç¦»çº¿æ“ä½œï¼Œä½†æ˜¯å®ƒçš„å¸¸æ•°æ¯”è¾ƒå°ï¼Œèƒ½æ›¿ä»£ä¸€éƒ¨åˆ†æ¯”è¾ƒå¤æ‚çš„æ•°æ®ç»“æ„ã€‚ äºŒç»´ååºï¼ˆCDQåˆ†æ²»å¤ªçƒ¦äº†ï¼Œå­¦ä¹ ä¸­â€¦â€¦ï¼‰ æ›´å¤šè¯¦æƒ…è¯·ç‚¹å‡»Coco_T_å¤§ä½¬çš„blogã€‚]]></content>
      <categories>
        <category>çŸ¥è¯†ç‚¹</category>
      </categories>
      <tags>
        <tag>Operation On Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¯å‘å¼åˆå¹¶]]></title>
    <url>%2F2019%2F02%2F18%2F%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~ä¸€ã€å¯å‘å¼åˆå¹¶çš„ç®—æ³•åŸç†æˆ‘ä»¬å¸¸ç”¨è·¯å¾„å‹ç¼©çš„æ–¹æ³•æ¥å‡å°‘å†…å­˜æ¶ˆè€—ï¼Œä½†æ˜¯è¿‡ç¨‹ä¸­ä¼šæŸå¤±æ‰å¾ˆå¤šçš„æ•°æ®ä¿¡æ¯ï¼Œå¦‚æœç”¨å†°èŒ¶å‡ æ¥ç»´æŠ¤åˆä¼šæ¶ˆè€—å¾ˆå¤šæ—¶é—´ï¼Œè¿™æ—¶å€™æˆ‘ä»¬éœ€è¦ç”¨åˆ°å¯å‘å¼åˆå¹¶ã€‚ æˆ‘ä»¬ç”¨å¹¶æŸ¥é›†æ—¶ï¼Œå¾ˆå¤šæ—¶é—´éƒ½æµªè´¹åœ¨äº†$getfa()$è¿™ä¸ªå‡½æ•°ä¸Šé¢ï¼Œæˆ‘ä»¬è€ƒè™‘å¯¹$getfa()$è¿›è¡Œä¼˜åŒ–ã€‚å¯å‘å¼åˆå¹¶ä½¿å®ƒçš„æ—¶é—´å¤æ‚åº¦èƒ½å°½å¯èƒ½æ§åˆ¶åœ¨$O(logn)$å·¦å³ã€‚ å¹¶æŸ¥é›†æ˜¯æ ‘å‹çš„æ•°æ®ç»“æ„ï¼Œæœ‰æ·±åº¦è¿™ä¸€æ¦‚å¿µï¼Œå¦‚æœæˆ‘ä»¬æŠŠæ·±åº¦å¤§çš„æ ‘çš„æ ¹èŠ‚ç‚¹æ¥åœ¨æ·±åº¦å°çš„æ ‘ä¸Šï¼Œé‚£ä¹ˆæ·±åº¦åè€Œä¼šå¢å¤§ï¼Œæ—¶é—´æ¶ˆè€—å°±ä¼šæ›´å¤šã€‚ é‚£å¯å‘å¼åˆå¹¶å°±æ˜¯æŠŠå°çš„æ ‘çš„æ ¹èŠ‚ç‚¹æ¥åœ¨å¤§çš„æ ‘ä¸Šï¼Œé‚£ä¹ˆæ·±åº¦å°±æ˜¯$max(h_å°+1,h_å¤§)$ï¼Œè¿™å°±æ˜¯å¯å‘å¼åˆå¹¶çš„åŸç†ã€‚ äºŒã€æˆ‘ä»¬å€Ÿå›¾æ¥ç†è§£ä¸€ä¸‹ã€‚ ä¸€å¼€å§‹æœ‰ä¸¤æ£µæ ‘é«˜åº¦åˆ†åˆ«ä¸º3å’Œ5 å¦‚æœæ˜¯å¹¶æŸ¥é›†çš„$getfa()$æ“ä½œï¼Œé‚£ä¹ˆæ ‘ä¼šå˜æˆè¿™æ · è€Œè¿›è¡Œäº†å¯å‘å¼åˆå¹¶çš„æ ‘æ˜¯è¿™æ ·çš„ ä¸‰ã€Code12345678910111213void qfs_union(int x,int y)&#123; int a=find(x); int b=find(y); if(height[a]&gt;height[b]) fa[b]=a; else if(height[a]&lt;height[b]) fa[a]=b; else&#123; fa[a]=b; height[b]++; &#125;&#125; 123456int find(x)&#123; while(fa[x]!=0) x=fa[x]; return x;&#125;]]></content>
      <categories>
        <category>çŸ¥è¯†ç‚¹</category>
      </categories>
      <tags>
        <tag>Operation On Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[äºŒåˆ†å›¾ä¸“é¢˜]]></title>
    <url>%2F2019%2F02%2F18%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~æˆ‘å¯¹äºŒåˆ†å›¾ç®€ç›´è‡ªé—­ï¼Œå†³å®šå†æ¬¡å­¦ä¹ ä¸€æ³¢ï¼Œå”‰ã€‚ ä¸€ã€äºŒåˆ†å›¾çš„å®šä¹‰ ç®€å•çš„è¯´ï¼Œå¦‚æœå›¾ä¸­çš„ç‚¹å¯ä»¥è¢«åˆ†ä¸ºä¸¤ç»„ï¼Œå¹¶ä¸”æ‰€æœ‰çš„è¾¹çš„ä¸¤ç«¯ä¸åœ¨åŒä¸€ç»„å†…ï¼Œä¹Ÿå°±æ˜¯è¯´éƒ½è¿é€šä¸¤ä¸ªç»„ï¼Œé‚£ä¹ˆè¿™å°±æ˜¯ä¸€ä¸ªäºŒåˆ†å›¾ã€‚ äºŒåˆ†å›¾è¿˜æœ‰å¦ä¸€ä¸ªå®šä¹‰ï¼Œå¦‚æœæŠŠä¸€ä¸ªå›¾çš„é¡¶ç‚¹åˆ’åˆ†ä¸ºä¸¤ä¸ªä¸ç›¸äº¤é›†ï¼Œä½¿æ¯ä¸€æ¡è¾¹åˆ†åˆ«è¿æ¥ä¸¤é›†ä¸­çš„é¡¶ç‚¹ï¼Œé‚£ä¹ˆè¿™å°±æ˜¯ä¸€ä¸ªäºŒåˆ†å›¾ã€‚ Fig1æ˜¯ä¸€ä¸ªäºŒåˆ†å›¾ï¼Œçœ‹èµ·æ¥ä¸æ–¹ä¾¿ï¼Œå°±ç”»æˆFig2ã€‚ äºŒã€åŒ¹é…çš„å®šä¹‰ ç®€å•åœ°è¯´ï¼Œå°±æ˜¯ä¸€ä¸ªè¾¹é›†ï¼Œä¸”æ»¡è¶³å…¶ä¸­ä»»æ„ä¸¤è¾¹éƒ½æ²¡æœ‰å…¬å…±é¡¶ç‚¹ã€‚ å¦‚å›¾ï¼ŒFig3ã€Fig4æ˜¯Fig2 çš„åŒ¹é…ï¼š åŒ¹é…ä¸­è¿˜æœ‰ä¸€äº›å®šä¹‰ï¼šåŒ¹é…ç‚¹ï¼ŒåŒ¹é…è¾¹ï¼ŒæœªåŒ¹é…ç‚¹ï¼ŒéåŒ¹é…è¾¹ã€‚æ¯”å¦‚Fig3ä¸­çš„1,4,5,7æ˜¯åŒ¹é…ç‚¹ï¼Œ1-5,4-7æ˜¯åŒ¹é…è¾¹ã€‚ æœ€å¤§åŒ¹é…ï¼šä¸€ä¸ªå›¾çš„æ‰€æœ‰åŒ¹é…ä¸­ï¼Œæ‰€å«åŒ¹é…è¾¹æœ€å¤šçš„åŒ¹é…ï¼Œç§°ä¸ºè¯¥å›¾çš„æœ€å¤§åŒ¹é…ã€‚Fig4æ˜¯ä¸€ä¸ªæœ€å¤§åŒ¹é…ã€‚ å®Œç¾åŒ¹é…ï¼šå¦‚æœä¸€ä¸ªåŒ¹é…å†…ï¼Œæ‰€æœ‰çš„ç‚¹éƒ½æ˜¯åŒ¹é…ç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªåŒ¹é…å°±æ˜¯ä¸€ä¸ªå®Œç¾åŒ¹é…ï¼Œæ˜¾ç„¶æœ‰ï¼Œå®Œç¾åŒ¹é…ä¸€å®šæ˜¯æœ€å¤§åŒ¹é…ã€‚ä½†æ˜¯å¹¶ä¸æ˜¯æ‰€æœ‰çš„å›¾éƒ½å­˜åœ¨å®Œç¾åŒ¹é…ã€‚ ä¸‰ã€å¦ä¸€äº›å®šä¹‰ï¼ˆåŒˆç‰™åˆ©ç®—æ³•ï¼‰ äº¤æ›¿è·¯ï¼šä»ä¸€ä¸ªæœªåŒ¹é…ç‚¹å‡ºå‘ï¼Œä¾æ¬¡ç»è¿‡éåŒ¹é…è¾¹ï¼ŒåŒ¹é…è¾¹ï¼ŒéåŒ¹é…è¾¹ï¼ŒåŒ¹é…è¾¹â€¦â€¦å¦‚æ­¤å½¢æˆçš„è·¯å¾„å«äº¤æ›¿è·¯ã€‚ å¢å¹¿è·¯ï¼šä»ä¸€ä¸ªæœªåŒ¹é…ç‚¹å‡ºå‘ï¼Œèµ°äº¤æ›¿è·¯ï¼Œå¦‚æœé€”å¾„å¦ä¸€ä¸ªæœªåŒ¹é…ç‚¹ï¼Œä½†ä¸èƒ½ç®—å‡ºå‘ç‚¹ï¼Œé‚£ä¹ˆè¿™æ¡è·¯å«åšå¢å¹¿è·¯ã€‚å¦‚å›¾ï¼ŒFig5ä¸­çš„å¢å¹¿è·¯ä¸ºFig6ï¼š å¢å¹¿è·¯æœ‰ä¸€ä¸ªç‰¹ç‚¹ï¼šéåŒ¹é…è¾¹ä¸€å®šæ¯”åŒ¹é…è¾¹å¤šä¸€æ¡ã€‚ â†’ ç”±æ­¤ï¼Œåªè¦æŠŠå¢å¹¿è·¯ä¸­çš„åŒ¹é…è¾¹å’ŒéåŒ¹é…è¾¹èº«ä»½äº¤æ¢å³å¯ã€‚ç”±äºä¸­é—´çš„åŒ¹é…èŠ‚ç‚¹ä¸å­˜åœ¨å…¶ä»–ç›¸è¿çš„åŒ¹é…è¾¹ï¼Œæ‰€ä»¥è¿™æ ·åšä¸ä¼šç ´ååŒ¹é…çš„æ€§è´¨ã€‚äº¤æ¢åï¼Œå›¾ä¸­çš„åŒ¹é…è¾¹æ•°æ¯”åŸæ¥å¤š1æ¡ï¼Œå…¶å®å¦‚æœäº¤æ›¿è·¯ä»¥éåŒ¹é…ç‚¹ç»“æŸï¼Œé‚£ä¹ˆè¯¥äº¤æ›¿è·¯å°±æ˜¯ä¸€æ¡å¢å¹¿è·¯ã€‚ å››ã€åŒˆç‰™åˆ©ç®—æ³• 1ã€åŸºæœ¬æ€æƒ³ï¼š é€šè¿‡å¯»æ‰¾å¢å¹¿è·¯ï¼ŒæŠŠå¢å¹¿è·¯çš„åŒ¹é…è¾¹å’ŒéåŒ¹é…è¾¹èº«ä»½äº¤æ¢ï¼Œå¤šå‡ºä¸€æ¡åŒ¹é…è¾¹ï¼Œç›´åˆ°ä¸èƒ½æ‰¾åˆ°å¢å¹¿è·¯ä¸ºæ­¢ã€‚ Codeï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define MAXN 9999using namespace std;int nx,ny;//nxè¡¨ç¤ºäºŒåˆ†å›¾å·¦è¾¹é¡¶ç‚¹çš„ä¸ªæ•°ï¼Œnyè¡¨ç¤ºäºŒåˆ†å›¾å³è¾¹é¡¶ç‚¹çš„ä¸ªæ•°int m;//mä»£è¡¨è¾¹çš„æ¡æ•°int cx[MAXN],cy[MAXN];//å¦‚æœæœ‰cx[i]=jï¼Œåˆ™å¿…æœ‰cy[j]=iï¼Œè¯´æ˜iç‚¹å’Œjç‚¹èƒ½å¤ŸåŒ¹é…int x,y;//xç‚¹åˆ°yç‚¹æœ‰è¾¹int e[MAXN][MAXN];//é‚»æ¥çŸ©é˜µint visited[MAXN];//æ ‡è®°æ•°ç»„ï¼Œæ ‡è®°çš„æ°¸è¿œæ˜¯äºŒåˆ†å›¾å³è¾¹çš„é¡¶ç‚¹int ret;//æœ€åç»“æœint point(int u)//è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯å¯»æ‰¾å¢å¹¿è·¯å’Œæ›´æ–°cxï¼Œxyæ•°ç»„ï¼Œå¦‚æœæ‰¾åˆ°äº†å¢å¹¿è·¯ï¼Œå‡½æ•°è¿”å›1ï¼Œæ‰¾ä¸åˆ°ï¼Œå‡½æ•°è¿”å›0ã€‚&#123; for(int v=1;v&lt;=ny;v++)//ä¾æ¬¡éå†å³è¾¹çš„æ‰€æœ‰é¡¶ç‚¹ &#123; if(e[u][v]&amp;&amp;!visited[v])//æ¡ä»¶ä¸€ï¼šå·¦è¾¹çš„ué¡¶ç‚¹å’Œå³è¾¹çš„vé¡¶ç‚¹æœ‰è¿é€šè¾¹ï¼Œæ¡ä»¶äºŒï¼šå³è¾¹çš„vé¡¶ç‚¹åœ¨æ²¡æœ‰è¢«è®¿é—®è¿‡ï¼Œè¿™ä¸¤ä¸ªæ¡ä»¶å¿…é¡»åŒæ—¶æ»¡è¶³ &#123; visited[v]=1;//å°†vé¡¶ç‚¹æ ‡è®°ä¸ºè®¿é—®è¿‡çš„ if(cy[v]==-1||point(cy[v]))//æ¡ä»¶ä¸€ï¼šå³è¾¹çš„vé¡¶ç‚¹æ²¡æœ‰å·¦è¾¹å¯¹åº”çš„åŒ¹é…çš„ç‚¹ï¼Œæ¡ä»¶äºŒï¼šä»¥vé¡¶ç‚¹åœ¨å·¦è¾¹çš„åŒ¹é…ç‚¹ä¸ºèµ·ç‚¹èƒ½å¤Ÿæ‰¾åˆ°ä¸€æ¡å¢å¹¿è·¯ï¼ˆå¦‚æœèƒ½å¤Ÿåˆ°è¾¾æ¡ä»¶äºŒï¼Œè¯´æ˜vé¡¶ç‚¹åœ¨å·¦è¾¹ä¸€å®šæœ‰å¯¹åº”çš„åŒ¹é…ç‚¹ï¼‰ã€‚ &#123; cx[u]=v;//æ›´æ–°cxï¼Œcyæ•°ç»„ cy[v]=u; return 1; &#125; &#125; &#125; return 0;//å¦‚æœç¨‹åºåˆ°è¾¾äº†è¿™é‡Œï¼Œè¯´æ˜å¯¹å³è¾¹æ‰€æœ‰çš„é¡¶ç‚¹éƒ½è®¿é—®å®Œäº†ï¼Œæ²¡æœ‰æ»¡è¶³æ¡ä»¶çš„ã€‚&#125;int main()&#123; while (cin&gt;&gt;m&gt;&gt;nx&gt;&gt;ny) &#123; memset(cx,-1,sizeof(cx));//åˆå§‹åŒ–cxï¼Œcyæ•°ç»„çš„å€¼ä¸º-1 memset(cy,-1,sizeof(cy)); memset(e,0,sizeof(e));//åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ ret=0; while (m--)//è¾“å…¥è¾¹çš„ä¿¡æ¯å’Œæ›´æ–°é‚»æ¥çŸ©é˜µ &#123; cin&gt;&gt;x&gt;&gt;y; e[x][y]=1; &#125; for(int i=1;i&lt;=nx;i++)//å¯¹äºŒåˆ†å›¾å·¦è¾¹çš„æ‰€æœ‰é¡¶ç‚¹è¿›è¡Œéå† &#123; if(cx[i]==-1)//å¦‚æœå·¦è¾¹çš„ié¡¶ç‚¹è¿˜æ²¡æœ‰åŒ¹é…çš„ç‚¹ï¼Œå°±å¯¹ié¡¶ç‚¹è¿›è¡ŒåŒ¹é… &#123; memset(visited,0,sizeof(visited));//æ¯æ¬¡è¿›è¡Œpointæ—¶ï¼Œéƒ½è¦å¯¹visitedæ•°ç»„è¿›è¡Œåˆå§‹åŒ– ret+=point(i);//pointå‡½æ•°ä¼ å…¥çš„å‚æ•°æ°¸è¿œæ˜¯äºŒåˆ†å›¾å·¦è¾¹çš„ç‚¹ &#125; &#125; cout&lt;&lt;ret&lt;&lt;endl; &#125; &#125;//%%%%%%%%%%%%//æ¥è‡ªcsdn--æ ¾çª//%%%%%%%%%%%% 2ã€åˆ†æ æˆ‘ä»¬æ‹¿å‡ºFig2æ¥åˆ†æä¸€æ³¢ï¼š åˆ†æä¸€ä¸‹$point()$å‡½æ•°çš„è¿è¡Œè¿‡ç¨‹ï¼Œç¬¬ä¸€æ¬¡ä»¥$1$é¡¶ç‚¹ä¸ºèµ·ç‚¹è¿›å…¥$point(1)$å‡½æ•°ï¼Œç„¶å5å·é¡¶ç‚¹æ»¡è¶³æ¡ä»¶ï¼Œæ›´æ–°$cx[1]ï¼Œcy[5]$ï¼Œè¿”å›$1$ã€‚æ­¤æ—¶$1â†’5$è¿™æ¡è¾¹ä¸ºåŒ¹é…è¾¹ï¼Œ$1$å·ï¼Œ$5$å·é¡¶ç‚¹ä¸ºåŒ¹é…é¡¶ç‚¹ã€‚ ç„¶åä»¥$2$é¡¶ç‚¹ä¸ºå…¶å®ç‚¹è¿›å…¥$point(1)$å‡½æ•°ï¼Œç„¶åè®¿é—®åˆ°$5$å·èŠ‚ç‚¹ï¼Œç„¶åä»¥$5$å·èŠ‚ç‚¹çš„åŒ¹é…ç‚¹$1$å·èŠ‚ç‚¹ä¸ºèµ·å§‹ç‚¹å†æ¬¡è¿›å…¥$point(2)$å‡½æ•°ï¼Œæ‰¾åˆ°äº†$7$å·ç‚¹ï¼Œè¿™æ—¶è¯´æ˜æ‰¾åˆ°äº†å¢å¹¿è·¯ï¼Œç„¶åæ›´æ–°$cx[1],cy[7]$ï¼Œç„¶åè¿”å›$1$ï¼Œæ›´æ–°$cx[2],cy[5]$ï¼Œè¿”å›$1$ï¼Œå‡½æ•°ç»“æŸã€‚ ç„¶åä»¥$3$å·é¡¶ç‚¹ä¸ºèµ·å§‹ç‚¹è¿›å…¥$point(1)$å‡½æ•°ï¼Œç„¶åè®¿é—®åˆ°$5$å·èŠ‚ç‚¹ï¼Œç„¶åä»¥$5$å·èŠ‚ç‚¹çš„åŒ¹é…ç‚¹$2$å·èŠ‚ç‚¹ä¸ºèµ·å§‹ç‚¹å†æ¬¡è¿›å…¥$point(2)$å‡½æ•°ï¼Œæ‰¾ä¸åˆ°ç‚¹äº†ï¼Œè¿”å›$0$ï¼Œåˆ°è¾¾$point(1)$å‡½æ•°ï¼Œç»§ç»­è®¿é—®å…¶ä»–çš„èŠ‚ç‚¹ã€‚ç„¶åè®¿é—®åˆ°$6$å·é¡¶ç‚¹ï¼Œæ»¡è¶³æ¡ä»¶ï¼Œæ›´æ–°$cx[3],cy[6]$ï¼Œè¿”å›$1$ï¼Œå‡½æ•°ç»“æŸã€‚ ç„¶åä»¥$4$å·é¡¶ç‚¹ä¸ºèµ·å§‹ç‚¹è¿›å…¥$point(1)$å‡½æ•°ï¼Œç„¶åè®¿é—®åˆ°$7$å·èŠ‚ç‚¹ï¼Œç„¶åä»¥$7$å·èŠ‚ç‚¹çš„åŒ¹é…ç‚¹$1$å·èŠ‚ç‚¹ä¸ºèµ·å§‹ç‚¹å†æ¬¡è¿›å…¥$point(2)$å‡½æ•°ï¼Œç„¶åæ‰¾åˆ°$5$å·èŠ‚ç‚¹ï¼Œç„¶åä»¥$5$å·èŠ‚ç‚¹çš„åŒ¹é…ç‚¹$2$å·èŠ‚ç‚¹ä¸ºèµ·å§‹ç‚¹å†æ¬¡è¿›å…¥$point(3)$å‡½æ•°ï¼Œæ‰¾ä¸åˆ°ç‚¹äº†ï¼Œè¿”å›$0$ï¼Œåˆ°è¾¾$point(2)$å‡½æ•°ï¼Œç»§ç»­è®¿é—®å…¶ä»–çš„èŠ‚ç‚¹ï¼Œæ²¡æœ‰ç‚¹äº†ï¼Œè¿”å›$0$ï¼Œåˆ°è¾¾$point(1)$å‡½æ•°ï¼Œç»§ç»­è®¿é—®å…¶ä»–çš„èŠ‚ç‚¹ï¼Œåˆ°è¾¾äº†$8$å·èŠ‚ç‚¹ï¼Œæ»¡è¶³ï¼Œç„¶åæ›´æ–°$cx[4],cy[8]$ï¼Œè¿”å›$1$ï¼Œå‡½æ•°ç»“æŸã€‚ è¿™æ ·æˆ‘ä»¬å°±æ‰¾åˆ°äº†æ‰€æœ‰çš„åŒ¹é…è¾¹ã€‚ äº”ã€KMç®—æ³•è§blog: https://www.cnblogs.com/wenruo/p/5264235.html https://www.cnblogs.com/logosG/p/logos.html?tdsourcetag=s_pcqq_aiomsg Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;limits.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cassert&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;list&gt;#include&lt;set&gt;#define INT 9654234#define mod 1000000007typedef long long ll;using namespace std;const int MAXN = 305;int N;int ex_gir[MAXN];//æ¯ä¸ªå¦¹å­çš„æœŸæœ›å€¼int ex_boy[MAXN];//æ¯ä¸ªç”·ç”Ÿçš„æœŸæœ›å€¼bool vis_gir[MAXN];//è®°å½•æ¯ä¸€è½®åŒ¹é…è¿‡çš„å¥³ç”Ÿbool vis_boy[MAXN];//è®°å½•æ¯ä¸€è½®åŒ¹é…è¿‡çš„ç”·ç”Ÿ æ¯è¿›è¡Œæ–°çš„ä¸€è½®ï¼Œéƒ½è¦é‡æ–°åˆå§‹åŒ–è¿™ä¸¤ä¸ªæ•°ç»„int match[MAXN];//match[i]ä»£è¡¨å’Œiç”·ç”ŸåŒ¹é…çš„å¥³ç”Ÿçš„ç¼–å·int slack[MAXN];//slack[i]ä»£è¡¨iç”·ç”Ÿå¦‚æœè¦è·å¾—å¥³ç”Ÿçš„èŠ³å¿ƒï¼Œè‡³å°‘éœ€è¦å¢åŠ çš„æœŸå¾…å€¼int love[MAXN][MAXN];//è®°å½•æ¯ä¸ªå¦¹å­å’Œç”·ç”Ÿçš„å¥½æ„Ÿåº¦bool dfs(int gir)//dfså‡½æ•°æ±‚çš„æ˜¯ç¼–å·ä¸ºgirçš„å¥³å­©èƒ½å¦åŒ¹é…åˆ°ç”·ç”Ÿï¼Œå¦‚æœèƒ½ï¼Œè¿”å›trueï¼Œå¦åˆ™ï¼Œè¿”å›false&#123; vis_gir[gir]=true;//æ ‡è®° for(int i=1;i&lt;=N;i++) &#123; if(vis_boy[i])//æˆ‘ä»¬è§„å®šæ¯æ¬¡åŒ¹é…å¯¹äºæŸä¸ªç”·ç”Ÿåªè®¿é—®ä¸€éï¼Œå¦‚æœå…ˆå‰è®¿é—®è¿‡äº†ï¼Œå°±æ¢ä¸ªç”·ç”Ÿ continue ; int gap=ex_gir[gir]+ex_boy[i]-love[gir][i]; if(gap==0)//å¦‚æœè¿™ä¸ªæ¡ä»¶æ»¡è¶³ï¼Œè¯´æ˜ç¼–å·ä¸ºgirå¥³å­©å’Œç¼–å·ä¸ºiçš„ç”·å­©å¯èƒ½èƒ½å¤ŸåŒ¹é…æˆåŠŸ &#123; vis_boy[i]=true;//æ ‡è®° if(match[i]==-1||dfs(match[i]))//å¦‚æœè¿™ä¸¤ä¸ªæ¡ä»¶æ»¡è¶³å…¶ä¸­ä¸€ä¸ªï¼Œè¯´æ˜ç¼–å·ä¸ºgirå¥³å­©å’Œç¼–å·ä¸ºiçš„ç”·å­©åŒ¹é…æˆåŠŸ &#123; match[i]=gir; return true; &#125; &#125; else slack[i]=min(slack[i],gap);//å¦‚æœgapä¸ç­‰äº0ï¼Œè¯´æ˜å½“å‰çŠ¶æ€ç¼–å·ä¸ºgirå¥³å­©å’Œç¼–å·ä¸ºiçš„ç”·å­©ä¸å¯èƒ½åŒ¹é…æˆåŠŸï¼Œæ›´æ–°slack[i]ã€‚ &#125; return false;&#125;int km()&#123; memset(match,-1,sizeof(match)); memset(ex_boy,0,sizeof(ex_boy)); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) ex_gir[i]=max(love[i][j],ex_gir[i]);//åˆå§‹åŒ–ex_giræ•°ç»„ for(int i=1;i&lt;=N;i++) &#123; fill(slack,slack+N+1,INT); while (1)//è¿™ä¸ªwhileå¾ªç¯ç»“æŸçš„æ¡ä»¶æ˜¯ç›´åˆ°è®©ç¼–å·ä¸ºiçš„å¥³ç”Ÿæ‰¾åˆ°å¯ä»¥åŒ¹é…çš„ç”·ç”Ÿå &#123; memset(vis_gir,false,sizeof(vis_gir)); memset(vis_boy,false,sizeof(vis_gir)); if(dfs(i))//å¦‚æœè¿™ä¸ªæ¡ä»¶æ»¡è¶³ï¼Œè¯´æ˜ç¼–å·ä¸ºiçš„å¥³ç”Ÿæ‰¾åˆ°äº†åŒ¹é…çš„ç”·ç”Ÿï¼Œæ¢ä¸‹ä¸€ä¸ªå¥³ç”Ÿ,å¦‚æœè¿™ä¸ªæ¡ä»¶ä¸æ»¡è¶³ï¼Œè¯´æ˜è¿™ä¸ªå¥³ç”Ÿæ²¡æœ‰åŒ¹é…åˆ°ç”·ç”Ÿï¼Œè®©è¿™ä¸ªå¥³ç”Ÿé™ä½æœŸæœ›å€¼åç»§ç»­åŒ¹é… break ; int t=INT; for(int j=1;j&lt;=N;j++)//å¯»æ‰¾åœ¨è¿™ä¸€è½®åŒ¹é…ä¸­æ²¡æœ‰åŒ¹é…åˆ°çš„ç”·ç”Ÿå¦‚æœè¦è·å¾—å¥³ç”ŸèŠ³å¿ƒæ‰€éœ€è¦å¢åŠ çš„æœŸå¾…å€¼çš„æœ€å°å€¼ if(!vis_boy[j]) t=min(t,slack[j]); for(int i=1;i&lt;=N;i++)//è®©åœ¨è¿™ä¸€è½®åŒ¹é…ä¸­åŒ¹é…è¿‡çš„å¥³ç”Ÿçš„æœŸå¾…å€¼å‡å°ï¼ŒåŒ¹é…è¿‡çš„ç”·ç”Ÿçš„æœŸå¾…å€¼å¢åŠ  &#123; if(vis_gir[i]) ex_gir[i]-=t; if(vis_boy[i]) ex_boy[i]+=t; else slack[i]-=t;//å› ä¸ºæœ‰äº›å¥³ç”Ÿçš„æœŸå¾…å€¼å‡å°äº†ï¼Œæ‰€ä»¥è¿™ä¸€è½®æ²¡æœ‰è¢«åŒ¹é…è¿‡çš„ç”·ç”Ÿå¾—åˆ°å¥³ç”Ÿçš„èŠ³å¿ƒæ‰€éœ€è¦å¢åŠ çš„æœŸå¾…å€¼å°±å˜å°äº†ï¼Œæ‰€ä»¥slackæ•°ç»„ä¸­çš„ç›¸åº”çš„å€¼è¦å˜å° &#125; &#125; &#125; int res=0;//è®¡ç®—å¥½æ„Ÿå’Œ for(int i=1;i&lt;=N;i++) res+=love[match[i]][i]; return res;&#125;int main()&#123; cin&gt;&gt;N; for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) cin&gt;&gt;love[i][j]; cout&lt;&lt;km()&lt;&lt;endl;&#125;//%%%%%%%%%%%%//æ¥è‡ªcsdn--æ ¾çª//%%%%%%%%%%%% å…­ã€Gale-Shapleyâ€”-å©šå§»åŒ¹é…ç®—æ³•ç®—æ³•è§blog: https://blog.csdn.net/Air_hjj/article/details/70828937 https://blog.csdn.net/lc_miao/article/details/78116064 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;limits.h&gt;#include &lt;sstream&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cassert&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;list&gt;#include&lt;set&gt;#define mod 1000000007#define MAXN 1000typedef long long ll;using namespace std;int ManArray[MAXN][MAXN],GirArray[MAXN][MAXN];//ManArray[i][j]ä»£è¡¨ç¼–å·ä¸ºiçš„ç”·ç”Ÿçš„ç¬¬jä½å¿ƒä»ªå¥³ç”Ÿæ˜¯å‡ å·,GirArray[i][j]ä»£è¡¨ç¼–å·ä¸ºiçš„å¥³ç”Ÿçš„ç¬¬jä½å¿ƒä»ªç”·ç”Ÿæ˜¯å‡ å·int Man[MAXN],Gir[MAXN];//Man[i]ä»£è¡¨iå·ç”·ç”Ÿæ‰€åŒ¹é…åˆ°çš„å¥³ç”Ÿæ˜¯å‡ å·ï¼ŒGir[i]ä»£è¡¨iå·å¥³ç”Ÿæ‰€åŒ¹é…åˆ°çš„ç”·ç”Ÿæ˜¯å‡ å·int ManStarPos[MAXN];//ManStarPos[i]ä»£è¡¨iå·ç”·ç”Ÿç°åœ¨åŒ¹é…åˆ°çš„å¥³ç”Ÿæ˜¯ä»–å¿ƒç›®ä¸­çš„ç¬¬å‡ å·å¿ƒä»ªå¥³ç”Ÿint n;stack &lt; int &gt;q;//å§‹ç»ˆå­˜æ”¾æ²¡æœ‰åŒ¹é…æˆåŠŸçš„ç”·ç”Ÿçš„ç¼–å·int GetPositionFromLaday(int GirI,int ManI)//è¿™ä¸ªå‡½æ•°æ±‚çš„æ˜¯ç¼–å·ä¸ºManIçš„ç”·ç”Ÿåœ¨ç¼–å·ä¸ºGirIçš„å¥³ç”Ÿçš„å¿ƒä¸­çš„æ’åé¡ºåº&#123; for(int i=0;i&lt;n;i++) if(GirArray[GirI][i]==ManI) return i;//è¿”å›è¿™ä¸ªé¡ºåº return -1;&#125;void ManLookGir(int ManI)//ä¸ºç¼–å·ä¸ºManIçš„ç”·ç”ŸåŒ¹é…å¥³ç”Ÿ&#123; int NowGir=ManArray[ManI][ManStarPos[ManI]];//å¾—åˆ°è¿™ä¸ªç”·ç”Ÿåº”è¯¥åŒ¹é…çš„å¥³ç”Ÿçš„ç¼–å· if(Gir[NowGir]==-1)//å¦‚æœè¿™ä¸ªæ¡ä»¶æ»¡è¶³ï¼Œè¯´æ˜è¿™ä¸ªå¥³ç”Ÿæ²¡æœ‰å’Œå¥¹å¯¹åº”åŒ¹é…çš„ç”·ç”Ÿï¼Œé‚£ä¹ˆå°±åŒ¹é…ä¸Š &#123; Man[ManI]=NowGir; Gir[NowGir]=ManI; &#125; else//è¿™ä¸ªå¥³ç”Ÿç°åœ¨å·²ç»æœ‰ç”·æœ‹å‹äº† &#123; int OldMan=GetPositionFromLaday(NowGir,Gir[NowGir]);//å¾—åˆ°ç°ç”·å‹åœ¨è¿™ä¸ªå¥³å­©å¿ƒä¸­çš„æ’å int NowMan=GetPositionFromLaday(NowGir,ManI);//å¾—åˆ°æˆ‘ä»¬è¦åŒ¹é…çš„ç”·ç”Ÿåœ¨è¿™ä¸ªå¥³å­©å¿ƒä¸­çš„æ’å if(OldMan&lt;NowMan)//å¦‚æœè¿™ä¸ªæ¡ä»¶æ»¡è¶³ï¼Œè¯´æ˜è¿™ä¸ªå¥³å­©çš„ç°ç”·å‹åœ¨è¿™ä¸ªå¥³å­©å¿ƒä¸­çš„æ’åè¦é«˜äºæˆ‘ä»¬è¦åŒ¹é…çš„è¿™ä¸ªç”·ç”Ÿçš„æ’åï¼Œè¿™ä¸ªå¥³å­©ä¸æ¢ç”·æœ‹å‹ &#123; ManStarPos[ManI]++; q.push(ManI); &#125; else//è¿™ä¸ªå¥³å­©æ›´å–œæ¬¢æˆ‘ä»¬è¦åŒ¹é…çš„è¿™ä¸ªç”·ç”Ÿï¼Œæ¢ç”·æœ‹å‹ &#123; ManStarPos[Gir[NowGir]]++;//è¿™æ˜¯ä¸€ä¸ªä¼˜åŒ– q.push(Gir[NowGir]); Man[ManI]=NowGir; Gir[NowGir]=ManI; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; memset(Man,-1,sizeof(Man));//åˆå§‹åŒ–è¿™ä¸‰ä¸ªæ•°ç»„ memset(Gir,-1,sizeof(Gir)); memset(ManStarPos,0,sizeof(ManStarPos)); for(int i=0;i&lt;n;i++)//è¾“å…¥æ¯ä¸ªç”·ç”Ÿå¿ƒç›®ä¸­å¯¹å¥³ç”Ÿçš„æ’åº for(int j=0;j&lt;n;j++) cin&gt;&gt;ManArray[i][j]; for(int i=0;i&lt;n;i++)//è¾“å…¥æ¯ä¸ªå¥³ç”Ÿå¿ƒç›®ä¸­å¯¹ç”·ç”Ÿçš„æ’åº for(int j=0;j&lt;n;j++) cin&gt;&gt;GirArray[i][j]; for(int i=0;i&lt;n;i++)//åˆšå¼€å§‹å¯¹æ¯ä¸ªç”·ç”Ÿéƒ½è¿›è¡Œä¸€æ¬¡åŒ¹é…ï¼Œä»æ¯ä¸ªç”·ç”Ÿæœ€å¿ƒä»ªçš„å¥³ç”Ÿå¼€å§‹åŒ¹é…ã€‚å¦‚æœä»ç¨‹åºè¿™ä¸ªåœ°æ–¹è¿›å…¥ManLookGirå‡½æ•°ï¼Œé‚£ä¹ˆæ¯ä¸ªç”·ç”Ÿéƒ½ä¼šå’Œè‡ªå·±æœ€å¿ƒä»ªçš„å¥³ç”Ÿè¿›è¡Œä¸€æ¬¡åŒ¹é…ï¼Œå› ä¸ºæ˜¯ManStarPosæ•°ç»„å†³å®šçš„ï¼Œè‡³äºèƒ½å¦åŒ¹é…æˆåŠŸï¼Œè¿™å°±ä¸ä¸€å®šäº† ManLookGir(i); while(!q.empty()) &#123; int i=q.top(); q.pop(); ManLookGir(i); &#125; for(int i=0;i&lt;n;i++) cout&lt;&lt;"Man NO.: "&lt;&lt;i&lt;&lt;" Laday NO.: "&lt;&lt;Man[i]&lt;&lt;endl;&#125;//%%%%%%%%%%%%//æ¥è‡ªcsdn--æ ¾çª//%%%%%%%%%%%% ä»€ä¹ˆï¼Ÿä½ è¯´ä¸ºä»€ä¹ˆæˆ‘åé¢éƒ½æ²¡äº†ï¼Ÿéƒ½åªæŒ‚äº†ä¸€ä¸ªï¼ˆä¸ä¸ä¸ï¼Œå…¶å®æ˜¯ä¸¤ä¸ªï¼‰åšå®¢åœ°å€å‘¢ï¼Ÿ é‚£è¿˜ç”¨è¯´ï¼æˆ‘ä¸ä¼šå•Š_(Â¦3ã€âˆ )_]]></content>
      <categories>
        <category>çŸ¥è¯†ç‚¹</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#323 C.Two permutations]]></title>
    <url>%2F2019%2F02%2F17%2FCodeForces-323-C-Two-permutations%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜B.Two Permutationsé¢˜é¢è¿™æ¬¡æˆ‘ä¸æƒ³æ¬è‹±æ–‡é¢˜é¢äº†ï¼Œæˆ‘æ‡’ä¸€æ¬¡å§ï¼Œæ¯•ç«Ÿæ˜¯fateiceå¤§ä½¬ç»™çš„ç¿»è¯‘ ç®€è¦ç¿»è¯‘ç»™ä½ ä¸¤ä¸ªé•¿åº¦ä¸ºnçš„æ’åˆ—ï¼Œå¤šæ¬¡è¯¢é—®åœ¨ç¬¬ä¸€ä¸ªæ’åˆ—çš„[l1,r1]å’Œç¬¬äºŒä¸ªæ’åˆ—çš„[l2,r2]åŒæ—¶å‡ºç°çš„æ•°æœ‰å¤šå°‘ä¸ªã€‚ Inputç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°$n$ï¼Œå³ä¸¤ä¸ªæ’åˆ—ä¸­çš„å…ƒç´ æ•°ã€‚ä¸‹ä¸€è¡ŒåŒ…å«$n$ä¸ªæ•´æ•°ï¼Œç”¨ç©ºæ ¼åˆ†éš”: $p_1, p_2 â€¦ p_n$ ï¼Œä»£è¡¨åºåˆ—$1$ã€‚ä¸‹ä¸€è¡ŒåŒ…å«$n$ä¸ªæ•´æ•°ï¼Œç”¨ç©ºæ ¼åˆ†éš”:$q_1,q_2â€¦q_n$ï¼Œä»£è¡¨åºåˆ—$2$ã€‚ ä¸‹é¢ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°$m$ï¼Œä»£è¡¨è¯¢é—®çš„æ¬¡æ•°ã€‚ ä¸‹é¢çš„mè¡ŒåŒ…å«ä¸€è¡ŒæŸ¥è¯¢çš„æè¿°ã€‚ç¬¬iä¸ªè¯¢é—®çš„æè¿°ç”±4ä¸ªæ•´æ•°ç»„æˆ:$a,b,c, d$ã€‚æŸ¥è¯¢å‚æ•°$l_1ã€r_1ã€1_2ã€r_2$ç”±æ•°å­—$a,b,c,d$é€šè¿‡ä»¥ä¸‹ç®—æ³•å¾—åˆ° å¼•å…¥å˜é‡$x$ã€‚å¦‚æœå®ƒæ˜¯ç¬¬ä¸€ä¸ªæŸ¥è¯¢ï¼Œé‚£ä¹ˆå˜é‡$x=0$ï¼Œå¦åˆ™å®ƒç­‰äºå‰ä¸€ä¸ªæŸ¥è¯¢çš„å€¼åŠ ä¸Š$1$ã€‚ å¼•å…¥å‡½æ•°$f(z) =((z-1+c)\ mod\ n)+1$ã€‚ å‡è®¾$l_1 = min (f (a), f (b)), r_1 = max(f (a), f (b)), l_2 = min (f (c), f (d)), r_2=max(f (c), f (d))$ Outputå¯¹äºæ¯ä¸ªæŸ¥è¯¢è¾“å‡ºä¸€è¡Œä¸€ä¸ªæ•´æ•°ä»£è¡¨ç­”æ¡ˆã€‚ Sample Input 133 1 23 2 111 2 3 3 Sample Output 11 Sample Input 244 3 2 12 3 4 131 2 3 41 3 2 11 4 2 3 Sample Output 21 1 2 Hint$1\le n\le 10^6$ï¼Œ$1 \le m \le 2Ã—10^5$ã€‚ $1\le p_i\le n$ï¼Œ$1\le a,b,c,d\le n$ã€‚ æˆ‘ä»¬æ±‚å‡ºç¬¬äºŒä¸ªæ’åˆ—çš„æ•°åœ¨ç¬¬ä¸€ä¸ªæ’åˆ—ä¸­æ‰€å¯¹åº”çš„ä½ç½®ã€‚ ç”¨å¯æŒä¹…åŒ–çš„æƒå€¼çº¿æ®µæ ‘æ¥ç»´æŠ¤ã€‚ æ—¶é—´å¤æ‚åº¦$O(mlogm)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N=1e6+10;const int M=2e5+10;struct seg_tree&#123; int l,r; int s;&#125;t[N*22];int rot[M&lt;&lt;4],cnt,n,q,answer,pos[M&lt;&lt;4],a[M&lt;&lt;4];void insert(int &amp;root,int l,int r,int posi,int last)&#123; root=++cnt; t[root].l=t[last].l,t[root].r=t[last].r; t[root].s=t[last].s+1; if(l==r) return; int mid=l+r&gt;&gt;1; if(posi&lt;=mid) insert(t[root].l,l,mid,posi,t[last].l); if(posi&gt;mid) insert(t[root].r,mid+1,r,posi,t[last].r);&#125;int query(int root,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) return t[root].s; int mid=l+r&gt;&gt;1,A=0; if(ll&lt;=mid) A+=query(t[root].l,l,mid,ll,rr); if(rr&gt;mid) A+=query(t[root].r,mid+1,r,ll,rr); return A;&#125;int get_read()&#123; return (read()+answer-1)%n+1;&#125;int main(int argc, char const *argv[])&#123; n=read(); for(register int i=1,x;i&lt;=n;++i) x=read(),pos[x]=i; for(register int i=1,x;i&lt;=n;++i) x=read(),a[i]=pos[x]; for(register int i=1;i&lt;=n;++i) insert(rot[i],1,n,a[i],rot[i-1]); q=read(); while(q--) &#123; int A=get_read(),B=get_read(),C=get_read(),D=get_read(); if(A&gt;B) swap(A,B); if(C&gt;D) swap(C,D); printf("%d\n",answer=query(rot[D],1,n,A,B)-query(rot[C-1],1,n,A,B)); ++answer; &#125; return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#558 E.A Simple Task]]></title>
    <url>%2F2019%2F02%2F16%2FCodeForces-558-E-A-Simple-Task%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜E.A Simple Taské¢˜é¢This task is very simple. Given a string $S$ of length $n$ and $q$ queries each query is on the format $i\ j\ k$ which means sort the substring consisting of the characters from $i$ to $j$ in non-decreasing order if $k=1$ or in non-increasing order if $k=0$ . Output the final string after applying the queries. ç®€è¦ç¿»è¯‘ç»™å®šä¸€ä¸ªé•¿åº¦ä¸è¶…è¿‡$10^5$çš„å­—ç¬¦ä¸²ï¼ˆå°å†™è‹±æ–‡å­—æ¯ï¼‰ï¼Œå’Œä¸è¶…è¿‡$5Ã—10^4$ä¸ªæ“ä½œã€‚ æ¯ä¸ªæ“ä½œ $L\ R\ K$ è¡¨ç¤ºç»™åŒºé—´$[L,R]$çš„å­—ç¬¦ä¸²æ’åºï¼Œ$K=1$ä¸ºå‡åºï¼Œ$K=0$ä¸ºé™åºã€‚ æœ€åè¾“å‡ºæœ€ç»ˆçš„å­—ç¬¦ä¸²ã€‚ Inputç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•°$n,q$ï¼Œ$n$ä»£è¡¨å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œ$q$ä»£è¡¨è¯¢é—®çš„ä¸ªæ•°ã€‚ ç¬¬äºŒè¡ŒåŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²$S$ã€‚$S$åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚ ä»¥ä¸‹$q$è¡Œæ¯è¡ŒåŒ…å«ä¸‰ä¸ªæ•´æ•°$i\ j\ k$ã€‚ Outputè¾“å‡ºä¸€è¡Œè¡¨ç¤ºç»è¿‡$q$æ¬¡æ“ä½œä¹‹åçš„å­—ç¬¦ä¸²$S$ã€‚ Sample Input 110 5abacdabcda7 10 05 8 11 4 03 6 07 10 1 Sample Output 1cbcaaaabdd Sample Input 210 1agjucbvdfk1 10 1 Sample Output 2abcdfgjkuv Hint$1\le n\le 10^5$ï¼Œ$0\le q\le 50,000$ã€‚ $1\le i\le j\le n$ï¼Œ$kâˆˆ\{0,1\}$ã€‚ æ ·ä¾‹è§£é‡Š1abacdabcda â†’ abacdadcba abacdadcba â†’ abacacddba abacacddba â†’ cbaaacddba cbaaacddba â†’ cbcaaaddba cbcaaaddba â†’ cbcaaaabdd æˆ‘ä»¬ç”¨çº¿æ®µæ ‘æ¥ç»´æŠ¤â€™$a$â€™-â€˜$c$â€™ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æ•°å­—$1$~$26$ä»£æ›¿ã€‚ æˆ‘ä»¬æ¯æ¬¡æ”¹å˜åºåˆ—æ—¶ï¼Œå…ˆæŸ¥è¯¢è¯¥åŒºé—´å†…$1$~$26$æ¯ä¸ªæ•°å‡ºç°çš„æ¬¡æ•°ï¼Œæ’å®Œåºåï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“è¯¥åŒºé—´ä¸€å®šæ˜¯è¿ç»­çš„ä¸€æ®µåŒºé—´ã€‚ å¦‚æœæ˜¯å‡åºï¼Œæˆ‘ä»¬å°±å¯¹æ•´ä¸ªåŒºé—´ä»å°åˆ°å¤§è¦†ç›–ã€‚ å¦‚æœæ˜¯é™åºï¼Œé‚£å°±ä»å¤§åˆ°å°è¦†ç›–ã€‚ æœ€åéå†ä¸€éçº¿æ®µæ ‘è¾“å‡ºå³å¯ã€‚ æ€»æ—¶é—´å¤æ‚åº¦ä¸º$O(26nlogn)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N=100010;struct seg_tree&#123; bool is_changed[28]; int letter[28]; int l,r;&#125;t[N&lt;&lt;2];struct node&#123; int g[28];&#125;;void clear(node &amp;g)&#123; for(int i=1;i&lt;=26;++i) g.g[i]=0;&#125;int n,q,a[N];char c[N];void pushup(int root)&#123; for(int i=1;i&lt;=26;++i) t[root].letter[i]=t[root&lt;&lt;1].letter[i]+t[root&lt;&lt;1|1].letter[i];&#125;void build(int root,int l,int r)&#123; t[root].l=l,t[root].r=r; if(l==r) &#123; ++t[root].letter[a[l]]; return; &#125; int mid=l+r&gt;&gt;1; build(root&lt;&lt;1,l,mid); build(root&lt;&lt;1|1,mid+1,r); pushup(root);&#125;void pushdown(int root,int l,int r)&#123; if(t[root].l==t[root].r) return; for(int i=1;i&lt;=26;++i) if(t[root].is_changed[i]) &#123; for(int j=1;j&lt;=26;++j) &#123; t[root&lt;&lt;1].is_changed[j]=0; t[root&lt;&lt;1].letter[j]=0; t[root&lt;&lt;1|1].is_changed[j]=0; t[root&lt;&lt;1|1].letter[j]=0; &#125; t[root&lt;&lt;1].is_changed[i]=1; t[root&lt;&lt;1].letter[i]=t[root&lt;&lt;1].r-t[root&lt;&lt;1].l+1; t[root&lt;&lt;1|1].is_changed[i]=1; t[root&lt;&lt;1|1].letter[i]=t[root&lt;&lt;1|1].r-t[root&lt;&lt;1|1].l+1; t[root].is_changed[i]=0; &#125;&#125;node add(node a,node b)&#123; node g; clear(g); for(int i=1;i&lt;=26;++i) g.g[i]=a.g[i]+b.g[i]; return g;&#125;node query(int root,int l,int r,int ll,int rr)&#123; if(r&lt;ll||l&gt;rr) &#123; node g; clear(g); return g; &#125; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123; node g; clear(g); for(int i=1;i&lt;=26;++i) g.g[i]=t[root].letter[i]; return g; &#125; pushdown(root,l,r); int mid=l+r&gt;&gt;1; node g; clear(g); if(ll&lt;=mid) g=add(g,query(root&lt;&lt;1,l,mid,ll,rr)); if(rr&gt;mid) g=add(g,query(root&lt;&lt;1|1,mid+1,r,ll,rr)); return g;&#125;void change(int root,int l,int r,int ll,int rr,int k)&#123; if(r&lt;ll||l&gt;rr) return; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123; for(int i=1;i&lt;=26;++i) t[root].letter[i]=t[root].is_changed[i]=0; t[root].is_changed[k]=1; t[root].letter[k]=t[root].r-t[root].l+1; return; &#125; pushdown(root,l,r); int mid=l+r&gt;&gt;1; if(ll&lt;=mid) change(root&lt;&lt;1,l,mid,ll,rr,k); if(rr&gt;mid) change(root&lt;&lt;1|1,mid+1,r,ll,rr,k); pushup(root);&#125;void push_all_down(int root,int l,int r)&#123; pushdown(root,l,r); if(l==r) return; int mid=l+r&gt;&gt;1; push_all_down(root&lt;&lt;1,l,mid); push_all_down(root&lt;&lt;1|1,mid+1,r);&#125;void print(int root,int l,int r)&#123; if(l==r) &#123; for(int i=1;i&lt;=26;++i) if(t[root].letter[i]) &#123; putchar((char)((int)'a'+i-1)); return; &#125; &#125; int mid=l+r&gt;&gt;1; print(root&lt;&lt;1,l,mid); print(root&lt;&lt;1|1,mid+1,r);&#125;int main(int argc, char const *argv[])&#123; n=read(),q=read(); scanf("%s",c+1); for(int i=1;i&lt;=n;++i) a[i]=c[i]-'a'+1; build(1,1,n); while(q--) &#123; int l=read(),r=read(),k=read(); node g=query(1,1,n,l,r); for(int i=(k==1? 1:26);(k==1? i&lt;=26:i&gt;=1);l+=g.g[(k==1? i++:i--)]) change(1,1,n,l,l+g.g[i]-1,i); &#125; push_all_down(1,1,n); print(1,1,n); return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Regular Contest#068 E.Snuke Line]]></title>
    <url>%2F2019%2F02%2F16%2FAtcoder-Regular-Contest-068-E-Snuke-Line%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜E.Snuke Lineé¢˜é¢Snuke has decided to play a game, where the player runs a railway company. There are $M+1$ stations on Snuke Line, numbered $0$ through $M$. A train on Snuke Line stops at station $0$ and every $d$-th station thereafter, where $d$ is a predetermined constant for each train. For example, if $d=3$, the train stops at station $0, 3, 6, 9$, and so forth. There are $Nâ€‹$ kinds of souvenirs sold in areas around Snuke Line. The $iâ€‹$-th kind of souvenirs can be purchased when the train stops at one of the following stations: stations $l_i,l_i+1,l_i+2,â€¦r_iâ€‹$. There are M values of d, the interval between two stops, for trains on Snuke Line: $1, 2, 3, â€¦, M$. For each of these $M$ values, find the number of the kinds of souvenirs that can be purchased if one takes a train with that value of d at station $0$. Here, assume that it is not allowed to change trains. ç®€è¦ç¿»è¯‘æœ‰$m$ä¸ªç‚¹é›†ï¼Œç¬¬$i$ä¸ªç‚¹é›†åŒ…å«$0$è‡³$m$ä¸­ç¼–å·æ˜¯$i$çš„å€æ•°çš„ç‚¹ã€‚ ç»™å®š$n$ä¸ªåŒºé—´ï¼Œå¯¹äºæ¯ä¸ªç‚¹é›†ï¼Œæ±‚å‡ºæœ‰å¤šå°‘ä¸ªåŒºé—´åŒ…å«ç‚¹é›†å†…çš„è‡³å°‘ä¸€ä¸ªç‚¹ã€‚ æˆ–è€…è¯´æ˜¯ï¼š æœ‰$n$ä¸ªåŒºé—´ï¼Œç°åœ¨è¯¢é—®ä½ å¯¹äº$1\le i\le m$çš„æ¯ä¸ª$i$ï¼Œæœ‰å¤šå°‘ä¸ªåŒºé—´è‡³å°‘åŒ…å«ä¸€ä¸ª$i$çš„å€æ•°ï¼Ÿ Inputè¾“å…¥çš„æ ‡å‡†æ ¼å¼å¦‚ä¸‹ï¼š 1234N Ml1 r1:lN rN Outputè¾“å‡ºç­”æ¡ˆ$M$è¡Œã€‚ç¬¬$i$-thè¡ŒåŒ…å«åœåœ¨$d$ç«™çš„ç­”æ¡ˆã€‚ Sample Input 13 31 22 33 3 Sample Output 1322 Sample Input 27 91 75 95 75 91 16 83 4 Sample Output 2766545532 Hint$1\le M\le 10^5$ $1\le N\le 3Ã—10^5$ $1\le l_i\le r_i\le M$ æˆ‘ä»¬å¦‚æœæŒ‰é¢˜ç›®å»é¢˜æ„å»åšï¼Œæˆ‘ä¹Ÿä¸çŸ¥é“æ€ä¹ˆæƒ³ã€‚ æˆ‘ä»¬åç€æ€è€ƒï¼Œå¦‚æœä¸€ä¸ªåŒºé—´ä¸­æ²¡æœ‰$iâ€‹$çš„å€æ•°ï¼Œé‚£ä¹ˆå®ƒä¸€å®šæ˜¯è¢«ç›¸é‚»çš„ä¸¤ä¸ª$iâ€‹$çš„å€æ•°å¤¹åœ¨ä¸­é—´äº†ï¼Œæˆ–æ˜¯åœ¨æœ€å¤§çš„$iâ€‹$çš„å€æ•°çš„å³è¾¹äº†ã€‚ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å…ˆè¯»å…¥æ‰€æœ‰çš„æ•°æ®å†ç”¨å¯æŒä¹…åŒ–çº¿æ®µæ ‘ç¦»çº¿å¤„ç†å•¦ï¼ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int M=100010;const int N=300010;struct seg_tree&#123; int cnt,l,r;&#125;t[N&lt;&lt;5];int cnt_sgt,p[M],n,m;struct rg&#123; int l,r; friend bool operator &lt; (rg a,rg b) &#123; return a.l&lt;b.l; &#125;&#125;rg[N];void pushup(int root)&#123; t[root].cnt=t[t[root].l].cnt+t[t[root].r].cnt;&#125;void insert(int &amp;root,int l,int r,int x)&#123; t[++cnt_sgt]=t[root],root=cnt_sgt; if(l==r) &#123; t[root].cnt++; return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid) insert(t[root].l,l,mid,x); else insert(t[root].r,mid+1,r,x); pushup(root);&#125;int query(int root1,int root2,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) return t[root2].cnt-t[root1].cnt; int mid=l+r&gt;&gt;1; int s=0; if(ll&lt;=mid) s+=query(t[root1].l,t[root2].l,l,mid,ll,rr); if(rr&gt;mid) s+=query(t[root1].r,t[root2].r,mid+1,r,ll,rr); return s;&#125;int main(int argc, char const *argv[])&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) rg[i].l=read(),rg[i].r=read(); sort(rg+1,rg+1+n); int q=1; for(int i=1;i&lt;=m;++i) &#123; p[i]=p[i-1]; while(rg[q].l==i) insert(p[i],1,m,rg[q++].r); &#125; printf("%d\n",n); for(int i=2;i&lt;=m;++i) &#123; int answer=n,j; for(j=i;j&lt;=m;j+=i) answer-=query(p[j-i],p[j-1],1,m,j-i+1,j-1); if(j-i+1&lt;=m) answer-=query(p[j-i],p[m],1,m,j-i+1,m); printf("%d\n",answer); &#125; return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-18.FEB Snow Boots S]]></title>
    <url>%2F2019%2F02%2F16%2FUSACO-18-FEB-Snow-Boots-S%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜#.Snow Boots Sé¢˜é¢åˆ°å†¬å¤©äº†ï¼Œè¿™æ„å‘³ç€ä¸‹é›ªäº†ï¼ä»å†œèˆåˆ°ç‰›æ£šçš„è·¯ä¸Šæœ‰$N$å—åœ°ç –ï¼Œæ–¹ä¾¿èµ·è§ç¼–å·ä¸º$1â€¦N$ï¼Œç¬¬iå—åœ°ç –ä¸Šç§¯äº†$f_i$è‹±å°ºçš„é›ª ã€‚åœ¨$Farmer John$çš„å†œèˆçš„åœ°çª–ä¸­ï¼Œæ€»å…±æœ‰$B$åŒé´å­ï¼Œç¼–å·ä¸º$1â€¦B$ã€‚å…¶ä¸­æŸäº›æ¯”å¦ä¸€äº›ç»“å®ï¼ŒæŸäº›æ¯”å¦ä¸€äº›è½»ä¾¿ã€‚å…·ä½“åœ°è¯´ï¼Œç¬¬iåŒé´å­èƒ½å¤Ÿè®©$FJ$åœ¨è‡³å¤š$s_i$è‹±å°ºæ·±çš„ç§¯é›ªä¸­è¡Œèµ°ï¼Œèƒ½å¤Ÿè®©$FJ$æ¯æ­¥è‡³å¤šå‰è¿›$d_i$ã€‚$Farmer John$ä»$1$å·åœ°ç –å‡ºå‘ï¼Œä»–å¿…é¡»åˆ°è¾¾$N$å·åœ°ç –æ‰èƒ½å«é†’å¥¶ç‰›ä»¬ã€‚$1$å·åœ°ç –åœ¨å†œèˆçš„å±‹æªä¸‹ï¼Œ$N$å·åœ°ç –åœ¨ç‰›æ£šçš„å±‹æªä¸‹ï¼Œæ‰€ä»¥è¿™ä¸¤å—åœ°ç –éƒ½æ²¡æœ‰ç§¯é›ªã€‚å¸®åŠ©$Farmer John$æ±‚å‡ºå“ªäº›é´å­å¯ä»¥å¸®åŠ©ä»–èµ°å®Œè¿™æ®µè‰°è¾›çš„è·¯ç¨‹ã€‚ Inputç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªç©ºæ ¼åˆ†éš”çš„æ•´æ•°$N$å’Œ$B$ã€‚ ç¬¬äºŒè¡ŒåŒ…å«$Nâ€‹$ä¸ªç©ºæ ¼åˆ†éš”çš„æ•´æ•°ï¼›ç¬¬$iâ€‹$ä¸ªæ•´æ•°ä¸º$f_iâ€‹$ï¼Œå³$iâ€‹$å·åœ°ç –çš„ç§¯é›ªæ·±åº¦ã€‚ ä¸‹é¢$B$è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸¤ä¸ªç©ºæ ¼åˆ†éš”çš„æ•´æ•°ã€‚ç¬¬$i+2$è¡Œçš„ç¬¬ä¸€ä¸ªæ•°ä¸º$s_i$ï¼Œè¡¨ç¤ºç¬¬$i$åŒé´å­èƒ½å¤Ÿæ‰¿å—çš„æœ€å¤§ç§¯é›ªæ·±åº¦ã€‚ ç¬¬$i+2$è¡Œçš„ç¬¬äºŒä¸ªæ•°ä¸º$d_i$ï¼Œè¡¨ç¤ºç¬¬$i$åŒé´å­çš„æœ€å¤§æ­¥é•¿ã€‚ Outputè¾“å‡ºåŒ…å«$N$è¡Œã€‚ç¬¬$iè¡Œ$åŒ…å«ä¸€ä¸ªæ•´æ•°ï¼šå¦‚æœ$FarmerJohn$èƒ½å¤Ÿç©¿ç€ç¬¬$i$åŒé´å­ä»$1$å·åœ°ç –èµ°åˆ°$N$å·åœ°ç –ï¼Œä¸º$1$ï¼Œå¦åˆ™ä¸º$0$ã€‚ Sample Input8 7 0 3 8 5 6 9 0 0 0 5 0 6 6 2 8 1 10 1 5 3 150 7 Sample Output0 1 1 0 1 1 1 Hintè¾“å…¥ä¿è¯$f_1=f_N=0â€‹$ ï¼Œ$0â‰¤s_iâ‰¤10^9â€‹$ã€‚ $1â‰¤d_iâ‰¤N-1$ï¼Œ$0â‰¤f_iâ‰¤10^9$ã€‚ $1â‰¤N,Bâ‰¤10^5â€‹$ã€‚ æˆ‘å…ˆå¼ƒä¸ªå‘ã€‚ 12]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#438 D.The Child and Sequence]]></title>
    <url>%2F2019%2F02%2F16%2FCodeForces-438-D-The-Child-and-Sequence%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜#.The Child and Sequenceé¢˜é¢At the childrenâ€™s day, the child came to Picksâ€™s house, and messed his house up. Picks was angry at him. A lot of important things were lost, in particular the favorite sequence of Picks. Fortunately, Picks remembers how to repair the sequence. Initially he should create an integer array $a[1],a[2],â€¦,a[n]$ . Then he should perform a sequence of $m$ operations. An operation can be one of the following: Print operation $l,r$ . Picks should write down the value of $\sum_{i=l}^ra[i]$. Modulo operation $l,r,x$ . Picks should perform assignment $ a[i]=a[i]\ mod\ x $ for each $i$ $(l\le i\le r) $ . Set operation $k,x$ . Picks should set the value of $a[k]$ to $x$ (in other words perform an assignment $a[k]=x$ ). Can you help Picks to perform the whole sequence of op erations? ç®€è¦ç¿»è¯‘ç»™å®šä½ ä¸€ä¸ªæ•°åˆ—ï¼Œè¦æ±‚æ”¯æŒåŒºé—´å’ŒæŸ¥è¯¢ï¼ŒåŒºé—´å–æ¨¡ï¼Œå•ç‚¹ä¿®æ”¹ã€‚ Inputç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•°$n,m$ã€‚ ç¬¬äºŒè¡ŒåŒ…å«ç”¨ç©ºæ ¼éš”å¼€çš„$n$ä¸ªæ•´æ•°ï¼Œ$a[1],a[2],a[3]â€¦a[n]$ä»£è¡¨åºåˆ—çš„å€¼ã€‚ ä¸‹é¢åŒ…å«$m$è¡Œã€‚æ¯è¡Œå¼€å¤´åŒ…å«ä¸€ä¸ªæ•´æ•°$type$è¡¨ç¤ºæ“ä½œç±»å‹ã€‚ è‹¥$type=1$ï¼Œåé¢è·Ÿç€ä¸¤ä¸ªæ•´æ•°$l,r$ï¼Œæ±‚$sum[l,r]$ è‹¥$type=2$ï¼Œåé¢è·Ÿç€ä¸‰ä¸ªæ•´æ•°$l,r,x$ï¼Œè¡¨ç¤ºåŒºé—´$[l,r]$å¯¹$x$å–æ¨¡ã€‚ è‹¥$type=3$ï¼Œåé¢è·Ÿç€ä¸¤ä¸ªæ•´æ•°$k,x$ï¼Œè¡¨ç¤ºå°†$a[k]$ä¿®æ”¹ä¸º$x$ã€‚ Outputå¯¹äºæ¯ä¸ªæ“ä½œ$1$ï¼Œè¾“å‡ºä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚ æ³¨æ„ï¼Œç­”æ¡ˆå¯èƒ½ä¼šè¶…å‡º$int$ã€‚ Sample Input 15 51 2 3 4 52 3 5 43 3 51 2 52 1 3 31 1 3 Sample Output 18 5 Sample Input 210 106 9 6 7 6 1 10 10 9 51 3 92 7 10 92 5 10 81 4 73 3 72 7 9 91 2 41 6 61 5 93 1 10 Sample Output 249152319 Hint$1\le n,m\le 10^5,1\le a[i]\le 10^9$ã€‚ $typeâˆˆ\{1,2,3\}$ã€‚ æ“ä½œ$1$ä¸­ï¼Œ$1\le l\le r\le n$ã€‚ æ“ä½œ$2$ä¸­ï¼Œ$1\le l\le r\le n,1\le x\le 10^9$ã€‚ æ“ä½œ$3$ä¸­ï¼Œ$1\le k\le n,1\le x\le 10^9$ã€‚ æ ·ä¾‹è§£é‡ŠÎ£(âŠ™â–½âŠ™â€aéœ€è¦è§£é‡Šå˜›ï¼Ÿå¥½å§è¿˜æ˜¯è§£é‡Šä¸€ä¸‹å§wwwï¼Œåªè§£é‡Šæ ·ä¾‹ä¸€å“¦ ä¸€å¼€å§‹,$a=1,2,3,4,5$ã€‚ ç¬¬$1$æ¬¡æ“ä½œï¼Œ$a=1,2,3,0,1$ã€‚ ç¬¬$2$æ¬¡æ“ä½œï¼Œ$a=1,2,5,0,1$ã€‚ ç¬¬$3$æ¬¡æ“ä½œï¼Œ$Ans=2+5+0+1=8$ã€‚ ç¬¬$4$æ¬¡æ“ä½œï¼Œ$a=1,2,2,0,1$ã€‚ ç¬¬$5$æ¬¡æ“ä½œï¼Œ$Ans=1+2+2=5$ã€‚ è¿™é“é¢˜å•Šï¼Œæ“ä½œ$1$å’Œ$3â€‹$éƒ½æ˜¯æ¨¡æ¿é¢˜å§ï¼Ÿ é‚£ä¹ˆï¼Œæ“ä½œ$2$æ€ä¹ˆåŠå‘¢ï¼Ÿ å¯¹äºæ“ä½œ$2$æˆ‘ä»¬æƒ³ï¼š å¦‚æœæˆ‘ä»¬åŸæ¥çš„$a_i&lt;x$çš„è¯å‘¢ï¼Ÿé‚£ä¹ˆæˆ‘ä»¬å°±ä¸éœ€è¦å–æ¨¡äº†ï¼Œè¿™æ ·å°±å¯ä»¥èŠ‚çº¦æ—¶é—´ã€‚ è‹¥æœæˆ‘ä»¬åŸæ¥çš„$a_i&gt;=x$çš„è¯ï¼Œæˆ‘ä»¬å°±å¯ä»¥æš´åŠ›ç»´æŠ¤ã€‚å› ä¸ºæˆ‘ä»¬å¯ä»¥è¯æ˜ï¼Œä¸€ä¸ªæ•°æœ€å¤šè¢«æ¨¡$log\ a_i$æ¬¡ï¼Œä¸æ‡‚å¾—è¯å°±è‡ªå·±æ‰‹æ¨ä¸€æ³¢å§ï¼Œå¾ˆå¿«çš„ã€‚ æ‰€ä»¥è¯´ï¼Œæˆ‘ä»¬åªéœ€è¦ç»´æŠ¤åŒºé—´æœ€å¤§å€¼ï¼Œå¦‚æœæœ€å¤§å€¼å°äº$x$çš„è¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ç›´æ¥åœ¨$change$é‡Œç›´æ¥$return$å°±å¥½äº†ã€‚ çº¿æ®µæ ‘æœ¬èº«æ—¶é—´å¤æ‚åº¦$O(nlog\ n)$ï¼Œä¹˜$log \ a_i$ï¼Œæ‰€ä»¥æ€»æ—¶é—´å¤æ‚åº¦ä¸º$O(nlog(n)loga_(i))â€‹$ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;int n,m;const int N=100010;struct seg_tree&#123; long long s; long long Max;&#125;t[N&lt;&lt;2];int a[N];void pushup(int root)&#123; t[root].s=t[root&lt;&lt;1].s+t[root&lt;&lt;1|1].s; t[root].Max=max(t[root&lt;&lt;1].Max,t[root&lt;&lt;1|1].Max);&#125;void build(int root,int l,int r)&#123; if(l==r) &#123; t[root].s=t[root].Max=a[l]; return; &#125; int mid=l+r&gt;&gt;1; build(root&lt;&lt;1,l,mid); build(root&lt;&lt;1|1,mid+1,r); pushup(root);&#125;void change(int root,int l,int r,int pos,int k)&#123; if(l==r) &#123; t[root].s=t[root].Max=k; return; &#125; int mid=l+r&gt;&gt;1; if(pos&lt;=mid) change(root&lt;&lt;1,l,mid,pos,k); if(pos&gt;mid) change(root&lt;&lt;1|1,mid+1,r,pos,k); pushup(root);&#125;void mod_it(int root,int l,int r,int ll,int rr,int mod)&#123; if(t[root].Max&lt;mod) return; if(l==r) &#123; t[root].s%=mod; t[root].Max%=mod; return; &#125; int mid=l+r&gt;&gt;1; if(ll&lt;=mid) mod_it(root&lt;&lt;1,l,mid,ll,rr,mod); if(rr&gt;mid) mod_it(root&lt;&lt;1|1,mid+1,r,ll,rr,mod); pushup(root);&#125;long long query(int root,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) return t[root].s; int mid=l+r&gt;&gt;1; long long t=0; if(ll&lt;=mid) t+=query(root&lt;&lt;1,l,mid,ll,rr); if(rr&gt;mid) t+=query(root&lt;&lt;1|1,mid+1,r,ll,rr); return t;&#125;int main(int argc, char const *argv[])&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); build(1,1,n); while(m--) &#123; int type=read(); if(type==1) &#123; int l=read(),r=read(); printf("%lld\n",query(1,1,n,l,r)); &#125; else if(type==2) &#123; int l=read(),r=read(),mod=read(); mod_it(1,1,n,l,r,mod); &#125; else &#123; int pos=read(),k=read(); change(1,1,n,pos,k); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#12 D.Ball]]></title>
    <url>%2F2019%2F02%2F15%2FCodeForces-12-D-Ball%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜#.Ballé¢˜é¢$Nâ€‹$ ladies attend the ball in the Kingâ€™s palace. Every lady can bedescribed with three values: beauty, intellect and richness. Kingâ€™s Master of Ceremonies knows that ladies are very special creatures. If some lady understands that there is other lady at the ball which is more beautiful, smarter and more rich, she can jump out of the window. He knows values of all ladies and wants to find out how many probable self-murderers will be on the ball. Lets denote beauty of the $iâ€‹$-th lady by $B_iâ€‹$ , her intellect by $I_iâ€‹$ and her richness by $R_iâ€‹$ . Then $iâ€‹$-th lady is a probable self-murderer if there is some $jâ€‹$-th lady that $B_i&lt;B_j,I_i&lt;I_j,R_i&lt;R_jâ€‹$ . Find the number of probable self-murderers. ç®€è¦ç¿»è¯‘æœ‰Nä¸ªå¥³å£«å»å‚åŠ èˆä¼šã€‚æ¯ä¸ªå¥³å£«æœ‰ä¸‰ä¸ªå€¼a[i],b[i],c[i]ã€‚å¦‚æœä¸€ä½å¥³å£«å‘ç°æœ‰å…¶å®ƒå¥³å£«çš„è¿™ä¸‰ä¸ªå€¼éƒ½æ¯”è‡ªå·±é«˜çš„è¯å°±ä¼šå»è·³æ¥¼.æ±‚æœ‰å¤šå°‘è·³æ¥¼çš„å¥³å£«ã€‚ Inputç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°$N$ã€‚ ç¬¬äºŒè¡ŒåŒ…å«$Nâ€‹$ä¸ªæ•´æ•°$B_iâ€‹$ã€‚ ç¬¬ä¸‰è¡ŒåŒ…å«$Nâ€‹$ä¸ªæ•´æ•°$I_iâ€‹$ã€‚ ç¬¬å››è¡ŒåŒ…å«$N$ä¸ªæ•´æ•°$R_i$ã€‚ Outputè¾“å‡ºä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚ Sample Input31 4 24 3 22 5 3 Sample Output1 Hint$1\leq N\leq 500,000,0\leq B_i,I_i,R_i\leq 10^9$ã€‚ è¿™é¢˜ç›¸å½“äºç»™äº†ä½ $n$ä¸ªä¸‰å…ƒç»„ï¼Œæˆ‘ä»¬å…ˆå°†ä¸€ç»´ç¦»æ•£åŒ–ä¹˜çº¿æ®µæ ‘çš„ä¸‹æ ‡ï¼Œç„¶åå¯¹å‰©ä¸‹ä¸¤ç»´ä¸­çš„ä¸€ç»´é™åºæ’åºï¼Œæœ€åç”¨çº¿æ®µæ ‘æ¥å¤„ç†å‰©ä¸‹ä¸€ç»´ã€‚å°±éå¸¸okäº†ï¼ Code12]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1024 Max Sum Plus Plus]]></title>
    <url>%2F2019%2F02%2F15%2FHDU-1024-Max-Sum-Plus-Plus%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜C.Max Sum Plus PlusNow I think you have got an AC in Ignatius.Lâ€™s â€œMax Sumâ€ problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem. Given a consecutive number sequence $S_1,S_2,S_3,S_4â€¦S_x,â€¦S_n$. We define a function $sum(i,j)=S_i+â€¦+S_j$($1\leq i\leq j\leq nâ€‹$). Now given an integer m ($m &gt; 0$), your task is to find $m$ pairs of $i$ and $j$ which make $sum(i_1,j_1)+sum(i_2,j_2)+â€¦+sum(i_m,j_m)$ maximal ($i_x\leq i_y\leq j_x\ or\ \ i_x\leq j_y\leq j_x$ is not allowed). But Iâ€™m lazy, I donâ€™t want to write a special-judge module, so you donâ€™t have to output $m$ pairs of $i$ and $j$, just output the maximal summation of $sum(i_x,j_x)$($1\leq x\leq m$) instead. ç®€è¦ç¿»è¯‘ç»™å‡ºä¸€åˆ—æ•°$\{a_n\}â€‹$ ï¼Œä»ä¸­é€‰å‡º$ğ‘šâ€‹$ä¸ªäº’ä¸ç›¸äº¤çš„å­æ®µï¼Œä½¿å¾—å’Œæœ€å¤§ï¼Œæ±‚è¿™ä¸ªæœ€å¤§å€¼ã€‚ Inputå¯¹äºæ¯ç»„æ•°æ®ï¼Œéƒ½å ä¸€è¡Œã€‚ æ¯ä¸€è¡Œå‰é¢æœ‰ä¸¤ä¸ªæ•´æ•°$m,n$ï¼Œä¹‹ååˆ$n$ä¸ªæ•´æ•°$S_1,S_2,S_3â€¦S_nâ€‹$ç›´åˆ°æ–‡ä»¶ç»“æŸã€‚ Outputæ¯ç»„æ•°æ®è¾“å‡ºä¸€ä¸ªæ•°è¡¨ç¤ºç­”æ¡ˆã€‚ Sample Input1 3 1 2 3 2 6 -1 4 -2 3 -2 3 Sample Output6 8 Hintè¾“å…¥æ•°æ®å¾ˆå¤§ï¼Œ$scanfâ€‹$ä»€ä¹ˆçš„å¯èƒ½ä¼šè¢«å¡æ‰å“¦~ $1\leq m\leq n\leq 1,000,000,-32768\leq S_x\leq32767$ å¦‚æœæ­£æ•´æ•°çš„ä¸ªæ•°å°äº$m$ä¸ªï¼Œé‚£ä¹ˆåªè¦é€‰å–å‰$m$å¤§çš„æ•°å³å¯ã€‚ æˆ‘ä»¬å°±èƒ½å¤Ÿç”±è¿™æ ·çš„æ€æƒ³æ¥æƒ³åˆ°ç”¨çº¿æ®µæ ‘ç»´æŠ¤è¿™ä¸ªåºåˆ—ï¼Œæ¯ä¸€æ¬¡é€‰å–æ•´ä¸ªåºåˆ—çš„æœ€å¤§å­æ®µï¼Œå°†å’Œç´¯åŠ åˆ°ç­”æ¡ˆä¸­ã€‚ ç„¶åæˆ‘ä»¬æŠŠè¿™æ®µæ­£é¢˜éƒ½$Ã—(-1)$ï¼Œä¸‹æ¬¡å†æ¬¡é€‰ä¸­ï¼Œé‚£ä¹ˆå°±å»æ‰åŸæ¥æ‰€é€‰çš„éƒ¨åˆ†ï¼Œè¿™æ ·å°±å¾ˆå·§å¦™çš„é‡‡ç”¨äº†é¢˜æ„ã€‚ æˆ‘ä»¬æ“ä½œ$m$æ¬¡ï¼Œå¦‚æœé‡åˆ°äº†è´Ÿæ•°ï¼Œé‚£ä¹ˆå°±å·²ç»å¯ä»¥åœæ­¢äº†(è´Ÿæ•°åªä¼šä½¿ç­”æ¡ˆæ›´å°)ï¼Œå› ä¸ºæ­¤æ—¶æˆ‘ä»¬å·²ç»å¾—åˆ°äº†ç­”æ¡ˆã€‚ å¦‚æœæ­£æ•´æ•°çš„ä¸ªæ•°å¤§äºç­‰äº$m$ï¼Œé‚£ä¹ˆæœ€ç»ˆé€‰å–çš„æ®µæ•°ä¸€å®šå¤§äº$m$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±èƒ½å¤Ÿæ‹†æˆ$m$æ®µã€‚ æ‰€ä»¥æˆ‘ä»¬å°±éœ€è¦ç»´æŠ¤åŒºé—´æœ€å¤§ã€æœ€å°å€¼ï¼ŒåŒºé—´å‰ç¼€æœ€å¤§ã€æœ€å°å€¼ï¼ŒåŒºé—´åç¼€æœ€å¤§ã€æœ€å°å€¼(æˆ‘ä»¬$Ã—(-1)$çš„æ“ä½œéœ€è¦ç»´æŠ¤æœ€å°å€¼)ã€‚ æ€»æ—¶é—´å¤æ‚åº¦ä¸º$O(m\ logn)$ã€‚ Code1//æˆ‘æˆ‘æˆ‘â€¦â€¦â€¦â€¦æ‡’å¾—æ‰“â€¦â€¦â€¦â€¦]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#242 E.XOR on Segment]]></title>
    <url>%2F2019%2F02%2F15%2FCodeForces-242-E-XOR-on-Segment%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜A.XOR on Segmenté¢˜é¢Youâ€™ve got an array $a$ , consisting of $n$ integers $a_1$,$a_2$,â€¦,$a_n$. You are allowed to perform two operations on this array: Calculate the sum of current array elements on the segment $[l,r]$ , that is, count value $a_l+a_{l+1}+â€¦+a_r$ . Apply the $xor$ operation with $a$ given number $x$ to each array element on the segment $[l,r]$ , that is, execute . This operation changes exactly $r-l+1$ array elements. Expression means applying bitwise xor operation to numbers $x$ and $y$ . The given operation exists in all modern programming languages, for example in language $C++$ and Java it is marked as â€œ^â€, in Pascal â€” as â€œ$xor$â€. Youâ€™ve got a list of m m m operations of the indicated type. Your task is to perform all given operations, for each sum query you should print the result you get. ç®€è¦ç¿»è¯‘ç»™å®šä¸€ä¸ªé•¿ä¸º$n$($n\leq10^5$)çš„æ•°ç»„ æ•°ç»„é‡Œçš„æ•°ä¸è¶…è¿‡$10^6$ æœ‰ä¸¤ç§æ“ä½œï¼š 1:æ±‚$sum[l,r]$; 2:å¯¹$[l,r]$ä¸­çš„æ‰€æœ‰æ•°å’Œ$x$å¼‚æˆ– Inputç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°$n$ï¼Œè¡¨ç¤ºæ•°ç»„çš„é•¿åº¦ã€‚ ç¬¬äºŒè¡ŒåŒ…å«ç”¨ç©ºæ ¼éš”å¼€çš„$n$ä¸ªæ•´æ•°ï¼Œ$a_1,a_2,a_3,â€¦,a_n$è¡¨ç¤ºæ•°ç»„ã€‚ ç¬¬ä¸‰è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°$m$ï¼Œè¡¨ç¤ºæ“ä½œçš„ä¸ªæ•°ã€‚ ä¸‹é¢åŒ…å«$m$è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°$t_i$ï¼Œè¡¨ç¤ºæ“ä½œçš„ç±»å‹ã€‚ å½“$t_i=1$æ—¶ï¼Œä¹‹ååŒ…å«2ä¸ªæ•´æ•°$l,r$ï¼Œæ±‚$sum[l,r]$ã€‚ å½“$t_i=2$æ—¶ï¼Œä¹‹ååŒ…å«3ä¸ªæ•´æ•°$l,r,x$ï¼Œå¯¹$[l,r]$çš„æ•°ä¸$x$è¿›è¡Œå¼‚æˆ–æ“ä½œã€‚ Outputå¯¹äºæ¯ä¸ªæ“ä½œ$1$ï¼Œè¾“å‡ºä¸€è¡Œä¸€ä¸ªæ•´æ•°ä»£è¡¨ç­”æ¡ˆã€‚ è¯·ä¸è¦ä½¿ç”¨â€$\%lldâ€‹$â€å»è¯»å…¥æˆ–è¾“å‡º$long\ longâ€‹$ï¼›ä½ æœ€å¥½ä½¿ç”¨â€$cinâ€‹$,$coutâ€‹$â€æˆ–è€…â€$\%I64dâ€‹$â€ã€‚ Sample Input 154 10 3 13 781 2 42 1 3 31 2 41 3 32 2 5 51 1 52 1 2 101 2 3 Sample Output 126 22 0 34 11 Sample Input 264 7 4 0 7 352 2 3 81 1 52 3 5 12 4 5 61 2 3 Sample Output 238 28 Hint$1\leq n\leq 10^5ï¼Œ0\leq a_i\leq 10^6$ã€‚ $1\leq m\leq 5Ã—10^4$ï¼Œ$t=1\ or\ 2$ã€‚ $1\leq l_i\leq r_i\leq n$ï¼Œ$1\leq x_i\leq 10^6$ã€‚ åŒºé—´çš„å¼‚æˆ–éš¾ä»¥ç»´æŠ¤ã€‚ æˆ‘ä»¬å¯ä»¥æŠŠæ‰€æœ‰çš„æ•°æ‹†æˆäºŒè¿›åˆ¶çš„ï¼Œé‚£ä¹ˆç”±æ•°æ®èŒƒå›´å¯çŸ¥ï¼Œæ¯ä¸ªæ•°çš„äºŒè¿›åˆ¶ä½æ•°ä¸è¶…è¿‡20ä½ï¼Œæˆ‘ä»¬å¯ä»¥å»º20æ£µçº¿æ®µæ ‘ã€‚ æ¯ä¸€æ£µçº¿æ®µæ ‘ç»´æŠ¤åŒºé—´å–åï¼Œ$0â†’1$æˆ–$1â†’0$ï¼›åŒºé—´æ±‚å’Œã€‚ æ‰€ä»¥ç”¨ä¸€ä¸ªæ ‡è®°å³å¯è§£å†³ã€‚ æ—¶é—´å¤æ‚åº¦ä¸º$O(nklogn)$ï¼Œ$k$ä¸ºäºŒè¿›åˆ¶è½¬åŒ–çš„ä½æ•°ï¼Œå³æ‰€éœ€çº¿æ®µæ ‘ä¸ªæ•°ï¼Œ$k\leq20$ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N=100010;const int mod=1e9+7;const int inf=0x3f3f3f3f;int n,m;struct seg_tree&#123; int s,Xor;&#125;t[N&lt;&lt;2][22];void pushdown(int root,int len,int bit)&#123; if(!t[root][bit].Xor) return; t[root&lt;&lt;1][bit].s=(len-(len&gt;&gt;1))-t[root&lt;&lt;1][bit].s; t[root&lt;&lt;1|1][bit].s=(len&gt;&gt;1)-t[root&lt;&lt;1|1][bit].s; t[root&lt;&lt;1][bit].Xor^=1,t[root&lt;&lt;1|1][bit].Xor^=1; t[root][bit].Xor=0;&#125;void pushup(int root,int bit)&#123; t[root][bit].s=t[root&lt;&lt;1][bit].s+t[root&lt;&lt;1|1][bit].s;&#125;void change(int root,int l,int r,int ll,int rr,int bit)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123; t[root][bit].Xor^=1; t[root][bit].s=(r-l+1)-t[root][bit].s; return; &#125; pushdown(root,r-l+1,bit); int mid=l+r&gt;&gt;1; if(ll&lt;=mid) change(root&lt;&lt;1,l,mid,ll,rr,bit); if(rr&gt;mid) change(root&lt;&lt;1|1,mid+1,r,ll,rr,bit); pushup(root,bit);&#125;int query(int root,int l,int r,int ll,int rr,int bit)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) return t[root][bit].s; pushdown(root,r-l+1,bit); int mid=l+r&gt;&gt;1,tot=0; if(ll&lt;=mid) tot+=query(root&lt;&lt;1,l,mid,ll,rr,bit); if(rr&gt;mid) tot+=query(root&lt;&lt;1|1,mid+1,r,ll,rr,bit); return tot;&#125;int main(int argc, char const *argv[])&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; int x=read(); for(int j=0;j&lt;=20;++j) if((1&lt;&lt;j)&amp;x) change(1,1,n,i,i,j); &#125; m=read(); while(m--) &#123; int type=read(); if(type==1) &#123; long long ans=0; int l=read(),r=read(); for(int i=20;~i;--i) ans=(ans&lt;&lt;1)+query(1,1,n,l,r,i); cout&lt;&lt;ans&lt;&lt;endl; &#125; else &#123; int l=read(),r=read(),x=read(); for(int i=0;i&lt;=20;++i) if((1&lt;&lt;i)&amp;x) change(1,1,n,l,r,i); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç©¶æçš„æœ€å¤§æµç®—æ³•ISAPä¸HLPPHLPPâ€”â€”é’±é€¸å‡¡]]></title>
    <url>%2F2019%2F02%2F15%2F%E7%A9%B6%E6%9E%81%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AE%97%E6%B3%95ISAP%E4%B8%8EHLPPHLPP__%E9%92%B1%E9%80%B8%E5%87%A1%2F</url>
    <content type="text"><![CDATA[æœ¬æ–‡æ¬è¿è‡ªæ´›è°·å¤§ä½¬é’±é€¸å‡¡çš„åšå®¢ ç©¶çº§çš„æœ€å¤§æµç®—æ³•ï¼šISAPä¸HLPPæœ€å¤§æµçš„å®šä¹‰åŠåŸºç¡€è§£æ³•è¿™é‡Œå°±ä¸å†èµ˜è¿°äº† æœ‰éœ€è¦çš„å¯ä»¥çœ‹ä¹‹å‰å†™çš„åŠ£è´¨æ–‡ç« EKä¸Dinicæ±‚è§£æœ€å¤§æµçš„æ–¹æ³•äº† å‰è¨€æœ€å¤§æµç®—æ³•ç›®å‰æœ‰å¢å¹¿è·¯ç®—æ³•å’Œé¢„æµæ¨è¿›ç®—æ³•ä¸¤ç§ï¼Œå¢å¹¿è·¯ç®—æ³•çš„æ€æƒ³æ˜¯ä¸æ–­åœ°å¯»æ‰¾å¢å¹¿è·¯æ¥å¢å¤§æœ€å¤§æµï¼Œè€Œé¢„æµæ¨è¿›ç®—æ³•çš„æ€æƒ³æ˜¯â€¦â€¦åé¢å†è®²ã€‚ å…ˆä»æœ€ç†Ÿæ‚‰çš„å¢å¹¿è·¯ç®—æ³•å¼€å§‹è®²ã€‚ ISAP(Improved Shortest Augumenting Pathï¼‰ï¼šå…¶å®Dinicå·²ç»è¶³å¤Ÿé«˜æ•ˆäº†ï¼Œä½†é‚£äº›ï¼ˆé—²ç€æ²¡äº‹å¹²ï¼‰çš„è®¡ç®—æœºç§‘å­¦å®¶ä»¬å¯¹Dinicçš„æ•ˆç‡ä»ä¸æ»¡è¶³ï¼Œäºæ˜¯å°±æœ‰äº†ISAPç®—æ³•ã€‚ åœ¨Dinicä¸­æˆ‘ä»¬æ¯æ¬¡å¢å¹¿å‰éƒ½è¿›è¡Œäº†ä¸€æ¬¡bfsæ¥åˆå§‹åŒ–æ¯ä¸ªç‚¹çš„æ·±åº¦ï¼Œè™½ç„¶ä¸€æ¬¡æ ‡å·å¢å¹¿äº†å¾ˆå¤šæ¡è·¯ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯å¾ˆæœ‰å¯èƒ½è¦è·‘å¾ˆå¤šébfså¯¼è‡´æ•ˆç‡ä¸é«˜ã€‚ é‚£æœ‰æ²¡æœ‰ä»€ä¹ˆåŠæ³•åªè·‘ä¸€æ¬¡bfså‘¢?é‚£å°±æ˜¯ISAPç®—æ³•äº†ï¼ISAPè¿è¡Œè¿‡ç¨‹ï¼š1.ä»tåˆ°sè·‘ä¸€ébfsï¼Œæ ‡è®°æ·±åº¦ï¼ˆä¸ºä»€ä¹ˆæ˜¯ä»tåˆ°så‘¢ï¼Ÿåé¢ä¼šè®²ï¼‰ 2.ä»såˆ°tè·‘dfsï¼Œå’ŒDinicç±»ä¼¼ï¼Œåªæ˜¯å½“ä¸€ä¸ªç‚¹è·‘å®Œåï¼Œå¦‚æœä»ä¸Šä¸€ä¸ªç‚¹ä¼ è¿‡æ¥çš„flowæ¯”è¯¥ç‚¹çš„usedå¤§ï¼ˆå¯¹äºè¯¥ç‚¹å½“å‰çš„æ·±åº¦æ¥è¯´ï¼Œè¯¥ç‚¹åœ¨è¯¥ç‚¹ä»¥åçš„è·¯ä¸Šå·²ç»åºŸäº†ï¼‰ï¼Œåˆ™æŠŠå®ƒçš„æ·±åº¦åŠ 1ï¼Œå¦‚æœå‡ºç°æ–­å±‚ï¼ˆæŸä¸ªæ·±åº¦æ²¡æœ‰ç‚¹ï¼‰ï¼Œç»“æŸç®—æ³• 3.å¦‚æœæ“ä½œ2æ²¡æœ‰ç»“æŸç®—æ³•ï¼Œé‡å¤æ“ä½œ2 å¥½æŠ½è±¡å•Šã€‚ä»€ä¹ˆåŸç†å‘¢ï¼Ÿ ISAPå…¶å®ä¸Dinicå·®ä¸å¤šï¼Œä½†æ˜¯å®ƒåªè·‘ä¸€ébfsï¼Œä½†æ˜¯æ¯ä¸ªç‚¹çš„å±‚æ•°éšç€dfsçš„è¿›è¡Œè€Œä¸æ–­æé«˜ï¼ˆè¿™æ ·å°±ä¸ç”¨åå¤è·‘bfsé‡æ–°åˆ†å±‚äº†ï¼‰ï¼Œå½“sçš„æ·±åº¦å¤§äºnæ—¶ï¼ˆè¿™å°±æ˜¯ä¸ºä»€ä¹ˆbfsè¦ä»tåˆ°sï¼‰ï¼Œç»“æŸç®—æ³•ã€‚ å…ˆç»™ä¸€äº›æ•°ç»„å®šä¹‰ï¼š 12int dep[13000],gap[13000];//dep[i]è¡¨ç¤ºèŠ‚ç‚¹içš„æ·±åº¦ï¼Œgap[i]è¡¨ç¤ºæ·±åº¦ä¸ºiçš„ç‚¹çš„æ•°é‡ bfséƒ¨åˆ†: 1234567891011121314151617181920void bfs()&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); dep[t]=0; gap[0]=1;// queue&lt;int&gt;q; q.push(t); while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=node[i].next)&#123; int v=node[i].v; if(dep[v]!=-1)continue;//é˜²æ­¢é‡å¤æ”¹æŸä¸ªç‚¹ q.push(v); dep[v]=dep[u]+1; gap[dep[v]]++; &#125; &#125; return;&#125;//åˆå§‹åŒ–bfsï¼Œä»tåˆ°sæœå‡ºæ¯ä¸ªç‚¹åˆå§‹æ·±åº¦ å¯ä»¥çœ‹å‡ºISAPé‡Œçš„bfså¯¹ è¾¹æƒ!=0 è¿™ä¸€æ¡ä»¶å¹¶æ²¡æœ‰é™åˆ¶ï¼Œåªè¦åœ¨åé¢çš„dfsé‡Œåˆ¤æ–­è¾¹æƒå°±å¥½äº†ã€‚ æ¥ä¸‹æ¥æ˜¯dfsï¼š 1234567891011121314151617181920212223242526272829int dfs(int u,int flow)&#123; if(u==t)&#123;//å¯ä»¥åˆ°è¾¾t maxflow+=flow; return flow; &#125; int used=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;dep[d]+1==dep[u])&#123; int mi=dfs(d,min(node[i].val,flow-used)); if(mi)&#123; node[i].val-=mi; node[i^1].val+=mi; used+=mi; &#125; if(used==flow)return used; &#125; &#125; //å‰åŠæ®µå’ŒDinicä¸€æ¨¡ä¸€æ · //å¦‚æœå·²ç»åˆ°äº†è¿™é‡Œï¼Œè¯´æ˜è¯¥ç‚¹å‡ºå»çš„æ‰€æœ‰ç‚¹éƒ½å·²ç»æµè¿‡äº† //å¹¶ä¸”ä»å‰é¢ç‚¹ä¼ è¿‡æ¥çš„æµé‡è¿˜æœ‰å‰©ä½™ //åˆ™æ­¤æ—¶ï¼Œè¦å¯¹è¯¥ç‚¹æ›´æ”¹dep //ä½¿å¾—è¯¥ç‚¹ä¸è¯¥ç‚¹å‡ºå»çš„ç‚¹åˆ†éš”å¼€ --gap[dep[u]]; if(gap[dep[u]]==0)dep[s]=n+1;//å‡ºç°æ–­å±‚ï¼Œæ— æ³•åˆ°è¾¾täº† dep[u]++;//å±‚++ gap[dep[u]]++;//å±‚æ•°å¯¹åº”ä¸ªæ•°++ return used; &#125; æ„Ÿè§‰å’ŒDinicå·®ä¸å¤šã€‚ åªæ˜¯å¤šå‡ å¥è¯æ¥ç»Ÿè®¡æ·±åº¦å¯¹åº”çš„ç‚¹æ•°ã€‚ è¿™é‡Œè¦è§£é‡Šä¸€ä¸‹ä¸ºä»€ä¹ˆè¦ç»Ÿè®¡æ¯ä¸ªæ·±åº¦çš„èŠ‚ç‚¹æ•°ï¼šä¸ºäº†ä¼˜åŒ–ï¼ç»Ÿè®¡æ¯ä¸ªæ·±åº¦å¯¹åº”ç‚¹æ•°åªä¸ºäº†è¿™å¥è¯ï¼š 1if(gap[dep[u]]==0)dep[s]=n+1; å› ä¸ºæˆ‘ä»¬æ˜¯æŒ‰ç…§æ·±åº¦æ¥å¾€å‰èµ°çš„ï¼Œè·¯å¾„ä¸Šçš„ç‚¹çš„æ·±åº¦ä¸€å®šæ˜¯è¿ç»­çš„ï¼Œè€Œtçš„æ·±åº¦ä¸º0ï¼Œå¦‚æœæŸä¸ªæ·±åº¦çš„ç‚¹ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ— æ³•åˆ°è¾¾täº†æ­¤æ—¶ç›´æ¥ç»“æŸç®—æ³•å¯ä»¥å¤§å¤§èŠ‚çœæ—¶é—´ã€‚ æ¥ä¸‹æ¥æ˜¯ä¸»å‡½æ•°ï¼š 123456int ISAP()&#123; maxflow=0; bfs(); while(dep[s]&lt;n)dfs(s,inf); return maxflow;&#125; ç”±äºdfséƒ¨åˆ†ï¼ˆæœ‰ç‚¹ï¼‰ç›¸å½“æŠ½è±¡ï¼Œå¯ä»¥ç»“åˆå›¾ç¤ºç†è§£ã€‚ä»¥ä¸‹å›¾ä¸ºä¾‹ï¼šï¼ˆåå‘è¾¹æ²¡æœ‰ç”»ï¼Œä½†æ˜¯æœ‰åå‘è¾¹ï¼‰ å…ˆ bfs åˆ†å±‚ï¼šï¼ˆè“è‰²å­—ä½“è¡¨ç¤ºå±‚æ•°ï¼‰ æŒ‰ç…§æ·±åº¦ï¼Œæˆ‘ä»¬åªèƒ½èµ°S-&gt;1-&gt;5-&gt;6-&gt;tè¿™æ¡å¢å¹¿è·¯ï¼Œæµé‡ä¸º3 åœ¨dfsè¿‡ç¨‹ä¸­ï¼Œä»5ä¼ åˆ°6æ—¶$flow==4$è€Œåœ¨6å·ç‚¹çš„$used==3$ï¼Œæ‰€ä»¥æ­¤æ—¶ä¸ä¼šç›´æ¥è¿”å›ï¼ˆè§ä¸Šæ–¹çš„ä»£ç ï¼‰ï¼Œè€Œæ˜¯æŠŠ6å·ç‚¹çš„æ·±åº¦åŠ 1ï¼ŒåŒç†s,1,5çš„ä¹Ÿè¦åŠ 1ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè·‘äº†è¿™æ¡å¢å¹¿è·¯åï¼Œå›¾å˜æˆäº†ï¼š çœ‹è§äº†å—ï¼Ÿs-&gt;1-&gt;5-&gt;6-&gt;tè¿™æ¡è·¯è¢«å°äº†ï¼Œä½†æ˜¯s-&gt;1-&gt;2-&gt;3-&gt;4-&gt;tè¿™æ¡è·¯å´èƒ½èµ°äº† æŒ‰ç…§æ·±åº¦ï¼Œè¿™æ¬¡è‚¯å®šæ˜¯èµ°s-&gt;1-&gt;2-&gt;3-&gt;4-&gt;tè¿™æ¡è·¯ã€‚ è¿™æ¬¡çš„æƒ…å†µå’Œä¸Šæ¬¡ä¸åŒï¼Œç”±äºä»2ä¼ åˆ°3æ—¶çš„flow==3è€Œä¹‹åçš„è·¯å¾„çš„usedéƒ½æ˜¯3ï¼Œæ‰€ä»¥2,3,4å·ç‚¹çš„æ·±åº¦ä¸ä¼šæ”¹å˜ï¼Œè€Œ1,sçš„æƒ…å†µä¸ä¸Šæ¬¡çš„é‚£äº›ç‚¹ç›¸åŒï¼Œæ·±åº¦ä¼šæ”¹å˜ã€‚ è·‘äº†è¿™æ¡è·¯ä¹‹åï¼Œå›¾å˜æˆäº†ï¼š å›¾ä¸­å‡ºç°äº†æ–­å±‚ï¼ˆæ·±åº¦ä¸º4çš„ç‚¹æ²¡æœ‰äº†ï¼‰ï¼Œæ‰€ä»¥ä¸€å®šä¸å­˜åœ¨å¢å¹¿è·¯äº†ï¼Œå¯ä»¥ç›´æ¥ç»“æŸç®—æ³•äº†ã€‚ åˆšæ‰é‚£å¼ å›¾å¦‚æœç”¨Dinicä¼šæ€ä¹ˆæ ·ï¼Ÿä¸‰ébfsï¼Œä¸¤édfsï¼ä¸ä¹‹ç›¸æ¯”ï¼ŒISAPçœŸæ˜¯å¤ªé«˜æ•ˆäº†ï¼è¿™é‡Œé¡ºä¾¿è¯´ä¸€ä¸‹ä¸ºä»€ä¹ˆç»ˆæ­¢æ¡ä»¶æ˜¯dep[s]&lt;n ä»ä¸Šé¢çš„è¿‡ç¨‹å¯ä»¥çœ‹å‡ºï¼šæ¯èµ°ä¸€éå¢å¹¿è·¯ï¼Œsçš„å±‚æ•°å°±ä¼šåŠ 1ï¼Œå¦‚æœä¸€ç›´æ²¡æœ‰å‡ºç°æ–­å±‚ï¼Œæœ€å¤šè·‘n-depï¼ˆåˆšbfså®Œæ—¶sçš„æ·±åº¦ï¼‰æ¡å¢å¹¿è·¯ï¼ˆå› ä¸ºä¸€å…±å°±nä¸ªç‚¹ï¼‰ å®Œæ•´ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int inf=1&lt;&lt;30;int cnt=1,head[13000];int n,m,s,t;inline int Read()&#123; int x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;struct Node&#123; int v; int next; int val;&#125;node[250000];inline void addedge(int u,int v,int val)&#123; node[++cnt].v=v; node[cnt].val=val; node[cnt].next=head[u]; head[u]=cnt;&#125;int dep[13000],gap[13000];void bfs()&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); dep[t]=0; gap[0]=1; queue&lt;int&gt;q; q.push(t); while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=node[i].next)&#123; int v=node[i].v; if(dep[v]!=-1)continue; q.push(v); dep[v]=dep[u]+1; gap[dep[v]]++; &#125; &#125; return;&#125;int maxflow;int dfs(int u,int flow)&#123; if(u==t)&#123; maxflow+=flow; return flow; &#125; int used=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;dep[d]+1==dep[u])&#123; int mi=dfs(d,min(node[i].val,flow-used)); if(mi)&#123; node[i].val-=mi; node[i^1].val+=mi; used+=mi; &#125; if(used==flow)return used; &#125; &#125; --gap[dep[u]]; if(gap[dep[u]]==0)dep[s]=n+1; dep[u]++; gap[dep[u]]++; return used; &#125;int ISAP()&#123; maxflow=0; bfs(); while(dep[s]&lt;n)dfs(s,inf); return maxflow;&#125;int main()&#123; int i=1; n=Read(),m=Read(),s=Read(),t=Read(); int u,v,w; for(i=1;i&lt;=m;i++)u=Read(),v=Read(),w=Read(),addedge(u,v,w),addedge(v,u,0); printf("%d",ISAP()); return 0;&#125; å½“ç„¶ï¼Œè¿™ä¸œè¥¿ä¹Ÿå¯ä»¥å½“å‰å¼§ä¼˜åŒ–ï¼ˆåŸç†è§ Dinic ï¼‰åªéœ€è¦æ”¹ä¸€ç‚¹å³å¯ï¼š 1234while(dep[s]&lt;n)&#123; memcpy(cur,head,sizeof(head)); dfs(s,inf); &#125; dfséƒ¨åˆ†çš„ä¿®æ”¹å°±ä¸æ”¾ä»£ç äº†ï¼Œåº”è¯¥éƒ½ä¼šã€‚ æ¥ä¸‹æ¥å°±æ˜¯ç›¸å½“æŠ½è±¡çš„é¢„æµæ¨è¿›ç®—æ³•äº† åœ¨è®²è§£ç®—æ³•ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥å›é¡¾ä¸€ä¸‹æœ€å¤§æµæ˜¯å¹²å˜›çš„ï¼š æ°´æµä»ä¸€ä¸ªæºç‚¹sé€šè¿‡å¾ˆå¤šè·¯å¾„ï¼Œç»è¿‡å¾ˆå¤šç‚¹ï¼Œåˆ°è¾¾æ±‡ç‚¹tï¼Œé—®ä½ æœ€å¤šèƒ½æœ‰å¤šå°‘æ°´èƒ½å¤Ÿåˆ°è¾¾tç‚¹ã€‚ åœ¨åˆšé¢å¯¹è¿™ä¸ªé—®é¢˜æ—¶ï¼Œä½ æˆ–è®¸ä¼šæœ‰è¿™æ ·çš„æ€è·¯ï¼š å…ˆä»så¾€ç›¸é‚»ç‚¹æ‹¼å‘½çŒæ°´ï¼Œç„¶åè®©æ°´ä¸åœåœ°å‘tæµï¼Œèƒ½æµå¤šå°‘æ˜¯å¤šå°‘ã€‚ è¿™å°±æ˜¯é¢„æµæ¨è¿›ï¼šèƒ½æ¨æµï¼Œå°±æ¨æµï¼Œæœ€ç»ˆtæœ‰å¤šå°‘æ°´ï¼Œæœ€å¤§æµå°±æ˜¯å¤šå°‘ã€‚ é¢„æµæ¨è¿›ç®—æ³•çš„æ€æƒ³ï¼šåœ¨è®²æ€æƒ³ä¹‹å‰ï¼Œå…ˆå¼•å…¥ä¸€ä¸ªæ¦‚å¿µï¼š ä½™æµï¼š å¬åå­—å°±çŸ¥é“æ˜¯ä»€ä¹ˆæ„æ€äº†ï¼Œå³æ¯ä¸ªç‚¹å½“å‰æœ‰å¤šå°‘æ°´ã€‚ é¢„ç•™æ¨è¿›ç®—æ³•çš„æ€æƒ³æ˜¯ï¼š 1.å…ˆå‡è£…sæœ‰æ— é™å¤šçš„æ°´(ä½™æµ)ï¼Œä»så‘å‘¨å›´ç‚¹æ¨æµï¼ˆæŠŠè¯¥ç‚¹çš„ä½™æµæ¨ç»™å‘¨å›´ç‚¹ï¼Œæ³¨æ„ï¼šæ¨çš„æµé‡ä¸èƒ½è¶…è¿‡è¾¹çš„å®¹é‡ä¹Ÿä¸èƒ½è¶…è¿‡è¯¥ç‚¹ä½™æµï¼‰ï¼Œå¹¶è®©å‘¨å›´ç‚¹å…¥é˜Ÿï¼ˆ æ³¨æ„ï¼šså’Œtä¸èƒ½å…¥é˜Ÿ ï¼‰ 2.ä¸æ–­åœ°å–é˜Ÿé¦–å…ƒç´ ï¼Œå¯¹é˜Ÿé¦–å…ƒç´ æ¨æµ 3.é˜Ÿåˆ—ä¸ºç©ºæ—¶ç»“æŸç®—æ³•ï¼Œtç‚¹çš„ä½™æµå³ä¸ºæœ€å¤§æµã€‚ ä¸Šè¿°æ€è·¯æ˜¯ä¸æ˜¯çœ‹èµ·æ¥å¾ˆç®€å•ï¼Œä¹Ÿæ„Ÿè§‰æ˜¯å®Œå…¨æ­£ç¡®çš„ï¼Ÿ ä½†æ˜¯è¿™ä¸ªæ€è·¯æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯å¯èƒ½ä¼šå‡ºç°ä¸¤ä¸ªç‚¹ä¸åœåœ°æ¥å›æ¨æµçš„æƒ…å†µï¼Œä¸€ç›´æ¨åˆ°TLEã€‚ æ€ä¹ˆè§£å†³è¿™ä¸ªé—®é¢˜å‘¢ï¼Ÿ ç»™æ¯ä¸ªç‚¹ä¸€ä¸ªé«˜åº¦ï¼Œæ°´åªä¼šä»é«˜å¤„å¾€ä½å¤„æµã€‚åœ¨ç®—æ³•è¿è¡Œæ—¶ï¼Œ ä¸æ–­åœ°å¯¹æœ‰ä½™æµçš„ç‚¹æ›´æ”¹é«˜åº¦ ï¼Œç›´åˆ°è¿™äº›ç‚¹å…¨éƒ¨æ²¡æœ‰ä½™æµä¸ºæ­¢ã€‚ ä¸ºä»€ä¹ˆè¿™æ ·å°±ä¸ä¼šå‡ºç°æ¥å›æ¨æµçš„æƒ…å†µäº†å‘¢ï¼Ÿ å½“ä¸¤ä¸ªç‚¹å¼€å§‹æ¥å›æ¨æµæ—¶ï¼Œå®ƒä»¬çš„é«˜åº¦ä¼šä¸æ–­ä¸Šå‡ï¼Œå½“å®ƒä»¬çš„é«˜åº¦å¤§äºsæ—¶ï¼Œä¼šæŠŠä½™æµè¿˜ç»™sã€‚ æ‰€ä»¥åœ¨å¼€å§‹é¢„æµæ¨è¿›å‰è¦å…ˆæŠŠsçš„é«˜åº¦æ”¹ä¸ºnï¼ˆç‚¹æ•°ï¼‰ï¼Œå…å¾—ä¸€å¼€å§‹så‘¨å›´é‚£äº›ç‚¹å°±æ€¥ç€æŠŠä½™æµè¿˜ç»™sã€‚ å…ˆç”¨å›¾è§£æ¥è¡¨ç¤ºç®—æ³•çš„è¿è¡Œè¿‡ç¨‹ï¼šä»¥ä¸‹å›¾ä¸ºä¾‹ï¼ˆåå‘è¾¹æ²¡ç”»å‡ºæ¥ï¼‰ æˆ‘ä»¬ç”¨æ·±è“è‰²çš„å­—è¡¨ç¤ºæ¯ä¸ªç‚¹çš„ä½™æµï¼Œç”¨æ·¡è“è‰²çš„å­—è¡¨ç¤ºæ¯ä¸ªç‚¹çš„é«˜åº¦ã€‚ åˆšå¼€å§‹è‚¯å®šæ˜¯ï¼š æˆ‘ä»¬æŠŠsç‚¹çš„é«˜åº¦æ”¹æˆ6ï¼ˆä¸€å…±6ä¸ªç‚¹ï¼‰ ç„¶åä»å¾€sæ‹¼å‘½åœ°çŒæ°´ï¼Œæ°´æµä¼šé¡ºç€è¿˜æ²¡æ»¡çš„è¾¹å‘å‘¨å›´çš„èŠ‚ç‚¹æµ æ­¤æ—¶1,3èŠ‚ç‚¹è¿˜æœ‰ä½™æµï¼Œäºæ˜¯æ›´æ–°1,3å·ç‚¹é«˜åº¦ï¼Œæ›´æ–°ä¸ºä¸å®ƒç›¸é‚»ä¸”æœ€ä½çš„ç‚¹çš„é«˜åº¦+1ã€‚ æ­¤æ—¶æˆ‘ä»¬å¯¹1å·èŠ‚ç‚¹æ¨æµã€‚ æ›´æ–°æœ‰ä½™æµçš„1,2å·èŠ‚ç‚¹çš„é«˜åº¦ ä¸ºä»€ä¹ˆ1çš„é«˜åº¦å˜æˆäº†7å‘¢ï¼Ÿå› ä¸º1ä¸sæœ‰åå‘è¾¹ï¼Œå› ä¸ºåˆšæ‰æ¨è¿‡æµï¼Œåå‘è¾¹æœ‰äº†è¾¹æƒï¼Œä¸1è¿é€šçš„æœ€ä½çš„ç‚¹å°±æ˜¯sã€‚ ç„¶åæ˜¯å¯¹3èŠ‚ç‚¹æ¨æµï¼ˆæ›´æ–°é«˜åº¦æ˜¯åŒæ—¶è¿›è¡Œçš„åªæ˜¯åˆšæ‰ä¸ºäº†ä¾¿äºç†è§£è€Œåˆ†å¼€ç”»äº†ï¼‰ ç„¶åæ˜¯2å·ç‚¹æ¨æµï¼Œæ³¨æ„tç‚¹ä¸èƒ½æ›´æ–°é«˜åº¦ï¼ˆå¦åˆ™å¥½ä¸å®¹æ˜“æµè¿‡å»çš„æ°´å°±ä¼šå¾€å›æµäº†ï¼‰ 4å·ç‚¹æ¨æµ 2å·ç‚¹æ¨æµ 3å·ç‚¹æ¨æµ é™¤äº†så’Œtä»¥å¤–ï¼Œæ‰€æœ‰èŠ‚ç‚¹éƒ½æ— ä½™æµï¼Œç®—æ³•ç»“æŸï¼Œæœ€å¤§æµå°±æ˜¯tçš„ä½™æµã€‚ å®Œæ•´ä»£ç : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// luogu-judger-enable-o2//æ•ˆç‡ç›¸å½“ä½ï¼Œå¸æ°§æ°”éƒ½è¿‡ä¸äº†æ¨¡æ¿#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int inf=1&lt;&lt;30;;int n,m,s,t;struct Node&#123; int v; int val; int next;&#125;node[205202];int top=1;int inque[13000];int head[13000];int h[13000];int e[13000];//æ¯ä¸ªç‚¹çš„é«˜åº¦ï¼Œæ¯ä¸ªç‚¹çš„å‰©ä½™ï¼ˆå¤šä½™ï¼‰æµé‡inline int Read()&#123; int x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;//è¯»å…¥ä¼˜åŒ– inline int min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline void addedge(int u,int v,int val)&#123; node[++top].v=v; node[top].val=val; node[top].next=head[u]; head[u]=top;&#125;inline void add(int u,int v,int val)&#123; addedge(u,v,val); addedge(v,u,0);&#125;int maxflow;inline void push_(int u,int i)&#123; int mi=min(e[u],node[i].val); node[i].val-=mi; node[i^1].val+=mi; e[u]-=mi; e[node[i].v]+=mi;&#125;//ä»uåˆ°væ¨æµ,iä¸ºuä¸vç›¸è¿çš„é‚£ä¸€æ¡è¾¹çš„ç¼–å· inline bool relabel(int u)&#123; int mh=inf; register int i; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val)&#123; mh=min(mh,h[d]); &#125; &#125; if(mh==inf)return 0;//æ— å¯ä»¥æµçš„è·¯å¾„ h[u]=mh+1;//æŠŠuç‚¹æ‹‰åˆ°å¯æµç‚¹ä»¥ä¸Šï¼ˆä½¿æ°´æµèƒ½ä»uæµå‘å‘¨å›´çš„ç‚¹ï¼‰ return 1; &#125;//åˆ¤æ–­ç‚¹uæ˜¯å¦èƒ½æµå‘å‘¨å›´ç‚¹int push_relabel()&#123; queue&lt;int&gt;q; h[s]=n;//æŠŠæºç‚¹çš„é«˜åº¦è®¾æˆnï¼ˆå›¾ä¸­çš„ç‚¹æ•°ï¼‰ for(register int i=head[s];i;i=node[i].next)&#123; int d=node[i].v; int val=node[i].val; if(val)&#123; node[i].val-=val; node[i^1].val+=val; e[s]-=val; e[d]+=val; if(inque[d]==0&amp;&amp;d!=t&amp;&amp;d!=s&amp;&amp;relabel(d))&#123; q.push(d); inque[d]=1; &#125; &#125;//ç»™æ‰€æœ‰ä¸sç›¸è¿çš„ç‚¹æ¨å…¥æ»¡æµ &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); inque[u]=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(e[u]==0)break; if(node[i].val==0)continue; if(h[u]==h[d]+1) push_(u,i); if(e[d]!=0&amp;&amp;d!=t&amp;&amp;d!=s)&#123; if(inque[d]==0&amp;&amp;relabel(d))&#123; q.push(d); inque[d]=1; &#125; &#125; &#125; if(e[u]&amp;&amp;inque[u]==0&amp;&amp;relabel(u))&#123; q.push(u); inque[u]=1; &#125; &#125; return e[t];&#125;//push_relabelint main()&#123; n=Read(),m=Read(),s=Read(),t=Read(); register int i; int u,v,val; for(i=1;i&lt;=m;i++)u=Read(),v=Read(),val=Read(),add(u,v,val); printf("%d",push_relabel()); return 0;&#125; è¿™ä¸ªé¢„æµæ¨è¿›ç®—æ³•ç›¸å½“æ…¢ï¼Œè‡³äºP4722 ã€æ¨¡æ¿ã€‘æœ€å¤§æµ åŠ å¼ºç‰ˆ / é¢„æµæ¨è¿›ï¼ˆæ¯’ç˜¤é¢˜ï¼‰æ›´æ²¡å¸Œæœ›ã€‚ é‚£ä¸ºä»€ä¹ˆè¿™ä¹ˆæ…¢ï¼Œæˆ‘ä»¬è¿˜è¦å­¦å‘¢ï¼Ÿ ä¸ºäº†ä¸‹é¢çš„è®²è§£åšé“ºå«ã€‚ æœ€é«˜æ ‡å·é¢„æµæ¨è¿›ï¼ˆHLPPï¼‰ç®—æ³•æ­¥éª¤ï¼š 1.å…ˆä»tåˆ°såå‘bfsï¼Œä½¿æ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªåˆå§‹é«˜åº¦ 2.ä»så¼€å§‹å‘å¤–æ¨æµï¼Œå°†æœ‰ä½™æµçš„ç‚¹æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ— 3.ä¸æ–­ä»ä¼˜å…ˆé˜Ÿåˆ—é‡Œå–å‡ºé«˜åº¦æœ€é«˜çš„ç‚¹è¿›è¡Œæ¨æµæ“ä½œ 4.è‹¥æ¨å®Œè¿˜æœ‰ä½™æµï¼Œæ›´æ–°é«˜åº¦æ ‡å·ï¼Œé‡æ–°æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ— 5.å½“ä¼˜å…ˆé˜Ÿåˆ—ä¸ºç©ºæ—¶ç»“æŸç®—æ³•ï¼Œæœ€å¤§æµå³ä¸ºtçš„ä½™æµ ä¸åŸºç¡€çš„ä½™æµæ¨è¿›ç›¸æ¯”çš„ä¼˜åŠ¿ï¼š é€šè¿‡bfsé¢„å…ˆå¤„ç†äº†é«˜åº¦æ ‡å·ï¼Œå¹¶åˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆé—²ç€æ²¡äº‹å¯ä»¥æ‰‹å†™å †ï¼‰ä½¿å¾—æ¯æ¬¡æ¨æµéƒ½æ˜¯é«˜åº¦æœ€é«˜çš„é¡¶ç‚¹ï¼Œä»¥æ­¤å‡å°‘æ¨æµçš„æ¬¡æ•°å’Œé‡æ ‡å·çš„æ¬¡æ•°ã€‚ ä¼˜åŒ–ï¼š å’ŒISAPä¸€æ ·çš„gapä¼˜åŒ–ï¼Œå¦‚æœæŸä¸ªé«˜åº¦ä¸å­˜åœ¨ï¼Œå°†æ‰€æœ‰æ¯”è¯¥é«˜åº¦é«˜çš„èŠ‚ç‚¹æ ‡è®°ä¸ºä¸å¯åˆ°è¾¾ï¼ˆä½¿å®ƒçš„é«˜åº¦ä¸ºn+1ï¼Œè¿™æ ·å°±ä¼šç›´æ¥å‘sæ¨æµäº†ï¼‰ã€‚ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;inline int Read()&#123; int x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;const int inf=1&lt;&lt;30;int top=1,head[10100];int n,m,s,t;int e[10100],h[10100],cnth[20100];//æ¯ä¸ªç‚¹å¯¹åº”çš„ä½™æµï¼Œé«˜åº¦ï¼›æ¯ä¸ªé«˜åº¦æœ‰å¤šå°‘ä¸ªç‚¹ struct cmp&#123; inline bool operator () (int a,int b) const&#123; return h[a]&lt;h[b]; &#125;&#125;;struct Node&#123; int v; int val; int next;&#125;node[400100];inline void addedge(int u,int v,int val)&#123; node[++top].v=v; node[top].val=val; node[top].next=head[u]; head[u]=top;&#125;inline void add(int u,int v,int val)&#123; addedge(u,v,val); addedge(v,u,0);&#125;int inque[11000];void bfs()&#123; memset(h,0x3f,sizeof(h)); h[t]=0; queue&lt;int&gt;qu; qu.push(t); while(!qu.empty())&#123; int u=qu.front(); qu.pop(); inque[u]=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i^1].val&amp;&amp;h[d]&gt;h[u]+1)&#123;//åå‘è·‘ h[d]=h[u]+1; if(inque[d]==0)&#123; qu.push(d); inque[d]=1; &#125; &#125; &#125; &#125; return;&#125;priority_queue&lt;int,vector&lt;int&gt;,cmp&gt;q;inline void push_(int u)&#123; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;h[d]+1==h[u])&#123;//å¯ä»¥æ¨æµ int mi=min(node[i].val,e[u]); node[i].val-=mi; node[i^1].val+=mi; e[u]-=mi; e[d]+=mi; if(inque[d]==0&amp;&amp;d!=t&amp;&amp;d!=s)&#123; q.push(d); inque[d]=1; &#125; if(e[u]==0)break;//å·²ç»æ¨å®Œäº† &#125; &#125;&#125;//æ¨æµ inline void relabel(int u)&#123; h[u]=inf; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;h[d]+1&lt;h[u])&#123; h[u]=h[d]+1; &#125; &#125;&#125;//æŠŠuçš„é«˜åº¦æ›´æ”¹ä¸ºä¸uç›¸é‚»çš„æœ€ä½çš„ç‚¹çš„é«˜åº¦åŠ 1 int hlpp()&#123; register int i; bfs(); if(h[s]==0x3f3f3f3f)return 0;//sä¸tä¸è¿é€š h[s]=n; for(i=1;i&lt;=n;i++)if(h[i]&lt;0x3f3f3f3f)cnth[h[i]]++;//ç»Ÿè®¡å„ä¸ªé«˜åº¦çš„ç‚¹æ•°ï¼Œæ³¨æ„ä¸è¦è®©ä¸‹æ ‡è¶Šç•Œ for(i=head[s];i;i=node[i].next)&#123; int d=node[i].v; int mi=node[i].val; if(mi)&#123; e[s]-=mi; e[d]+=mi; node[i].val-=mi; node[i^1].val+=mi; if(d!=t&amp;&amp;inque[d]==0&amp;&amp;d!=s)&#123; q.push(d); inque[d]=1; &#125; &#125; &#125;//ä»så‘å‘¨å›´ç‚¹æ¨æµ while(!q.empty())&#123; int u=q.top(); inque[u]=0; q.pop(); push_(u); if(e[u])&#123;//è¿˜æœ‰ä½™æµ cnth[h[u]]--; if(cnth[h[u]]==0)&#123; for(int i=1;i&lt;=n;i++)&#123; if(i!=s&amp;&amp;i!=t&amp;&amp;h[i]&gt;h[u]&amp;&amp;h[i]&lt;n+1)&#123; h[i]=n+1;//æ ‡è®°æ— æ³•åˆ°è¾¾ &#125; &#125; &#125;//gapä¼˜åŒ– relabel(u); cnth[h[u]]++; q.push(u); inque[u]=1; &#125; &#125; return e[t];&#125; int main()&#123; n=Read(),m=Read(),s=Read(),t=Read(); register int i; int u,v,val; for(i=1;i&lt;=m;i++)u=Read(),v=Read(),val=Read(),add(u,v,val); printf("%d",hlpp()); return 0;&#125; è¿™æ¬¡ç»ˆäºå¯ä»¥è¿‡æ‰é‚£é“æ¯’ç˜¤é¢˜äº†ã€‚ æ€»ç»“ï¼šISAPçš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n^2m),è€ŒHLPPçš„æ—¶é—´å¤æ‚åº¦O(n^2sqrt(m)),ä½†ç”±äºHLPPå¸¸æ•°è¿‡å¤§ï¼Œåœ¨çº¯éšæœºæ•°æ®ï¼ˆæ¨¡æ¿é¢˜ï¼‰ä¸‹è·‘å¾—è¿˜æ²¡æœ‰ISAPå¿«ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œç”¨ISAPå°±å¤Ÿäº†ã€‚ æœ€åæ„Ÿè°¢é’±é€¸å‡¡å¤§ä½¬çš„ç»éªŒå…±äº«QWQ]]></content>
      <categories>
        <category>æ›´å¤šä¼˜ç§€çš„ç®—æ³•</category>
      </categories>
      <tags>
        <tag>Magical Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Grand Contest#016 F.Games on DAG]]></title>
    <url>%2F2019%2F02%2F14%2FAtcoder-Grand-Contest-016-F-Games-on-DAG%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜G.Games on DAGé¢˜é¢There is a directed graph $G$ with $N$ vertices and $M$ edges. The vertices are numbered $1$ through $M$. Edge $i$ is directed from $x_i$ to $y_i$ holds. Alse, there are no multiple edges in $G$. Consider selecting a subset of the set of the $M$ edges in $G$, and removing these edges from $G$ to obtain another graph $Gâ€™$. There are $2^M$ different possible graphs as $Gâ€™$. Alice and Bob play against each other in the following game played on $Gâ€™$. First, place two pieces on vertices $1$ and $2$, one on each. Then, starting from Alice, Alice and Bob alternately perform the following operation: Select an edge $i$ such that there is a piece placed on vertex $x_i$, and move the piece to vertex $y_i$(if there are two pieces on vertex $x_i$, only move one). The two pieces are allowed to be placed on the same vertex. The player loses when he(or she) becomes unable to perform the operation. We assume that both players play optimally. Among the $2^M$ different possible graphs as $Gâ€™$, how many lead to Aliceâ€™s victory? Find the count modulo $10^9+7$.]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#254 C.DZY Loves Colors]]></title>
    <url>%2F2019%2F02%2F14%2FCodeForces-254-C-DZY-Loves-Colors%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜F.DZY Loves Colorsé¢˜é¢$DZY$ loves colors, and he enjoys painting. On a colorful day, $DZY$ gets a colorful ribbon, which consists of $n$ units (they are numbered from $1$ to $n$ from left to right). The color of the $i$-th unit of the ribbon is $i$ at first. It is colorful enough, but we still consider that the colorfulness of each unit is $0â€‹$ at first. $DZY$ loves painting, we know. He takes up a paintbrush with color $x$ and uses it to draw a line on the ribbon. In such a case some contiguous units are painted. Imagine that the color of unit $i$ currently is $y$. When it is painted by this paintbrush, the color of the unit becomes $x$, and the colorfulness of the unit increases by $|x - y|$. $DZY$ wants to perform $m$ operations, each operation can be one of the following: Paint all the units with numbers between $l$ and $r$ (both inclusive) with color $x$. Ask the sum of colorfulness of the units between $l$ and $râ€‹$ (both inclusive). Can you help $DZY$? ç®€è¦ç¿»è¯‘$DZY$å–œæ¬¢è‰²å½©ï¼Œä»–çƒ­çˆ±ç»˜ç”»ã€‚ åœ¨ä¸€ä¸ªå¤šå§¿å¤šå½©çš„æ—¥å­é‡Œï¼Œ$DZY$å¾—åˆ°äº†ä¸€ä¸ªå½©è‰²çš„ç¼å¸¦ï¼Œå®ƒç”±$N$ä¸ªå•å…ƒç»„æˆï¼ˆä»å·¦åˆ°å³ä»$1$åˆ°$n$ç¼–å·ï¼‰ã€‚è‰²å¸¦çš„ç¬¬$i$ä¸ªå•ä½çš„æœ€åˆé¢œè‰²æ˜¯$i$ã€‚è™½ç„¶é¢œè‰²è¶³å¤Ÿä¸°å¯Œï¼Œä½†æˆ‘ä»¬ä»ç„¶è®¤ä¸ºæ¯ä¸ªå•å…ƒçš„é¢œè‰²æ•°é‡æœ€åˆæ˜¯$0$ã€‚ $DZY$çƒ­è¡·äºç»˜ç”»ï¼Œæˆ‘ä»¬çŸ¥é“ã€‚ä»–æ‹¿èµ·ä¸€æŠŠå½©è‰²$X$ç¬”ï¼Œç”¨å®ƒåœ¨ç¼å¸¦ä¸Šç”»ä¸€æ¡çº¿ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä»–å°±ç»˜åˆ¶äº†ä¸€æ®µè¿ç»­çš„å•å…ƒã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œå•ä½$i$è¢«æ¶‚ä¹‹å‰é¢œè‰²æ˜¯$Y$ã€‚è¢«æ¶‚ä¹‹åæ—¶ï¼Œå•å…ƒçš„é¢œè‰²å˜ä¸º$X$ï¼Œä»¤å•ä½çš„é¢œè‰²å¢åŠ äº† $âˆ£Xâˆ’Yâˆ£$ã€‚ $DZY$æƒ³è¦æ‰§è¡Œ$M$ä¸ªæ“ä½œï¼Œæ¯ä¸ªæ“ä½œå¯ä»¥æ˜¯ä¸‹åˆ—æ“ä½œä¹‹ä¸€ï¼š $1$ã€å°†åŒºé—´ [$L,R$] å†…å•å…ƒç»˜åˆ¶ä¸ºé¢œè‰²$X$ã€‚ $2$ã€è¯¢é—® [$L,R$] ä¹‹é—´çš„å•ä½é¢œè‰²çš„æ€»å’Œï¼ˆåŒ…æ‹¬ä¸¤è€…ï¼‰ã€‚ ä½ èƒ½å¸®åŠ©$DZY$å—ï¼Ÿ Inputç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•°$n,m$ã€‚ ä¸‹é¢$m$è¡Œä¸­æ¯ä¸€è¡Œä»¥ä¸€ä¸ªæ•´æ•°$type$å¼€å¤´ï¼Œè¡¨ç¤ºæ“ä½œç±»å‹ã€‚ è‹¥$type=1$ï¼Œé‚£ä¹ˆè¯¥è¡Œæ¥ä¸‹æ¥æœ‰3ä¸ªæ•´æ•°$L,R,X$ï¼Œæè¿°æ“ä½œ$1$ï¼› è‹¥$type=2$ï¼Œé‚£ä¹ˆè¯¥è¡Œæ¥ä¸‹æ¥æœ‰2ä¸ªæ•´æ•°$L,R$ï¼Œæè¿°æ“ä½œ$2$ã€‚ Outputå¯¹äºæ¯ä¸ªæ“ä½œ$2$ï¼Œè¾“å‡ºä¸€è¡Œï¼ŒåŒ…å«ç€è‰²æ•°é‡ä¹‹å’Œã€‚ Sample Input 13 31 1 2 41 2 3 52 1 3 Sample Output 18 Sample Input 23 41 1 3 42 1 12 2 22 3 3 Sample Output 23 2 1 Sample Input 310 61 1 5 31 2 7 91 10 10 111 3 8 121 1 10 32 1 10 Sample Output 3129 Hint$1\leq n,m,\leq 10^5$ $1\leq type\leq 2$ $1\leq l\leq r\leq n$ï¼Œ$1\leq x\leq 10^8$ã€‚ æœ¬é¢˜çš„é¢˜æ„éå¸¸çš„æ˜äº†ï¼Œä¸€å¼€å§‹çš„$a[i]=i,b[i]=0$ï¼Œä½¿åŒºé—´ $[l,r]$çš„$b[i]+=|x-a[i]|$ï¼Œ$a[i]=x$ï¼Œå¹¶æŸ¥è¯¢ $[l,r]$ çš„$b[i]$å’Œã€‚ æˆ‘ä»¬ç”¨ä¸€ä¸ªçº¿æ®µæ ‘å°±å¯ä»¥å¾ˆå®¹æ˜“åœ°ç»´æŠ¤ä»–ä»¬äº†ã€‚ ä¸å¤šè¯´ï¼Œç›´æ¥ä¸Šä»£ç å§ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N=500010;struct seg_tree&#123; long long lazy,s,flag;&#125;t[N&lt;&lt;2];int n,m;void build(int root,int l,int r)&#123; if(l==r) &#123; t[root].flag=l; return; &#125; int mid=l+r&gt;&gt;1; build(root&lt;&lt;1,l,mid); build(root&lt;&lt;1|1,mid+1,r); // pushup(root);&#125;long long query(int root,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) return t[root].s; int mid=l+r&gt;&gt;1; long long ans=0; if(ll&lt;=mid) ans+=query(root&lt;&lt;1,l,mid,ll,rr); if(rr&gt;mid) ans+=query(root&lt;&lt;1|1,mid+1,r,ll,rr); return ans+max(0,min(r,rr)-max(l,ll)+1)*t[root].lazy;&#125;void empty(int root,int l,int r,int s)&#123; if(t[root].flag) &#123; t[root].lazy+=abs(t[root].flag-s); t[root].s+=abs(t[root].flag-s)*(r-l+1); t[root].flag=0; return; &#125; if(l==r) return; int mid=l+r&gt;&gt;1; empty(root&lt;&lt;1,l,mid,s); empty(root&lt;&lt;1|1,mid+1,r,s); t[root].s=t[root&lt;&lt;1].s+t[root&lt;&lt;1|1].s+t[root].lazy*(r-l+1);&#125;void pushdown(int root)&#123; if(!t[root].flag) return; t[root&lt;&lt;1].flag=t[root&lt;&lt;1|1].flag=t[root].flag; t[root].flag=0;&#125;void change(int root,int l,int r,int ll,int rr,int s)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123; empty(root,l,r,s); t[root].flag=s; return; &#125; int mid=l+r&gt;&gt;1; pushdown(root); if(ll&lt;=mid) change(root&lt;&lt;1,l,mid,ll,rr,s); if(rr&gt;mid) change(root&lt;&lt;1|1,mid+1,r,ll,rr,s); t[root].s=t[root&lt;&lt;1].s+t[root&lt;&lt;1|1].s+t[root].lazy*(r-l+1);&#125;int main(int argc, char const *argv[])&#123; n=read(),m=read(); build(1,1,n); while(m--) &#123; int type=read(); if(type==1) &#123; int l=read(),r=read(),x=read(); change(1,1,n,l,r,x); &#125; else &#123; int l=read(),r=read(); printf("%lld\n",query(1,1,n,l,r)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#271 F.Ant Colony]]></title>
    <url>%2F2019%2F02%2F14%2FCodeForces-271-F-Ant-Colony%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜D.Ant Colonyé¢˜é¢Mole is hungry again. He found one ant colony, consisting of $n$ ants, ordered in a row. Each ant $i$ ($1\leq i\leq n$) has a strength $s_i$. In order to make his dinner more interesting, Mole organizes a version of Â«Hunger GamesÂ» for the ants. He chooses two numbers $l$ and $r$ ($1\leq l\leq r\leq n$) and each pair of ants with indices between $l$ and $r$ (inclusively) will fight. When two ants $i$ and $j$ fight, ant $s_i$ gets one battle point only if $s_i$ divides $s_j$ (also, ant $j$ gets one battle point only if $s_j$ divides $s_i$). After all fights have been finished, Mole makes the ranking. An ant $iâ€‹$, with $v_iâ€‹$ battle points obtained, is going to be freed only if $v_i=r-lâ€‹$, or in other words only if it took a point in every fight it participated. After that, Mole eats the rest of the ants. Note that there can be many ants freed or even none. In order to choose the best sequence, Mole gives you $t$ segments $[l_i,r_i]$ and asks for each of them how many ants is he going to eat if those ants fight. ç®€è¦ç¿»è¯‘ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º$ğ‘›$çš„åºåˆ—ï¼Œ$ğ‘$ä¸ªè¯¢é—®ã€‚ æ¯æ¬¡ç»™å®šåŒºé—´$ ğ‘™,ğ‘Ÿ $ï¼Œå°†$ ğ‘™,ğ‘Ÿ $ä¸­æ‰€æœ‰æ•°ä¸¤ä¸¤æ¯”è¾ƒã€‚ å¦‚æœ$ğ‘,ğ‘ âˆˆ ğ‘™,ğ‘Ÿ $ï¼Œ$ğ‘|ğ‘$åˆ™$ğ‘$å¾—ä¸€åˆ†ï¼Œ$ğ‘|ğ‘$åˆ™$ğ‘$å¾—ä¸€åˆ†ã€‚ é—®æœ‰å¤šå°‘ä¸ªæ•°æ²¡æœ‰å¾—åˆ°æ»¡åˆ†ã€‚ Inputç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°$n$ï¼Œä»£è¡¨åºåˆ—çš„å¤§å°ã€‚ ç¬¬äºŒè¡ŒåŒ…å«$n$ä¸ªæ•´æ•°ï¼Œ$s_1,s_2,s_3â€¦s_n$ï¼Œä»£è¡¨åºåˆ—çš„å€¼ã€‚ ç¬¬ä¸‰è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°$t$ï¼Œä»£è¡¨è¯¢é—®ä¸ªæ•°ã€‚ ä¸‹é¢æœ‰$t$è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•°$l_i,r_i$æè¿°ä¸€ä¸ªè¯¢é—®ã€‚ Outputè¾“å‡ºåŒ…å«$t$è¡Œã€‚ ç¬¬$i$è¡Œè¾“å‡ºä¸€ä¸ªæ•°è¡¨ç¤º $[l_i,r_i]$ ä¸­çš„æ²¡æœ‰æ»¡åˆ†çš„æ•°çš„ä¸ªæ•°ã€‚ Sample Input5 1 3 2 4 2 4 1 5 2 5 3 5 4 5 Sample Output4 4 1 1 Note || ï¼ˆæœ¬æ¥æƒ³æ¬æ ·ä¾‹è§£é‡Šçš„ï¼Œä¸è¿‡æ—¢ç„¶æ˜¯é¢˜è§£é‚£å°±ç®—äº†å§ï¼‰ Hint$1\leq n\leq 10^5$ï¼Œ$1\leq s_i\leq 10^9$ã€‚ $1\leq t\leq 10^5$ï¼Œ$1\leq l_i\leq r_i\leq n$ã€‚ æˆ‘ä»¬å¯ä»¥æ¯”è¾ƒæ˜¾ç„¶çš„çŸ¥é“ï¼Œèƒ½ç•™ä¸‹çš„æ•°ä¸€å®šæ˜¯åŒºé—´çš„æœ€å°$gcd$ï¼Œäºæ˜¯æˆ‘ä»¬å°±åªè¦æ‰¾åŒºé—´å†…ä¸åŒºé—´æœ€å°$gcd$ç›¸ç­‰çš„æ•°çš„ä¸ªæ•°ã€‚ åŒºé—´æœ€å°$gcd$ä¸€å®šå°äºç­‰äºåŒºé—´$min$ï¼Œæˆ‘ä»¬åªè¦åˆ¤æ–­æœ€å°å€¼æ˜¯å¦æ˜¯åŒºé—´æœ€å°$gcd$ï¼Œå¦‚æœæ˜¯ï¼Œå°±å¯ä»¥æ±‚å‡ºæœ€å°å€¼çš„ä¸ªæ•°ï¼Œä¹Ÿå°±èƒ½æ±‚å‡ºç­”æ¡ˆäº†ã€‚ æ ¹æ®æ•°æ®èŒƒå›´å’Œè¦æ±‚ç»´æŠ¤çš„æ•°æ®ï¼Œæˆ‘ä»¬å°è¯•ç”¨çº¿æ®µæ ‘æ¥ç»´æŠ¤ã€‚ åˆ†åˆ«ç»´æŠ¤$gcd$ï¼ŒåŒºé—´$min$ï¼Œä»¥åŠåŒºé—´$min$çš„ä¸ªæ•°ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N=100010;struct seg_tree&#123; int min,gcd,cnt;&#125;t[N&lt;&lt;2];int a[N];int n,m;int minA,gcdA,cntA;int gcd(int a,int b)&#123; return !b? a:gcd(b,a%b);&#125;void pushup(int root)&#123; t[root].min=min(t[root&lt;&lt;1].min,t[root&lt;&lt;1|1].min); t[root].gcd=gcd(t[root&lt;&lt;1].gcd,t[root&lt;&lt;1|1].gcd); if(t[root&lt;&lt;1].min==t[root&lt;&lt;1|1].min) t[root].cnt=t[root&lt;&lt;1].cnt+t[root&lt;&lt;1|1].cnt; else if(t[root&lt;&lt;1].min&gt;t[root&lt;&lt;1|1].min) t[root].cnt=t[root&lt;&lt;1|1].cnt; else t[root].cnt=t[root&lt;&lt;1].cnt;&#125;void build(int root,int l,int r)&#123; if(l==r) &#123; t[root].min=t[root].gcd=a[l]; t[root].cnt=1; return; &#125; int mid=l+r&gt;&gt;1; build(root&lt;&lt;1,l,mid); build(root&lt;&lt;1|1,mid+1,r); pushup(root);&#125;void query(int root,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123; gcdA=gcd(gcdA,t[root].gcd); if(minA==t[root].min) cntA+=t[root].cnt; else if(minA&gt;t[root].min) cntA=t[root].cnt,minA=t[root].min; return; &#125; int mid=l+r&gt;&gt;1; if(ll&lt;=mid) query(root&lt;&lt;1,l,mid,ll,rr); if(rr&gt;mid) query(root&lt;&lt;1|1,mid+1,r,ll,rr);&#125;int main(int argc, char const *argv[])&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); build(1,1,n); // cout&lt;&lt;"YES"&lt;&lt;endl; m=read(); while(m--) &#123; int l=read(),r=read(); minA=1000000001; gcdA=cntA=0; query(1,1,n,l,r); if(gcdA==minA) printf("%d\n",r-l+1-cntA); else printf("%d\n",r-l+1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[image]]></title>
    <url>%2F2019%2F02%2F14%2Fimage%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Photo Collection</category>
      </categories>
      <tags>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[èšç¾¤ç®—æ³•(Ant Colony)]]></title>
    <url>%2F2019%2F02%2F14%2F%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©ï¼Œæˆ‘åœ¨ç½‘ä¸Šç¿»åˆ°ä¸€ä¸ªç¥å¥‡çš„ç®—æ³•èšç¾¤ç®—æ³•ï¼æŸå¤§ä½¬çš„blogï¼šhttps://blog.csdn.net/lyxleft/article/details/82980760 è®°å¾—å­¦å“ˆ~]]></content>
      <categories>
        <category>ç©ºé—²æ—¶é—´çš„é›¶ç¢çŸ¥è¯†</category>
      </categories>
      <tags>
        <tag>Magical Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1848 Fibonacci again and again]]></title>
    <url>%2F2019%2F02%2F13%2FHDU-1848-Fibonacci-again-and-again%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜#.Fibonacci again and againé¢˜é¢ ä»»ä½•ä¸€ä¸ªå¤§å­¦ç”Ÿå¯¹è²æ³¢é‚£å¥‘æ•°åˆ—($Fibonacci numbers$)åº”è¯¥éƒ½ä¸ä¼šé™Œç”Ÿï¼Œå®ƒæ˜¯è¿™æ ·å®šä¹‰çš„ï¼š$F(1)=1;$$F(2)=2;$$F(n)=F(n-1)+F(n-2)(n&gt;=3);$æ‰€ä»¥ï¼Œ$1,2,3,5,8,13$â€¦â€¦å°±æ˜¯è²æ³¢é‚£å¥‘æ•°åˆ—ã€‚åœ¨HDOJä¸Šæœ‰ä¸å°‘ç›¸å…³çš„é¢˜ç›®ï¼Œæ¯”å¦‚$1005\ Fibonacci\ again\ and\ again$å°±æ˜¯æ›¾ç»çš„æµ™æ±Ÿçœèµ›é¢˜ã€‚ä»Šå¤©ï¼Œåˆä¸€ä¸ªå…³äº$Fibonacci$çš„é¢˜ç›®å‡ºç°äº†ï¼Œå®ƒæ˜¯ä¸€ä¸ªå°æ¸¸æˆï¼Œå®šä¹‰å¦‚ä¸‹ï¼š1ã€ è¿™æ˜¯ä¸€ä¸ªäºŒäººæ¸¸æˆ;2ã€ ä¸€å…±æœ‰$3$å †çŸ³å­ï¼Œæ•°é‡åˆ†åˆ«æ˜¯$m, n, p$ä¸ªï¼›3ã€ ä¸¤äººè½®æµèµ°;4ã€ æ¯èµ°ä¸€æ­¥å¯ä»¥é€‰æ‹©ä»»æ„ä¸€å †çŸ³å­ï¼Œç„¶åå–èµ°$f$ä¸ªï¼›5ã€ $f$åªèƒ½æ˜¯è²æ³¢é‚£å¥‘æ•°åˆ—ä¸­çš„å…ƒç´ ï¼ˆå³æ¯æ¬¡åªèƒ½å–$\ 1ï¼Œ2ï¼Œ3ï¼Œ5ï¼Œ8$â€¦ç­‰æ•°é‡ï¼‰ï¼›6ã€ æœ€å…ˆå–å…‰æ‰€æœ‰çŸ³å­çš„äººä¸ºèƒœè€…ï¼› å‡è®¾åŒæ–¹éƒ½ä½¿ç”¨æœ€ä¼˜ç­–ç•¥ï¼Œè¯·åˆ¤æ–­å…ˆæ‰‹çš„äººä¼šèµ¢è¿˜æ˜¯åæ‰‹çš„äººä¼šèµ¢ã€‚ Inputè¾“å…¥æ•°æ®åŒ…å«å¤šä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å ä¸€è¡Œï¼ŒåŒ…å«$3â€‹$ä¸ªæ•´æ•°$m,n,pâ€‹$ã€‚$m=n=p=0â€‹$åˆ™è¡¨ç¤ºè¾“å…¥ç»“æŸã€‚ Output å¦‚æœå…ˆæ‰‹çš„äººèƒ½èµ¢ï¼Œè¯·è¾“å‡ºâ€œ$Fibo$â€ï¼Œå¦åˆ™è¯·è¾“å‡ºâ€œ$Nacci$â€ï¼Œæ¯ä¸ªå®ä¾‹çš„è¾“å‡ºå ä¸€è¡Œã€‚ Sample Input1 1 1 1 4 1 0 0 0 Sample OutputFibo Nacci Hint$1\leq m,n,p\leq 1,000$ æ¥è‡ª$ACM\ Short\ Term\ Exam\ 2007/12/13$ (Html Address:http://acm.hdu.edu.cn/search.php?field=problem&amp;key=ACM+Short+Term+Exam_2007%2F12%2F13&amp;source=1&amp;searchmode=source) è¿™é¢˜å•Šï¼ è£¸çš„SGå‡½æ•°å‘€ï¼ æ²¡å­¦è¿‡çš„å¤§ä½¬ä»¬é€›ä¸€æ³¢åšå®¢å§ï¼ ï¼ˆmaybeâ€¦å‡ ä¸‡å¹´ä»¥åæˆ‘ä¹Ÿä¼šå†™ä¸€ç¯‡çš„å§~ï¼‰ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x=0,w=0; char ch=0; while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return w? -x:x;&#125;const int MAXN=1010;int f[MAXN],sg[MAXN];void Fibonacci()&#123; f[1]=1,f[2]=2; for(int i=3;i&lt;=200;++i) &#123; f[i]=f[i-1]+f[i-2]; if(f[i]&gt;1000) break; &#125;&#125;map&lt;int,int&gt; ma;void Build_Map(int lim)&#123; for(int i=1;i&lt;=lim;++i) &#123; ma.clear(); for(int j=1;f[j]&lt;=i;++j) ++ma[sg[i-f[j]]]; for(int j=0;j&lt;=lim;++j) if(!ma[j]) &#123; sg[i]=j; break; &#125; &#125;&#125;int a,b,c;int main()&#123; Fibonacci(); Build_Map(1000); while(1) &#123; a=read(),b=read(),c=read(); if(!a&amp;&amp;!b&amp;&amp;!c) return 0; int sum=0; sum^=sg[a]^sg[b]^sg[c]; if(!sum) puts("Nacci"); else puts("Fibo"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.2.13-Contest]]></title>
    <url>%2F2019%2F02%2F13%2F2019-2-13-Contest%2F</url>
    <content type="text"><![CDATA[æœ¬è’Ÿè’»è¾ƒæ‡’ï¼Œæƒ³ç›´æ¥è´´pdfçš„å›¾ç‰‡ã€‚ äºæ˜¯ä¸‹è½½äº†ä¸€ä¸ªè½¬åŒ–å™¨ï¼Œç»“æœæœ€åä¸€å¼ è¿˜å¸¦äº†æ°´å°ã€‚ (èƒ½çœ‹å°±è¡Œ)]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2640 Help Me Escape]]></title>
    <url>%2F2019%2F02%2F12%2FZOJ-2640-Help-Me-Excape%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜B.Help Me EscapeèƒŒæ™¯If thou doest well, shalt thou not be accepted? and if thou doest not well, sin lieth at the door. And unto thee shall be his desire, and thou shalt rule over him. And Cain talked with Abel his brother: and it came to pass, when they were in the field, that Cain rose up against Abel his brother, and slew him. And the LORD said unto Cain, Where is Abel thy brother? And he said, I know not: Am I my brotherâ€™s keeper? And he said, What hast thou done? the voice of thy brotherâ€™s blood crieth unto me from the ground. And now art thou cursed from the earth, which hath opened her mouth to receive thy brotherâ€™s blood from thy hand; When thou tillest the ground, it shall not henceforth yield unto thee her strength; a fugitive and a vagabond shalt thou be in the earth. â€‹ $ â€”â€” Bible Chapter 4$ é¢˜é¢ Now Cain is unexpectedly trapped in a cave with N paths. Due to LORDâ€™s punishment, all the paths are zigzag and dangerous. The difficulty of the ith path is ci. Then we define f as the fighting capacity of Cain. Every day, Cain will be sent to one of the N paths randomly. Suppose Cain is in front of the ith path. He can successfully take ti days to escape from the cave as long as his fighting capacity f is larger than ci. Otherwise, he has to keep trying day after day. However, if Cain failed to escape, his fighting capacity would increase ci as the result of actual combat. (A kindly reminder: Cain will never died.) As for ti, we can easily draw a conclusion that ti is closely related to ci. Letâ€™s use the following function to describe their relationship: t_i=\lfloor \frac{1+\sqrt 5}2Ã—c_i^2\rfloor After D days, Cain finally escapes from the cave. Please output the expectation of D. ç®€è¦ç¿»è¯‘æœ‰$n$ä¸ªå¦–æ€ªï¼Œæ¯ä¸ªå¦–æ€ªæœ‰ä¸€ä¸ªæˆ˜æ–—åŠ›$c_j$ã€‚å°Aæœ‰ä¸€ä¸ªåˆå§‹æˆ˜æ–—åŠ›$f_0$ã€‚ æ¯å¤©ï¼Œå°Aéšæœºé€‰æ‹©ä¸€ä¸ªå¦–æ€ªå†³æ–—ã€‚è®¾å°Aåœ¨ç¬¬ğ‘–å¤©çš„æˆ˜æ–—åŠ›ä¸º$f_i$ã€‚ è®¾å½“å‰ä¸ºç¬¬$ğ‘–$å¤©ï¼Œå¦‚æœæ‰“èµ¢ï¼Œå³$ğ‘“_i &gt; ğ‘_j$ï¼Œå°±å¯ä»¥é€ƒå‡ºå»ï¼Œéœ€è¦èŠ±$t_j$å¤©ã€‚ å¦‚æœæ‰“ä¸èµ¢ï¼Œå°Aä¼šè®©è‡ªå·±å˜å¼ºï¼Œ$ğ‘“_{i+1} = ğ‘“_i+ ğ‘_j$ã€‚ æ±‚å°Aé€ƒå‡ºæ¥éœ€è¦çš„æœŸæœ›å¤©æ•°ã€‚ Inputè¾“å…¥åŒ…å«å¤šç»„æ•°æ®ã€‚ æ¯ç»„æ•°æ®åŒ…æ‹¬ä¸¤è¡Œã€‚ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ª$n$å’Œ$f$ï¼Œç¬¬äºŒè¡ŒåŒ…å«$n$ä¸ªæ•´æ•°$c_i$ã€‚ Outputå¯¹äºæ¯ç»„æ•°æ®ä½ è¦è¾“å‡ºæœŸæœ›å€¼ï¼Œä¿ç•™å°æ•°ç‚¹åä¸‰ä½ã€‚ Sample Input3 1 1 2 3 Sample Output6.889 Hint$n\leq 100$ï¼Œ$f\leq 10,000$ï¼Œ$c_i\leq10,000ï¼Œ1\leq i\leq n$ã€‚ ç”¨$f(i)$è¡¨ç¤ºæˆ˜æ–—åŠ›ä¸º$i$æ—¶ï¼Œæ‰€éœ€è¦çš„æœŸæœ›å¤©æ•°ã€‚ é‚£ä¹ˆæœ‰ï¼šè‹¥$i&gt;c_j$ï¼Œåˆ™$f(i)=f(i)+\frac 1n(t_j)$ï¼› è‹¥ï¼ˆ$i\leq c_j$ï¼‰ï¼Œåˆ™$f(i)=f(i)+\frac 1n(f(i+c_j)+1)$ã€‚ ç„¶åè¿›è¡Œè®°å¿†åŒ–æœç´¢ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;struct data&#123; int c, t;&#125;;bool vis[100010];vector&lt;data&gt; vs;int N, F;double dp[100010];double dfs(int f)&#123; if (vis[f]) return dp[f]; vis[f] = 1; double A = 0; for (int i = 0; i &lt; N; ++i) if (vs[i].c &gt;= f) A += (1 + dfs(f + vs[i].c)) / N; else A += 1.0 * vs[i].t / N; return dp[f] = A;&#125;int main()&#123; while (~scanf("%d%d", &amp;N, &amp;F)) &#123; vs.clear(); memset(vis, 0, sizeof(vis)); for (int i = 0, g; i &lt; N; ++i) &#123; g = read(); int p = (1 + sqrt(5)) / 2 * g * g; vs.push_back((data) &#123;g, p&#125;); &#125; printf("%.3lf\n", dfs(F)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2096 Collecting Bugs]]></title>
    <url>%2F2019%2F02%2F12%2FPOJ2096-Collecting-Bugs%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜A.Collecting Bugsï¼ˆHtml Address:http://poj.org/problem?id=2096ï¼‰é¢˜é¢Ivan is fond of collecting. Unlike other people who collect post stamps,coins or other material stuff, he collects software bugs. When Ivan gets a new program, he classifies all possible bugs into n categories. Each day he discovers exactly one bug in the program and adds information about it and its category into a spreadsheet. When he finds bugs in all bug categories, he calls the program disgusting, publishes this spreadsheet on his home page, and forgets completely about the program. Two companies, Macrosoft and Microhard are in tight competition. Microhard wants to decrease sales of one Macrosoft program. They hire Ivan to prove that the program in question is disgusting. However, Ivan has a complicated problem. This new program has s subcomponents, and finding bugs of all types in each subcomponent would take too long before the target could be reached. So Ivan and Microhard agreed to use a simpler criteria â€”- Ivan should find at least one bug in each subsystem and at least one bug of each category. Macrosoft knows about these plans and it wants to estimate the time that is required for Ivan to call its program disgusting. Itâ€™s important because the company releases a new version soon, so it can correct its plans and release it quicker. Nobody would be interested in Ivanâ€™s opinion about the reliability of the obsolete version. A bug found in the program can be of any category with equal probability. Similarly, the bug can be found in any given subsystem with equal probability. Any particular bug cannot belong to two different categories or happen simultaneously in two different subsystems. The number of bugs in the program is almost infinite, so the probability of finding a new bug of some category in some subsystem does not reduce after finding any number of bugs of that category in that subsystem. Find an average time (in days of Ivanâ€™s work) required to name the program disgusting. ç®€è¦ç¿»è¯‘ä¸€ä¸ªè½¯ä»¶æœ‰$s$ä¸ªå­ç³»ç»Ÿï¼Œä¼šäº§ç”Ÿ$n$ç§$bug$ã€‚ ä½ æ¯å¤©ä¼šå‘ç°ä¸€ä¸ª$bug$ï¼Œè¿™ä¸ª$bug$å±äºæŸä¸ªå­ç³»ç»Ÿï¼Œå±äºæŸç§$bug$ã€‚ æ¯å¤©å‘ç°çš„$bug$ï¼Œå‡ºç°åœ¨æ¯ä¸ªå­ç³»ç»Ÿä¸­çš„æ¦‚ç‡éƒ½æ˜¯$\frac 1s$ï¼Œå±äºæ¯ç§$bug$çš„æ¦‚ç‡å‡ä¸º$\frac 1n$ã€‚ æ±‚æ‰¾å‡ºæ‰€æœ‰çš„$n$ç§$bug$ï¼Œä¸”æ¯ä¸ªå­ç³»ç»Ÿéƒ½æ‰¾åˆ°$bug$æ‰€éœ€è¦çš„å¤©æ•°çš„æœŸæœ›ã€‚ Inputè¾“å…¥ä¸¤ä¸ªæ•´æ•°$n,s$ã€‚ Outputè¾“å‡ºæœŸæœ›ï¼Œä¿ç•™å°æ•°ç‚¹åå››ä½å°æ•°ã€‚ Sample Input1 2 Sample Output3.0000 Hint$1&lt;n,s\leq 1,000$ è®¾$f(i,j)$è¡¨ç¤ºå·²ç»æ‰¾åˆ°$i$ç§$bug$ï¼Œå­˜åœ¨äº$j$ä¸ªå­ç³»ç»Ÿä¸­çš„æœŸæœ›è¿˜è¦å¤šå°‘å¤©ã€‚ é‚£ä¹ˆ$f(n,s)=0$ï¼Œ$f(0,0)$å³ä¸ºï¼ˆæ­£ä¹‰ï¼‰ç­”æ¡ˆã€‚ çŠ¶æ€è½¬ç§»å¦‚ä¸‹ï¼š $1.$å‘ç°äº†æ–°$bug$ç§ç±»ï¼Œå­˜åœ¨äºæ–°å­ç³»ç»Ÿï¼Œ$p_1=\frac{n-i}nÃ—\frac{s-j}s$ï¼Œè¿˜éœ€è¦$f(i+1,j+1)$å¤©ã€‚ $2.$å‘ç°äº†æ–°$bug$ç§ç±»ï¼Œå­˜åœ¨äºæ—§å­ç³»ç»Ÿï¼Œ$p_2=\frac{n-i}nÃ—\frac js$ï¼Œè¿˜éœ€è¦$f(i+1,j)$å¤©ã€‚ $3.$å‘ç°äº†æ—§$bug$ç§ç±»ï¼Œå­˜åœ¨äºæ–°å­ç³»ç»Ÿï¼Œ$p_3=\frac inÃ—\frac {s-j}s$ï¼Œè¿˜éœ€è¦$f(i,j+1)$å¤©ã€‚ $4.$å‘ç°äº†æ—§$bug$ç§ç±»ï¼Œå­˜åœ¨äºæ—§å­ç³»ç»Ÿï¼Œ$p_4=\frac inÃ—\frac js$ï¼Œè¿˜éœ€è¦$f(i,j)$å¤©ã€‚ æ‰€ä»¥æœŸæœ›çš„è½¬ç§»æ–¹ç¨‹ä¸ºï¼š f(i,j)=p_1f(i+1,j+1)+p_2f(i+1,j)+p_3f(i,j+1)+p_4f(i,j)+1ç§»é¡¹$f(i,j)$å¯å¾—ï¼š f(i,j)=\frac{p_!f(i+1,j+1)+p_2f(i+1,j)+p_3f(i,j+1)+1}{1-p_4}â€‹æ—¶é—´å¤æ‚åº¦ä¸º$O(ns)$ã€‚ Code123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;int n, s;double f[1010][1010];int main(int argc, char const *argv[])&#123; while(~scanf("%d%d",&amp;n,&amp;s)) &#123; memset(f,0,sizeof(f)); for (int i = n; ~i; --i) for (int j = s; ~j; --j) &#123; if (i == n &amp;&amp; j == s) continue; double p1 = 1.0 * (n - i) / n * (s - j) / s; double p2 = 1.0 * (n - i) / n * j / s; double p3 = 1.0 * i / n * (s - j) / s; double p4 = 1.0 * i / n * j / s; f[i][j] = 1.0 * (p1 * f[i + 1][j + 1] + p2 * f[i + 1][j] + p3 * f[i][j + 1] + 1) / (1.0 - p4); &#125; printf("%.4f\n", f[0][0]); &#125; return 0;&#125; pojæœ‰æ¯’å•¦ï¼ æœ€åæ˜æ˜åº”è¯¥è¾“å‡ºâ€œ$\%.4lf$â€ï¼Œç»“æœå¼ºè¡Œâ€$\%.4f$â€æ‰è¿‡ã€‚ [â—‹ï½¥ï½€Ğ”Â´ï½¥ â—‹]ï¼ï¼ï¼]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#301 D.Bad Luck Island]]></title>
    <url>%2F2019%2F02%2F12%2FCodeForces-301-D-Bad-Luck-Island%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜E.Bad Luck Islandé¢˜é¢The Bad Luck Island is inhabited by three kinds of species: $r$ rocks, $s$ scissors and $p$ papers. At some moments of time two random individuals meet (all pairs of individuals can meet equiprobably), and if they belong to different species, then one individual kills the other one: a rock kills scissors,scissors kill paper, and paper kills a rock. Your task is to determine for each species what is the probability that this species will be the only one to inhabit this island after a long enough period of time. ç®€è¦é¢˜æ„åœ¨ä¸€ä¸ªå²›ä¸Šï¼Œæœ‰ $ğ‘Ÿ + ğ‘  + ğ‘$ ä¸ªäººï¼Œå…¶ä¸­æœ‰$ğ‘Ÿ$ä¸ªäººæœ‰çŸ³å¤´ï¼Œ$ğ‘ $ä¸ªäººæœ‰å‰ªåˆ€ï¼Œ$ğ‘$ä¸ªäººæœ‰å¸ƒã€‚ éµå¾ªçŸ³å¤´å‰ªåˆ€å¸ƒçš„åŸåˆ™ï¼Œè¾“çš„äººå°±ç‹—å¸¦äº†ã€‚æ¯ä¸¤ä¸ªäººé‡åˆ°æ¦‚ç‡çš„ç›¸ç­‰ã€‚æ±‚æ¯ä¸ªäººå­˜æ´»çš„æ¦‚ç‡ã€‚ æ˜¾ç„¶æœ‰åŒç§ä¸œè¥¿çš„äººå­˜æ´»æ¦‚ç‡ç›¸ç­‰ï¼Œä½ åªéœ€è¦è¾“å‡ºæœ‰çŸ³å¤´ï¼Œå‰ªåˆ€ï¼Œå¸ƒçš„äººçš„å­˜æ´»æ¦‚ç‡å³å¯ã€‚ Inputä¸€è¡ŒåŒ…æ‹¬ä¸‰ä¸ªæ•´æ•° $r,s,p$ ï¼Œå¦‚é¢˜æ„æ‰€ç¤ºåˆ†åˆ«ä»£è¡¨çŸ³å¤´ï¼Œå‰ªåˆ€ï¼Œå¸ƒã€‚ Outputè¾“å‡ºä¸‰ä¸ªå®æ•°ï¼Œç”±ç©ºæ ¼éš”å¼€ï¼Œåˆ†åˆ«ä»£è¡¨çŸ³å¤´ï¼Œå‰ªåˆ€ï¼Œå¸ƒå­˜æ´»çš„æ¦‚ç‡ï¼Œå¦‚æœè¾“å‡ºä¸ç­”æ¡ˆçš„è¯¯å·®ä¸è¶…è¿‡$10^{-9}â€‹$ï¼Œåˆ™è®¤ä¸ºç­”æ¡ˆæ­£ç¡®ã€‚ Sample Input 12 2 2 Sample Output 10.333333333333 0.333333333333 0.333333333333 Sample Input 22 1 2 Sample Output 20.150000000000 0.300000000000 0.550000000000 Sample Input 31 1 3 Sample Output 30.057142857143 0.657142857143 0.285714285714 Hint$1\leq r,s,p\leq100â€‹$ ä¸è§£é‡Šäº†å§ï¼Ÿ ä¸€é“æœŸæœ›$dp$ï¼Œè®¾$f[i][j][k]$ï¼Œ$i$ä¸ºå‡ºçŸ³å¤´çš„äººï¼Œ$j$ä¸ºå‡ºå‰ªåˆ€çš„äººï¼Œ$k$ä¸ºå‡ºå¸ƒçš„äººï¼Œç»„åˆä¸€æ³¢å³å¯ã€‚ åˆå§‹çŠ¶æ€ä¸º$f[r][s][p]=1$ï¼Œè½¬ç§»æ–¹ç¨‹è§ä»£ç å§ï¼ŒåŸºæœ¬ç›¸åŒã€‚ Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 110;int r, s, p;double f[N][N][N], A1, A2, A3;long long calc(int x, int y, int z)&#123; return max(((x + y + z) * (x + y + z - 1) - x * (x - 1) - y * (y - 1) - z * (z - 1)) &gt;&gt; 1, 1);&#125;int main()&#123; r = read(), s = read(), p = read(); f[r][s][p] = 1; for (int i = r; ~i; --i) for (int j = s; ~j; --j) for (int k = p; ~k; --k) &#123; if (!i &amp;&amp; !j &amp;&amp; !k) continue; if (i == r &amp;&amp; j == s &amp;&amp; k == p) continue; f[i][j][k] += f[i + 1][j][k] * (1.0 * (i + 1) * k / calc(i + 1, j, k)); f[i][j][k] += f[i][j + 1][k] * (1.0 * (j + 1) * i / calc(i, j + 1, k)); f[i][j][k] += f[i][j][k + 1] * (1.0 * (k + 1) * j / calc(i, j, k + 1)); &#125; for (int i = 1; i &lt;= r; ++i) A1 += f[i][0][0]; for (int i = 1; i &lt;= s; ++i) A2 += f[0][i][0]; for (int i = 1; i &lt;= p; ++i) A3 += f[0][0][i]; printf("%.11lf %.11lf %.11lf", A1, A2, A3); return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu P1654 OSU!]]></title>
    <url>%2F2019%2F02%2F12%2Fluogu-P1654-OSU%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜D.OSU!é¢˜é¢ osu æ˜¯ä¸€æ¬¾ç¾¤ä¼—å–œé—»ä¹è§çš„ä¼‘é—²è½¯ä»¶ã€‚ æˆ‘ä»¬å¯ä»¥æŠŠosuçš„è§„åˆ™ç®€åŒ–ä¸æ”¹ç¼–æˆä»¥ä¸‹çš„æ ·å­: ä¸€å…±æœ‰næ¬¡æ“ä½œï¼Œæ¯æ¬¡æ“ä½œåªæœ‰æˆåŠŸä¸å¤±è´¥ä¹‹åˆ†ï¼ŒæˆåŠŸå¯¹åº”1ï¼Œå¤±è´¥å¯¹åº”0ï¼Œnæ¬¡æ“ä½œå¯¹åº”ä¸º1ä¸ªé•¿åº¦ä¸ºnçš„01ä¸²ã€‚åœ¨è¿™ä¸ªä¸²ä¸­è¿ç»­çš„ Xä¸ª1å¯ä»¥è´¡çŒ®X^3 çš„åˆ†æ•°ï¼Œè¿™xä¸ª1ä¸èƒ½è¢«å…¶ä»–è¿ç»­çš„1æ‰€åŒ…å«ï¼ˆä¹Ÿå°±æ˜¯æé•¿çš„ä¸€ä¸²1ï¼Œå…·ä½“è§æ ·ä¾‹è§£é‡Šï¼‰ ç°åœ¨ç»™å‡ºnï¼Œä»¥åŠæ¯ä¸ªæ“ä½œçš„æˆåŠŸç‡ï¼Œè¯·ä½ è¾“å‡ºæœŸæœ›åˆ†æ•°ï¼Œè¾“å‡ºå››èˆäº”å…¥åä¿ç•™1ä½å°æ•° Input ç¬¬ä¸€è¡Œæœ‰ä¸€ä¸ªæ­£æ•´æ•°n,è¡¨ç¤ºæ“ä½œä¸ªæ•°ã€‚æ¥ä¸‹å»nè¡Œæ¯è¡Œæœ‰ä¸€ä¸ª[0,1]ä¹‹é—´çš„å®æ•°ï¼Œè¡¨ç¤ºæ¯ä¸ªæ“ä½œçš„æˆåŠŸç‡ã€‚ Output åªæœ‰ä¸€ä¸ªå®æ•°ï¼Œè¡¨ç¤ºç­”æ¡ˆã€‚ç­”æ¡ˆå››èˆäº”å…¥åä¿ç•™1ä½å°æ•°ã€‚ Sample Input30.50.50.5 Sample Output6.0 Hint 000åˆ†æ•°ä¸º0ï¼Œ001åˆ†æ•°ä¸º1ï¼Œ010åˆ†æ•°ä¸º1ï¼Œ100åˆ†æ•°ä¸º1ï¼Œ101åˆ†æ•°ä¸º2ï¼Œ110åˆ†æ•°ä¸º8ï¼Œ011åˆ†æ•°ä¸º8ï¼Œ111åˆ†æ•°ä¸º27ï¼Œæ€»å’Œä¸º48ï¼ŒæœŸæœ›ä¸º48/8=6.0 $N\leq 10^5$ å­¦ä¹ $luogu$ä¸Š$hall_of_history$å¤§ä½¬ç®€æ´çš„é¢˜è§£ã€‚ é¦–å…ˆï¼Œå­¦è¿‡æ•°å­¦çš„å¹¼å„¿å›­æ¯•ä¸šç”Ÿéƒ½çŸ¥é“$(x+1)^3=x^3+3x^2+3x+1â€‹$ æ¯å¤šå¢åŠ ä¸€ä¸ª1ï¼Œåˆ™ç­”æ¡ˆå°±å˜ä¸ºåŸå…ˆçš„$(x+1)^3=x^3+3x^2+3x+1$ï¼Œ ä¹Ÿå°±æ˜¯æ¯”åŸå…ˆå¤šäº†$(x+1)^3-x^3=3x^2+3x+1$ã€‚ ç»´æŠ¤è¿™ä¸ªå¢åŠ çš„æœŸæœ›ï¼Œç»´æŠ¤$x_1[i]$è¡¨ç¤º$x$çš„æœŸæœ›ï¼Œç»´æŠ¤$x_2[i]$è¡¨ç¤º$x^2$çš„æœŸæœ›ã€‚ åˆ™æœ‰$x_1[i]=(x_1[i-1]+1)Ã—p[i]$ï¼Œ$x_2[i]=(x_2[i-1]+2Ã—x_1[i-1]+1)Ã—p[i]$ã€‚ æ‰€ä»¥æœ‰ï¼š $Ans[i]=Ans[i-1]+(3Ã—x_2[i-1]+3Ã—x_1[i-1]+1)Ã—p[i]$ã€‚ æˆ‘ä»¬æ±‚$Ans[n]$å³å¯ã€‚ Code1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;long long read()&#123; long long x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e5 + 10;double p[N], x1[N], x2[N], Ans[N];long long n;int main()&#123; n = read(); for (int i = 1; i &lt;= n; ++i) scanf("%lf", &amp;p[i]); for (int i = 1; i &lt;= n; ++i) &#123; x1[i] = (x1[i - 1] + 1) * p[i]; x2[i] = (x2[i - 1] + 2 * x1[i - 1] + 1) * p[i]; Ans[i] = Ans[i - 1] + (3 * x2[i - 1] + 3 * x1[i - 1] + 1) * p[i]; &#125; printf("%.1lf", Ans[n]); return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6390 GUGUFISHTION]]></title>
    <url>%2F2019%2F02%2F11%2FHDU-6390-GUGUFISHTION%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜A.GUGUFISHTIONé¢˜é¢ç»™å‡º$m,n,p$ï¼Œæ±‚ï¼š$\sum_{a=1}^m\sum_{b=1}^n\frac {\phi(ab)}{\phi(a)\phi(b)}\ mod\ \ p$ Inputç¬¬ä¸€è¡Œä¸€ä¸ª$T$ä»£è¡¨ç»„æ•°ã€‚ ä¹‹åçš„$T$è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸‰ä¸ªæ•´æ•°$m,n,p$ã€‚ æ•°æ®ä¿è¯$p$æ˜¯ä¸€ä¸ªè´¨æ•°ã€‚ Outputè¾“å‡º$Tâ€‹$è¡Œï¼Œæ¯è¡Œåªæœ‰ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚ Sample Input1 5 7 23 Sample Output2 Hint$1\leq T \leq 3â€‹$ $1\leq m,n\leq1,000,000$ $max(m,n)&lt; p \leq 10^9+7â€‹$ ç”±æ¬§æ‹‰å‡½æ•°çš„æ€§è´¨$\phi(p^k)=(p-1)Ã—p^{k-1}(pä¸ºè´¨æ•°)$ã€‚ ä»¤$d=gcd(a,b)=p_1^{k_1}Ã—p_2^{k_2}Ã—â€¦Ã—p_n^{k_n}â€‹$ã€‚ $G_u(a,b)=\frac {\phi(a,b)}{\phi(a)\phi(b)}=\frac{\phi(p_1^{2k_1}Ã—p_2^{2k_2}Ã—â€¦Ã—p_n^{2k_n})}{\phi(p_1^{k_1}Ã—p_2^{k_2}Ã—â€¦Ã—p_n^{k_n})^2}$ ç”±äºæ¬§æ‹‰å‡½æ•°ä¸ºç§¯æ€§å‡½æ•°ï¼Œä¸”å› ä¸ºå„é¡¹ä¸Šä¸‹äº’è´¨ï¼Œå±•å¼€çº¦å»ã€‚ $G_u(a,b)=\frac {(p_1-1)Ã—(p_2-1)Ã—(p_3-1)Ã—â€¦Ã—(p_n-1)Ã—p_1^{2k_1-1}Ã—p_2^{2k_2-1}Ã—â€¦Ã—p_n^{2k_n-1}}{(p_1-$1)^2Ã—(p_2-1)^2Ã—(p_3-1)^2Ã—â€¦Ã—(p_n-1)^2Ã—p_1^{k_1-1}Ã—p_2^{k_2-1}Ã—â€¦Ã—p_n^{k_n-1}}â€‹$ $=\frac {p_1Ã—p_2Ã—p_3Ã—â€¦Ã—p_n}{(p_1-1)Ã—(p_2-1)Ã—â€¦Ã—(p_n-1)}=\frac {p_1Ã—p_2Ã—p_3Ã—â€¦Ã—p_nÃ—p_1^{k_1-1}Ã—p_2^{k_2-1}Ã—â€¦Ã—p_n^{k_n-1}}{(p_1-1)Ã—(p_2-1)Ã—(p_3-1)Ã—â€¦Ã—(p_n-1)Ã—p_1^{k_1-1}Ã—p_2^{k_2-2}Ã—â€¦Ã—p_n^{k_n-1}}â€‹$ $=\frac {p_1^{k_1}Ã—p_2^{k_2}Ã—â€¦Ã—p_n^{k_n}}{\phi(p_1^{k_1}Ã—p_2^{k_2}Ã—â€¦Ã—p_n^{k_n})}=\frac {d}{\phi{d}}â€‹$ ä»¤$a[i]=\frac i{\phi(i)}â€‹$ï¼Œ$f(m,n)=\sum_{a=1}^m\sum_{b=1}^nG_u(a,b)=\sum_{a=1}^m\sum_{b=1}^naÃ—dâ€‹$ $f(m,n)=\sum_{d=1}^{min(m,n)}\sum_{a=1}^m\sum_{b=1}^na[t]Ã—[d==t]=\sum_{d=1}^{min(m,n)}\sum_{a=1}^{\lfloor \frac mt\rfloor}\sum_{b=1}^{\lfloor \frac nt\rfloor}a[t]Ã—[d==1]$ $[åˆ°æ­¤å¤„dçš„å®šä¹‰å–æ¶ˆï¼Œæ‡’å¾—ä¿®æ”¹ï¼Œå†™å®Œå‘ç°ä¸å¯¹äº†]â€‹$â•®(â•¯â–½â•°)â•­ ä»¤$g(m,n)=\sum_{a=1}^m\sum_{b=1}^n[d==1]=\sum_{a=1}^m\sum_{b=1}^n\sum_{d|gcd(a,b)}\mu(d)=\sum_{d=1}^{min(a,b)}\mu(d)Ã—\frac mdÃ—\frac nd$ å› ä¸ºæœ‰ï¼š $\sum_{d|n}\mu(d)=1\ \ (n==1)$ $\sum_{d|n}\mu(d)=0\ \ (n&gt;1)$ å½“$gcd(a,b)==1$ï¼Œåˆ™$\sum_{d|gcd(a,b)}\mu(d)=1$ï¼› å½“$gcd(a,b)\ !\ =1â€‹$ï¼Œåˆ™$\sum_{d|gcd(a,b)}\mu(d)=0ï¼Œ=[gcd(a,b)==1]â€‹$ã€‚ å› ä¸º$\frac md$è¡¨ç¤ºåœ¨$aâˆˆ[1,m]$ä¸­èƒ½è¢«$d$æ•´é™¤çš„æ•°çš„ä¸ªæ•°ï¼Œ$\frac nd$è¡¨ç¤ºåœ¨$bâˆˆ[1,n]$ä¸­èƒ½è¢«$d$æ•´é™¤çš„æ•°çš„ä¸ªæ•°ã€‚ æ‰€ä»¥ï¼Œå¯è¯ç­‰ä»·ã€‚ æ‰€ä»¥æœ‰$f(m,n)=\sum_{d=1}^{min(m,n)}a[t]Ã—(\sum_{a=1}^{\lfloor \frac mt\rfloor}\sum_{b=1}^{\lfloor \frac nt\rfloor}[d==1])=\sum_{d=1}^{min(m,n)}a[t]Ã—g(\frac mt,\frac nt)$ã€‚ æ—¶é—´å¤æ‚åº¦$\frac n1+\frac n2+\frac n3+\frac n4+â€¦+\frac n{n-1}+\frac nn=nln(n)+Cï¼ˆCä¸ºæ¬§æ‹‰å‡½æ•°ï¼‰$ æ²¡æƒ³å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º$O(ln(n))â€‹$ï¼Œæ‰€ä»¥æ€»æ—¶é—´å¤æ‚åº¦ä¸º$O(nln(n))â€‹$ã€‚ CODEï¼šå› ä¸ºæ€»æœ‰$\phi(i)&lt;i$ï¼Œé¢„å¤„ç†å‡º$max(m,n)â€‹$ä¸ªé€†å…ƒå³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;long long read()&#123; long long x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e6 + 10;bool notprime[N];int mu[N], p[N], cnt;long long m, n, mod;long long phi[N], a[N], inv[N];void Prime()&#123; phi[1] = mu[1] = 1; notprime[1] = 1; for (int i = 2; i &lt;= 1000000; ++i) &#123; if (!notprime[i]) &#123; p[++cnt] = i; phi[i] = i - 1; mu[i] = -1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= 1000000; ++j) &#123; notprime[i * p[j]] = 1; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; else &#123; phi[i * p[j]] = phi[i] * (p[j] - 1); mu[i * p[j]] = -mu[i]; &#125; &#125; &#125;&#125;void inv_work(int lim)&#123; inv[1] = 1; for (int i = 2; i &lt;= lim; ++i) inv[i] = inv[mod % i] * (mod - mod / i) % mod; for (int i = 1; i &lt;= lim; ++i) a[i] = inv[phi[i]] * i % mod;&#125;int main()&#123; int T = read(); Prime(); while (T--) &#123; m = read(), n = read(), mod = read(); int lim = min(m, n); inv_work(lim); long long result = 0; for (int i = 1; i &lt;= lim; ++i) &#123; int pp = m / i, qq = n / i; long long t = 0; for (int j = 1; j &lt;= min(pp, qq); ++j) (t += 1ll * mu[j] * (pp / j) * (qq / j) + mod) %= mod; (result += a[i] * t % mod) %= mod; &#125; cout &lt;&lt; result &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4804 æ¬§æ‹‰å¿ƒç®—]]></title>
    <url>%2F2019%2F02%2F11%2Fbzoj-4804-%E6%AC%A7%E6%8B%89%E5%BF%83%E7%AE%97%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜C.æ¬§æ‹‰å¿ƒç®—é¢˜é¢ç»™å‡ºä¸€ä¸ªæ•°å­—Nï¼Œæ±‚$\sum_{i=1}^n\sum_{j=1}^n\phi(gcd(i,j))$ã€‚ Input ç¬¬ä¸€è¡Œä¸ºä¸€ä¸ªæ­£æ•´æ•°$Tâ€‹$ï¼Œè¡¨ç¤ºæ•°æ®ç»„æ•°ã€‚ æ¥ä¸‹æ¥$T$è¡Œä¸ºè¯¢é—®ï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªæ­£æ•´æ•°$N$ã€‚ Output æŒ‰è¯»å…¥é¡ºåºè¾“å‡ºç­”æ¡ˆã€‚ Sample Input1 10 Sample Output 136 Hint $T\leq5000,N\leq10^7$ è§£æè«æ¯”ä¹Œæ–¯åæ¼”ä¸€æ³¢å¯å¾—ï¼š Ans=\sum_{i=1}^n\sum_{j=1}^n\phi(gcd(i,j))=\sum_{i=1}^n\phi(i)\sum_{d=1}^{\lfloor\frac ni\rfloor}\mu(d)\lfloor\frac n{id}\rfloor^2ä»¤$g(n)=\sum_{d=1}^n\mu(d)\lfloor\frac nd\rfloor^2â€‹$ å› ä¸º$\lfloor\frac nd\rfloor-\lfloor\frac {n-1}d\rfloor=1$æˆç«‹å½“ä¸”ä»…å½“$d|n$ é‚£ä¹ˆ$g(n)=g(n-1)+\sum_{d|n}\mu(d)(2\frac {n}d-1)$ å› ä¸º$\sum_{d|n}\frac {\mu(d)}d=\frac {\phi(n)}n$ $g(n)=g(n-1)+2\phi(d)-[n==1]â€‹$ äºæ˜¯æœ‰$Ans=\sum_{i=1}^n\phi(i)g(\lfloor\frac ni\rfloor)$ è¯¥ç®—æ³•æ—¶é—´å¤æ‚åº¦ä¸º$O(T\sqrt N)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e7 + 10;int p[N], cnt, q[5010], T;long long phi[N], g[N];bool notprime[N];void work(int m, long long ans = 0)&#123; for (int i = 1, ne; i &lt;= m; i = ne + 1) &#123; ne = m / (m / i); ans += (phi[ne] - phi[i - 1]) * g[m / i]; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;void Prime()&#123; phi[1] = g[1] = 1, notprime[1] = 1; for (int i = 2; i &lt;= 10000000; ++i) &#123; if (!notprime[i]) &#123; p[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= 10000000; ++j) &#123; notprime[i * p[j]] = 1; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; else phi[i * p[j]] = phi[i] * (p[j] - 1); &#125; g[i] = g[i - 1] + 2 * phi[i]; &#125; for (int i = 2; i &lt;= 10000000; ++i) phi[i] += phi[i - 1];&#125;int main()&#123; T = read(); Prime(); while (T--) work(read()); return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3994/luogu P3327 çº¦æ•°ä¸ªæ•°å’Œ]]></title>
    <url>%2F2019%2F02%2F11%2Fbzoj-3994-luogu-P3327-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜D.çº¦æ•°ä¸ªæ•°å’Œé¢˜é¢è®¾d(x)ä¸ºxçš„çº¦æ•°ä¸ªæ•°ï¼Œç»™å®šNã€Mï¼Œæ±‚ $\sum_{i=1}^{N}\sum_{j=1}^{M}d(iÃ—j)$. Inputè¾“å…¥æ–‡ä»¶åŒ…å«å¤šç»„æµ‹è¯•æ•°æ®ã€‚ ç¬¬ä¸€è¡Œï¼Œä¸€ä¸ªæ•´æ•°Tï¼Œè¡¨ç¤ºæµ‹è¯•æ•°æ®çš„ç»„æ•°ã€‚ æ¥ä¸‹æ¥çš„Tè¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•°Nã€Mã€‚ OutputTè¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºä½ æ‰€æ±‚çš„ç­”æ¡ˆã€‚ Sample Input27 45 6 Sample Output110 121 Hint$1\leq N,M \leq 50,000$ $1\leq T \leq 50,000$ å“ï¼Œä»Šå¤©fhjå¤§ä½¬è®²è¯¾ä¹Ÿæ˜¯å¾ˆæ— å¥ˆï¼Œè«æ¯”ä¹Œæ–¯åæ¼”è™½ç„¶æ˜¯å­¦äº†ï¼Œä½†æ˜¯ç¡®å®ä¸å¤ªä¼šç”¨å“‡ã€‚ å…¬å¼ææƒ§ç—‡æ‚£è€…ä¸€æšâ€¦â€¦ ç¬¬ä¸€æ­¥â€‹ é¦–å…ˆï¼Œæˆ‘ä»¬è¯æ˜ä¸€æ¡ç»“è®ºï¼šd(nÃ—m)=\sum_{i|n}\sum_{j|m}[gcd(i,j)==1] â€‹ è¯æ˜ï¼šå¯¹äºnmæ¯ä¸€ä¸ªè´¨å› å­$p_i$ï¼Œæˆ‘ä»¬ä»¤$n={p_i}^{a_i}Ã—n_x,m={p_i}^{b_i}Ã—m_x$ï¼Œåˆ™æœ‰d(nÃ—m)=\Pi_i(a_i+b_i+1)â€‹ï¼Œè®¾ $l$ å’Œ $t$ äº’è´¨ä¸”ä¸å«è´¨å› å­$p_i$ï¼Œé‚£ä¹ˆ$(lÃ—{p_i}^{a_i},t),(lÃ—{p_i}^{a_i-1})â€¦(l,t)â€¦(l,tÃ—{p_i}^{b_i-1}),(l,tÃ—{p_i}^{b_i})$éƒ½æ˜¯äº’è´¨çš„æ•°å¯¹ï¼Œè€Œ $ l$ å’Œ $ t $ çš„å–æ³•åˆšå¥½æ˜¯$\Pi_{k\neq i}(a_k+b_k+1)$ç§ã€‚ ç¬¬äºŒæ­¥â€‹ ä¸‹é¢æ˜¯å…¬å¼ææƒ§ç—‡çš„â€œç¦åˆ©â€ï¼Ÿï¼ \sum_{i=1}^n\sum_{j=1}^md(iÃ—j)=\sum_{i=1}^n\sum_{j=1}^m\sum_{k|i}\sum_{l|j}[gcd(k,l)==1]â€‹â€‹ ç°åœ¨æˆ‘ä»¬æšä¸¾æ¯ä¸€ä¸ªæ•°å¯¹$(k,l)$,é‚£ä¹ˆå®ƒä»¬ä¼šè¢«ç®—å¤šå°‘éå‘¢ï¼Ÿæ¯ä¸€ä¸ª$k$çš„å€æ•°éƒ½ä¼šç®—ä¸€æ¬¡$k$ï¼Œæ¯ä¸€ä¸ª$l$çš„å€æ•°åˆä¼šç®—ä¸€æ¬¡$l$,è€Œç”¨$\frac nk$æ¥è¡¨ç¤ºnä»¥å†…kçš„å€æ•°æœ‰å¤šå°‘ä¸ªæ˜¯æ˜¾ç„¶çš„ï¼Œæ‰€ä»¥ï¼š \sum_{k=1}^n\sum_{l=1}^m\frac nkÃ—\frac ml[gcd(k,l)==1]â€‹ ç„¶åæˆ‘ä»¬èƒ½å¤Ÿç”¨è«æ¯”ä¹Œæ–¯å‡½æ•°çš„æ€§è´¨ï¼š \sum_{d|n}\mu(d)=1\ (n==1)\sum_{d|n}\mu(d)=0\ (n>1)â€‹ é‚£æˆ‘ä»¬å°±å¯ä»¥å¾—åˆ°ï¼š \sum_{k=1}^n\sum_{l=1}^m\frac nkÃ—\frac ml\sum_{d|gcd(k,l)}\mu(d)â€‹ å¦‚æœ$gcd(k,l)==1$ï¼Œæ­¤æ—¶åé¢çš„è¿™äº›ç­‰äº1ï¼Œå¦åˆ™æ˜¯0ã€‚ â€‹ æˆ‘ä»¬å°±èƒ½å¾—åˆ°ï¼š \sum_{k=1}^n\sum_{l=1}^m\frac nkÃ— \frac ml\sum_{d|kä¸”d|l}\mu(d)â€‹ æˆ‘ä»¬åªè¦æšä¸¾$\mu(d)$ï¼Œæ˜¾ç„¶ï¼Œæˆ‘ä»¬åªè¦æšä¸¾dçš„å€æ•°æ¥ä¸$\mu(d)$ç›¸ä¹˜å³å¯ã€‚ \sum_{d=1}^{min(n,m)}\mu(d)\sum_{i=1}^\frac nd\sum_{j=1}^\frac md\frac n{d_i}Ã—\frac m{d_j}ç¬¬ä¸‰æ­¥â€‹ æˆ‘ä»¬ç”±ç¬¬äºŒæ­¥ç»§ç»­å˜å½¢å¯å¾—ï¼š \sum_{d=1}^{min(n,m)}\mu(d)Ã—(\sum_{k=1}^{\frac nd}\frac n{dk})Ã—(\sum_{l=1}^{\frac md}\frac m{dl})ä»¤$g(x)=\sum_{i=1}^x\frac xiâ€‹$ \sum_{d=1}^{min(n,m)}\mu(d)Ã—g(\frac nd)Ã—g(\frac md)æˆ‘ä»¬é¢„å¤„ç†å‡º$g(x)â€‹$å³å¯ã€‚ è§‚å¯Ÿä¸€ä¸‹$g(x)$ï¼Œå°±ä¼šå‘ç°å…¶å®å¼å­å¯ä»¥è¿™ä¹ˆç†è§£ï¼š$x$ä»¥å†…æœ‰çº¦æ•°içš„æ•°çš„ä¸ªæ•°å’Œï¼Œä¹Ÿå°±æ˜¯å¯çœ‹ä½œåŸé¢˜ä¸­$d(x)$çš„å‰ç¼€å’Œè¦æ±‚$d(x)$çš„å‰ç¼€å’Œï¼Œå¯ä»¥æ±‚å‡ºæ¯ä¸€ä¸ª$d(x)$,ä¹Ÿå°±æ˜¯ç”¨çº¿æ€§ç­›æ±‚å•¦ï¼Œè¦è®°å½•ä¸€ä¸‹$c(x)$:å°†$x$åˆ†è§£è´¨å› æ•°åï¼Œæœ€å°è´¨å› æ•°çš„æŒ‡æ•°ã€‚é‚£ä¹ˆå‚è§ç¬¬ä¸€æ­¥ï¼Œxçš„æœ€å°è´¨å› æ•°å¯¹$d(x)$çš„è´¡çŒ®ä¸º$c(x)+1$ã€‚ ç¬¬å››æ­¥â€‹ ä»£ç å®ç° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;int mu[500010],p[50010],cnt,n,m;long long a[500010],b[500010];bool notprime[500010];void Prime()&#123; mu[1]=a[1]=b[1]=1; for(int i=2;i&lt;=50000;++i) &#123; if(!notprime[i]) &#123; p[++cnt]=i; mu[i]=-1,a[i]=1,b[i]=2; &#125; for(int j=1;j&lt;=cnt&amp;&amp;i*p[j]&lt;=50000;++j) &#123; notprime[i*p[j]]=1; if(i%p[j]==0) &#123; b[i*p[j]]=b[i]/(a[i]+1)*(a[i]+2); a[i*p[j]]=a[i]+1; break; &#125; else &#123; b[i*p[j]]=b[i]*b[p[j]]; a[i*p[j]]=1; mu[i*p[j]]=-mu[i]; &#125; &#125; &#125; for(int i=2;i&lt;=50000;++i) &#123; b[i]+=b[i-1]; mu[i]+=mu[i-1]; &#125;&#125;int main()&#123; int T=read(); Prime(); while(T--) &#123; long long result=0; n=read(),m=read(); if(n&gt;m) swap(n,m); for(int i=1,j;i&lt;=n;i=j+1) &#123; j=min(n/(n/i),m/(m/i)); result+=(mu[j]-mu[i-1])*b[n/i]*b[m/i]; &#125; cout&lt;&lt;result&lt;&lt;endl; &#125; return 0;&#125; p.s.è¿˜æœ‰å¾ˆé‡è¦çš„ä¸€ç‚¹ï¼Œå¦‚æœåˆå§‹åŒ–ç”¨è¿™æ ·a[N]={0,1}ï¼Œä¼šå¯¼è‡´exeæ–‡ä»¶è¿‡å¤§è€Œæ— æ³•æäº¤ï¼Œå˜¤å˜¤å˜¤ï¼Œæ„Ÿè°¢vhoscå·¨ä½¬â€¦â€¦(/â‰§â–½â‰¦)/]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.5.30 é›†è®­æ€»ç»“]]></title>
    <url>%2F2018%2F05%2F30%2F2018-5-30%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~æ€»ç»“ï¼š å…ˆä»ç¬¬ä¸€å¤©çš„æ¯”èµ›å¼€å§‹çœ‹ï¼Œå…¶å®å…‰ä»é¢˜ç›®æ¥çœ‹ï¼Œæˆ‘æ’äºç¬¬ä¸ƒåçš„æˆç»©ï¼Œä¹Ÿå°±æ˜¯ä¸¤é“æ°´é¢˜å’Œä¸€é“æ¯”è¾ƒç†Ÿç»ƒçš„BFSç»™çš„ï¼Œåé¢å‡ é¢˜æ˜¯æ²¡æœ‰æ€è·¯çš„ï¼ˆå¤§ä½¬ä»¬å¤ªå¼ºäº†å•Šï¼‰ï¼Œè¢«å®Œè™â€¦â€¦ æˆ‘å†ä»æ˜¨å¤©çš„ACMæ¬¢ä¹èµ›å¼€å§‹è¯´èµ·â€”â€”â€”â€”æ¯”èµ›ç¬¬ä¸€ä¸ªå°æ—¶ï¼Œä»Aé¢˜çš„æ°´é¢˜ååˆ†é’Ÿå®Œæˆçš„é€Ÿåº¦æ¥çœ‹ï¼Œç¨ç¨æ”¾å®½äº†å¿ƒæ€ï¼Œç„¶è€Œåœ¨Bé¢˜ä¸Šç«Ÿç„¶æ ½äº†è·Ÿå¤´ã€‚æœ€åˆåœ¨ç¬¬ä¸‰ä¸ªç‚¹WAäº†2éï¼Œå†åœ¨14ç‚¹WAäº†å¥½å‡ éï¼Œæœ€ååˆå¡åœ¨äº†35ç‚¹ã€‚æœ€åå¿ƒæ€å‡ ä¹çˆ†ç‚¸ï¼ˆå†…å¿ƒOSï¼šè¿™å¯æ˜¯ä¸€é“æ°´é¢˜å•Šï¼‰ï¼ŒåŒæ ·ï¼ŒåŒç»„çš„å¤§ä½¬ä»¬ï¼Œä¹Ÿæ²¡å‘ç°æœ‰ä»€ä¹ˆé—®é¢˜ã€‚å°±è¿™æ ·çº ç»“ç€ï¼Œæœ€åå°†ä¸€ä¸ªåŒé‡åˆ¤å®šæ¢äº†æ–¹å‘çš„æ€ç»´çš„å¦ä¸€ç§åˆ¤å®šï¼Œäºæ˜¯ï¼Œç»ˆäºæ˜¯Aäº†â€¦â€¦æ­¤æ—¶æ—¶é—´å·²ç»åœ¨ä¸¤å°æ—¶ä¹‹åäº†ï¼ˆæ¯”èµ›åŠç¨‹åˆšè¿‡ï¼‰ã€‚å†…å¿ƒç«æ€¥ç«ç‡å¾—ï¼Œä¹Ÿä¸çŸ¥æ€çš„å…¶ä»–ä¸¤ä½å¤§ä½¬ï¼Œç«Ÿç„¶å¼€å§‹æ¢é¡ºåºåšï¼ŒåŠå°æ—¶è¿‡å»ï¼ŒVHOSï¼ˆå¤ªå¼ºäº†ï¼‰ç«Ÿç„¶å®Œæˆäº†Gç»„é¢˜ï¼Œç„¶è€Œä¸å¹¸çš„æ˜¯ä¸èƒ½æäº¤ï¼ˆè¾£é¸¡æ—¥æœ¬Vjudgeï¼‰ã€‚è¿™åˆæ˜¯å¯¹æˆ‘ä»¬å¿ƒæ€çš„è€ƒéªŒï¼Œäºæ­¤åŒæ—¶åŠæ•°ä»¥ä¸Šçš„ç»„æ—©å·²ç»å®Œæˆäº†3é“äº†ï¼Œæˆ‘ä»¬çš„æ’åä½ç½®å‡ ä¹å·²ç»å¯ä»¥çœ‹åˆ°æ¦œåº•äº†ã€‚ç»ˆäºåœ¨æœ€åçš„ç¬¬ä¸‰ä¸ªå°æ—¶â€”â€”â€”â€”å¥‡è¿¹ç«Ÿç„¶å‡ºç°äº†ï¼ä¸‰å°æ—¶ååˆ†é’Ÿï¼Cé¢˜ï¼ï¼ACï¼ï¼ä¸‰å°æ—¶ä¸‰ååˆ†ï¼Gé¢˜ï¼ï¼ACï¼ï¼æ­¤æ—¶æˆ‘ä»¬çš„æ’åå·²ç»æŒ¤åˆ°äº†å‰åï¼Œ4é“ACï¼Œæœ€å¤šçš„å¤§ç¥ç»„æ—©å®Œæˆäº†5é¢˜ï¼Œæˆ‘å¿ƒæœ‰ä¸ç”˜ï¼Œç»§ç»­å¥‹æˆ˜ï¼Œæ­¤æ—¶åªå‰©å”¯æˆ‘ä¸€äººå¥‹ç¬”ç–¾ä¹¦â€¦â€¦å‘¨å›´çš„äººæ—©å·²æ‡ˆæ€ ï¼Œä¸ï¼Œè¿˜ä¸èƒ½é‚£ä¹ˆæ—©ã€‚åŠªåŠ›çš„æƒ³ç€Dé¢˜ï¼Œdpæ–¹ç¨‹å´æ­»ä¹Ÿæ¨ä¸å‡ºæ¥ï¼Œæœ€ååäº”åˆ†é’Ÿâ€¦â€¦ï¼ï¼ï¼å“¦ï¼ï¼ï¼çªç„¶æœ‰äº†æƒ³æ³•ï¼Œå¤ºè¿‡é”®ç›˜ï¼Œæœ€å13åˆ†é’Ÿï¼ï¼ï¼æˆ‘çŸ¥é“è¿™æ¬¡æˆ‘æ²¡æœ‰è°ƒè¯•çš„æ—¶é—´äº†ï¼Œåªèƒ½è¦æ±‚è‡ªå·±ä¸€éè¿‡ï¼Œæ¯ä¸ªå­—éƒ½æ•²å¾—å°å¿ƒç¿¼ç¿¼ï¼ŒåŒæ—¶åˆå¾—åŠ å¿«é€Ÿåº¦â€¦â€¦â€¦â€¦3minï¼2minï¼ï¼æ•²å®Œäº†ï¼ï¼ï¼æ ·ä¾‹ä¸€è¿‡ï¼Œç›´æ¥æäº¤ï¼Œä¸æ•¢æµªè´¹æ¯ä¸€åˆ†é’Ÿï¼ï¼ï¼ç«Ÿç„¶æˆåŠŸACäº†ï¼ï¼ï¼ï¼ï¼åŒç»„çš„å¤§ä½¬é«˜å…´çš„æ¬¢å‘¼ï¼ï¼æˆ‘åšåˆ°äº†ï¼ï¼ï¼å½“è‡ªå·±å¹³é™ä¸‹æ¥æ—¶ï¼Œæˆ‘æ‰å‘ç°è‡ªå·±çš„èº«ä½“ä¸€ç›´åœ¨é¢¤æŠ–ï¼Œå¿ƒè·³ååˆ†çš„å¿«ã€‚æœ€åæˆ‘ä»¬è™½ç„¶ç½šæ—¶å¾ˆä¹…ï¼Œä½†æ˜¯æœ€ç»ˆä¹Ÿä»¥å”¯ä¸€AC 6é“çš„å¥½æˆç»©ä½å±…äº†æ¦œé¦–ï¼Œååˆ†ä¸æ˜“å•Šï¼ï¼ ï¼ˆP.S:æœ€åä»å²³ç¥å’Œåˆ˜å¤§ä½¬çš„é’±åŒ…é‡ŒæˆåŠŸå‘åˆ°ä¸€é¡¿KFCï¼‰o(â—Ë‡âˆ€Ë‡â—)o ä¸‹é¢æ˜¯å¯¹è¿™å‡ å¤©æ‰€å­¦å†…å®¹çš„æ€»ç»“ï¼Œé€æ¡æšä¸¾ï¼šï¼ˆå…¶å®å¾ˆå¤šå£èƒ¡ä¸€æ³¢ï¼Œå¹¶ä¸èƒ½ä¸Šæ‰‹å½“åœºç é¢˜ï¼‰ 1ã€$KMP$ ï¼ˆä¿—ç§°â€œçœ‹*ç‰‡ç®—æ³•â€ï¼‰ ï¼ˆä¸€%é£ç¥ï¼‰è¿™æ˜¯ç”±ä¸‰ä½å¤§ç¥åŒæ—¶å‘ç°çš„ä¸€ç§æ”¹è¿›å­—ç¬¦ä¸²åŒ¹é…çš„ç®—æ³•ï¼ˆ%%%ï¼‰ï¼Œ$KMP$ç®—æ³•çš„å…³é”®æ˜¯åˆ©ç”¨åŒ¹é…å¤±è´¥åçš„ä¿¡æ¯ï¼Œå°½é‡å‡å°‘æ¨¡å¼ä¸²ä¸ä¸»ä¸²çš„åŒ¹é…æ¬¡æ•°ä»¥è¾¾åˆ°å¿«é€ŸåŒ¹é…çš„ç›®çš„ã€‚å…·ä½“å®ç°å°±æ˜¯å®ç°ä¸€ä¸ª$next()$å‡½æ•°ï¼Œå‡½æ•°æœ¬èº«åŒ…å«äº†æ¨¡å¼ä¸²çš„å±€éƒ¨åŒ¹é…ä¿¡æ¯ã€‚ï¼ˆå¼ºè¡Œè§£é‡Šä¸€æ³¢å¤±é…å‡½æ•°ï¼‰ä¸Šæ³¢ä»£ç ï¼š 1234567891011121314151617181920int KMP(string W,string T)&#123; int i=1,j=1; while(i&lt;=n)&#123; while (j!=0&amp;&amp;W[j]!=T[i]) j=next[j]; if(j==m) return i-m+1;//åŒ¹é…æˆåŠŸï¼Œè¿”å›åŒ¹é…ä½ç½®s else&#123;j++; i++;&#125; &#125; return -1;//åŒ¹é…å¤±è´¥&#125;void GetNext(charT[],intnext[])&#123; next[1]=0; j=1;k=0; while(j&lt;T[0]) if((k==0)||(T[j]==T[k]))&#123; j++; k++; next[j]=k; &#125; else k=next[k];&#125; ï¼ˆå…¶å®å¹¶ä¸å¤ªæ¸…æ¥šå®ƒåˆ°åº•å…·ä½“æœ‰ä»€ä¹ˆç”¨ï¼‰=v= 2ã€æ•°è®ºã€å®šç† ï¼ˆä¸€å †å¥‡å¥‡æ€ªæ€ªçš„ä¸œè¥¿ï¼‰ï¼ˆè¾¹æ‰“è¾¹å¤ä¹ ï¼‰é¦–å…ˆä¸Šåœºçš„æ˜¯å”¯ä¸€åˆ†è§£å’Œ$lcm$ã€$gcd$ï¼ˆè¿™è´§è´¼é‡è¦ï¼‰ï¼Œç”±æ­¤å¼•ç”³çš„æ˜¯æ¬§å‡ é‡Œå¾—å’Œæ‰©å±•æ¬§ã€‚ //å¨å°”é€Šå®šç†//ï¼šå®ƒç»™å‡ºäº†åˆ¤å®šä¸€ä¸ªè‡ªç„¶æ•°æ˜¯å¦ä¸ºç´ æ•°çš„å……åˆ†å¿…è¦æ¡ä»¶ï¼Œå°±æ˜¯å½“ä¸”ä»…å½“$p$ä¸ºç´ æ•°æ—¶ï¼š$(p-1)!â‰¡-1(mod p)$ï¼Œä½†æ˜¯ç”±äºé˜¶ä¹˜æ˜¯å¢é•¿çš„é€Ÿåº¦å®åœ¨æ˜¯â€¦â€¦â€¦â€¦ï¼ˆæ‰€ä»¥ç»“è®ºå¯¹äºå®é™…æ“ä½œæ„ä¹‰ä¸å¤§ï¼Œæ„Ÿè§‰è¯´äº†åºŸè¯ï¼‰ //å°è´¹é©¬//ï¼šå‡å¦‚$p$æ˜¯è´¨æ•°ï¼Œä¸”$gcd(a,p)=1$ï¼Œé‚£ä¹ˆ$a(p-1)â‰¡1(mod\ p)$ï¼ˆå¼ºåˆ¶ä½¿ç”¨äº†ä¸€æ³¢$gcd$ï¼‰ï¼ˆå…¶ä¸­$gcd$ä¸º$1$ä»£è¡¨äº’è´¨ï¼‰ï¼ˆç»“æœè¯æ˜å‡ºæ¥äº†ï¼‰ï¼ˆè¯¥åŒä½™å¼å¯ä»¥è½¬ä¸º$apâ‰¡p(mod\ p)$ï¼Œä¸çŸ¥é“å†™çš„å¯¹ä¸å¯¹ï¼Œå¥½åƒæåˆ°è¿‡ï¼‰ //æ¬§æ‹‰å‡½æ•°ä¸å®šç†//ï¼šemmmï¼Œè¿™ç©æ„æˆ‘å®åœ¨ä¸æ˜¯å¾ˆæ‡‚,è®¤è¯†äº†ä¸€ä¸‹$Ï†$ï¼Œè¿˜æœ‰æ¬§æ‹‰å®šç†ï¼šè‹¥$gcd(a,p)=1$ï¼Œåˆ™$a^{Ï†(p)}â‰¡1(mod\ p)$ã€‚ //å…³äºè¿™äº›å®šç†çš„ä¾‹é¢˜ä½¿ç”¨//ï¼šä¸å¤ªç†Ÿç»ƒï¼Œä¸çŒ®ä¸‘=w=ï¼Œå­¦ä¹ å¤§ç¥ä»¬çš„å†™æ³•ï¼Œè´¹åŠ›çš„ç†è§£å•Šå•Šå•Šâ€¦â€¦â€¦â€¦ 3ã€$manacher$ ï¼ˆäºŒ%é£ç¥ï¼‰è¿™ä¸ªå’Œ$KMP$ä¸€æ ·ï¼Œæ˜¯å…³äºå­—ç¬¦ä¸²çš„ä¸€ç§ç®—æ³•ï¼Œä¸»è¦é’ˆå¯¹å›æ–‡ä¸²ã€‚ä»¥$Oï¼ˆnï¼‰$çš„æ—¶é—´å¤æ‚åº¦ä»¥æ¯ä¸ªå­—ç¬¦ä¸ºä¸­å¿ƒï¼Œä»¥å›æ–‡ä¸²å•ç¨‹é•¿åº¦ï¼Œå°†æ‰€å–å­—ç¬¦ä¸²æ‰©å±•ä¸€å€ã€‚å¦‚æœæ˜¯å¥‡æ•°ä¸²å°±èƒ½é¡ºåˆ©è¿›è¡Œï¼Œå¦‚æœå¶æ•°ä¸²ï¼Œé‚£å¿…é¡»æ’å…¥å¥‡æ€ªçš„å­—ç¬¦ã€‚ä½†è¿™ç§ç®—æ³•çš„ç¥å¥‡ä¹‹å¤„åœ¨äºå¯ä»¥åŒæ—¶è€ƒè™‘å¥‡ä¸²å’Œå¶ä¸²ã€‚ï¼ˆä½†ä¸èƒ½æ‹†ååŸå­—ç¬¦ä¸²ï¼‰ï¼ˆä»£ç å¥½é•¿ï¼Œæˆ‘å†³å®šä¸å‡‘å­—æ•°ï¼‰(ï¿£â–½ï¿£)â€ 4ã€çŠ¶å‹$DP$å¥½å§ï¼Œæˆ‘æ‰¿è®¤ä½è¿ç®—æˆ‘å®åœ¨æ˜¯çƒ‚é€äº†ï¼Œå®Œå…¨æ²¡è®°ä½ï¼Œå·®ç‚¹å¬æˆå¤§å¼±æ™ºâ•®(â•¯-â•°)â•­ ã€‚è¡¨ç¤ºçŠ¶å‹åˆ—ä¸¾çš„å­é›†æ—¢èƒ½å®Œå…¨æšä¸¾ï¼Œè¿˜èƒ½èŠ‚çº¦ä¸å¿…è¦åˆ—ä¸¾çš„æ—¶é—´â€¦â€¦ï¼ˆæ¥è‡ªèŒæ–°çš„ç¥å¥‡(âŠ™oâŠ™)ï¼‰ 5ã€æ ‘çš„$LCA$ ï¼ˆæ±‚æ ‘ä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯ï¼‰å…ˆä»æ ‘çš„$dfs$åºå…¥æ‰‹ï¼Œå±•å¼€å€å¢ï¼ˆçœ‹å¾—æ‡‚ï¼Œè¡¨ç¤ºä¸ä¼šå†™â€¦â€¦ï¼‰ï¼Œ$tarjan$ï¼ˆç«Ÿç„¶åŸºäºå†°èŒ¶å‡ ï¼ˆå¹¶æŸ¥é›†ï¼‰ï¼ï¼ï¼‰ï¼Œ$RMQ$ï¼Œ$emmm$ï¼ˆå›å»é‡æ–°å­¦ä¹ è¿é€šåˆ†é‡ï¼‰ã€‚ï¼ˆä¸å¥½éšä¾¿å£èƒ¡=-=ï¼Œå†³å®šç¿»å·¥å­¦ä¹ ï¼‰ 6ã€å·®åˆ† ï¼ˆä¸€èµ·è®²äº†å·®åˆ†çº¦æŸå§ï¼‰å·®åˆ†æ‰€æ“…é•¿åšçš„å°±æ˜¯æŠŠ$a$æ•°ç»„ä¸­$l~r$èŒƒå›´å†…çš„æ•°åŠ ä¸Šæˆ–å‡å»æŸä¸ª$k$å€¼ï¼Œè¿™æ ·åªè¦æ±‚å‰ç¼€å’Œï¼Œè¿ç”¨å·®åˆ†å°±åªè¦æ±‚å‰ç¼€å’Œï¼Œå°±èƒ½åœ¨$Oï¼ˆnï¼‰$çš„æ—¶é—´å†…å¾—åˆ°æ•´ä¸ªæ•°ç»„çš„å€¼ã€‚å·®åˆ†çº¦æŸå˜›ï¼Œæ˜¯åŸºäºå›¾è®ºçŸ¥è¯†$SPFA$å’Œåˆ¤ç¯çš„ï¼Œæ¯”å¦‚æˆ‘ä»¬å¾—åˆ°$a[x]]]></content>
      <categories>
        <category>5/6æœˆé›†è®­</category>
      </categories>
      <tags>
        <tag>Total Review</tag>
      </tags>
  </entry>
</search>
