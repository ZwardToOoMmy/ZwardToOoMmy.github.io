<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[蒟蒻⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄报道 (置顶)(置顶)]]></title>
    <url>%2F2099%2F12%2F31%2F%E8%92%9F%E8%92%BB%E6%8A%A5%E9%81%93%2F</url>
    <content type="text"><![CDATA[这篇文章的出现，预示着时隔多年，我的博客终于要启用啦！撒花花]]></content>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#242 E.XOR on Segment]]></title>
    <url>%2F2019%2F02%2F15%2FCodeForces-242-E-XOR-on-Segment%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[究极的最大流算法ISAP与HLPPHLPP——钱逸凡]]></title>
    <url>%2F2019%2F02%2F15%2F%E7%A9%B6%E6%9E%81%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AE%97%E6%B3%95ISAP%E4%B8%8EHLPPHLPP__%E9%92%B1%E9%80%B8%E5%87%A1%2F</url>
    <content type="text"><![CDATA[本文搬运自洛谷大佬钱逸凡的博客 究级的最大流算法：ISAP与HLPP最大流的定义及基础解法这里就不再赘述了 有需要的可以看之前写的劣质文章EK与Dinic求解最大流的方法了 前言最大流算法目前有增广路算法和预流推进算法两种，增广路算法的思想是不断地寻找增广路来增大最大流，而预流推进算法的思想是……后面再讲。 先从最熟悉的增广路算法开始讲。 ISAP(Improved Shortest Augumenting Path）：其实Dinic已经足够高效了，但那些（闲着没事干）的计算机科学家们对Dinic的效率仍不满足，于是就有了ISAP算法。 在Dinic中我们每次增广前都进行了一次bfs来初始化每个点的深度，虽然一次标号增广了很多条路，但是我们还是很有可能要跑很多遍bfs导致效率不高。 那有没有什么办法只跑一次bfs呢?那就是ISAP算法了！ISAP运行过程：1.从t到s跑一遍bfs，标记深度（为什么是从t到s呢？后面会讲） 2.从s到t跑dfs，和Dinic类似，只是当一个点跑完后，如果从上一个点传过来的flow比该点的used大（对于该点当前的深度来说，该点在该点以后的路上已经废了），则把它的深度加1，如果出现断层（某个深度没有点），结束算法 3.如果操作2没有结束算法，重复操作2 好抽象啊。什么原理呢？ ISAP其实与Dinic差不多，但是它只跑一遍bfs，但是每个点的层数随着dfs的进行而不断提高（这样就不用反复跑bfs重新分层了），当s的深度大于n时（这就是为什么bfs要从t到s），结束算法。 先给一些数组定义： 12int dep[13000],gap[13000];//dep[i]表示节点i的深度，gap[i]表示深度为i的点的数量 bfs部分: 1234567891011121314151617181920void bfs()&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); dep[t]=0; gap[0]=1;// queue&lt;int&gt;q; q.push(t); while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=node[i].next)&#123; int v=node[i].v; if(dep[v]!=-1)continue;//防止重复改某个点 q.push(v); dep[v]=dep[u]+1; gap[dep[v]]++; &#125; &#125; return;&#125;//初始化bfs，从t到s搜出每个点初始深度 可以看出ISAP里的bfs对 边权!=0 这一条件并没有限制，只要在后面的dfs里判断边权就好了。 接下来是dfs： 1234567891011121314151617181920212223242526272829int dfs(int u,int flow)&#123; if(u==t)&#123;//可以到达t maxflow+=flow; return flow; &#125; int used=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;dep[d]+1==dep[u])&#123; int mi=dfs(d,min(node[i].val,flow-used)); if(mi)&#123; node[i].val-=mi; node[i^1].val+=mi; used+=mi; &#125; if(used==flow)return used; &#125; &#125; //前半段和Dinic一模一样 //如果已经到了这里，说明该点出去的所有点都已经流过了 //并且从前面点传过来的流量还有剩余 //则此时，要对该点更改dep //使得该点与该点出去的点分隔开 --gap[dep[u]]; if(gap[dep[u]]==0)dep[s]=n+1;//出现断层，无法到达t了 dep[u]++;//层++ gap[dep[u]]++;//层数对应个数++ return used; &#125; 感觉和Dinic差不多。 只是多几句话来统计深度对应的点数。 这里要解释一下为什么要统计每个深度的节点数：为了优化！统计每个深度对应点数只为了这句话： 1if(gap[dep[u]]==0)dep[s]=n+1; 因为我们是按照深度来往前走的，路径上的点的深度一定是连续的，而t的深度为0，如果某个深度的点不存在，那么我们就无法到达t了此时直接结束算法可以大大节省时间。 接下来是主函数： 123456int ISAP()&#123; maxflow=0; bfs(); while(dep[s]&lt;n)dfs(s,inf); return maxflow;&#125; 由于dfs部分（有点）相当抽象，可以结合图示理解。以下图为例：（反向边没有画，但是有反向边） 先 bfs 分层：（蓝色字体表示层数） 按照深度，我们只能走S-&gt;1-&gt;5-&gt;6-&gt;t这条增广路，流量为3 在dfs过程中，从5传到6时$flow==4$而在6号点的$used==3$，所以此时不会直接返回（见上方的代码），而是把6号点的深度加1，同理s,1,5的也要加1，也就是说，跑了这条增广路后，图变成了： 看见了吗？s-&gt;1-&gt;5-&gt;6-&gt;t这条路被封了，但是s-&gt;1-&gt;2-&gt;3-&gt;4-&gt;t这条路却能走了 按照深度，这次肯定是走s-&gt;1-&gt;2-&gt;3-&gt;4-&gt;t这条路。 这次的情况和上次不同，由于从2传到3时的flow==3而之后的路径的used都是3，所以2,3,4号点的深度不会改变，而1,s的情况与上次的那些点相同，深度会改变。 跑了这条路之后，图变成了： 图中出现了断层（深度为4的点没有了），所以一定不存在增广路了，可以直接结束算法了。 刚才那张图如果用Dinic会怎么样？三遍bfs，两遍dfs！与之相比，ISAP真是太高效了！这里顺便说一下为什么终止条件是dep[s]&lt;n 从上面的过程可以看出：每走一遍增广路，s的层数就会加1，如果一直没有出现断层，最多跑n-dep（刚bfs完时s的深度）条增广路（因为一共就n个点） 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int inf=1&lt;&lt;30;int cnt=1,head[13000];int n,m,s,t;inline int Read()&#123; int x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;struct Node&#123; int v; int next; int val;&#125;node[250000];inline void addedge(int u,int v,int val)&#123; node[++cnt].v=v; node[cnt].val=val; node[cnt].next=head[u]; head[u]=cnt;&#125;int dep[13000],gap[13000];void bfs()&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); dep[t]=0; gap[0]=1; queue&lt;int&gt;q; q.push(t); while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=node[i].next)&#123; int v=node[i].v; if(dep[v]!=-1)continue; q.push(v); dep[v]=dep[u]+1; gap[dep[v]]++; &#125; &#125; return;&#125;int maxflow;int dfs(int u,int flow)&#123; if(u==t)&#123; maxflow+=flow; return flow; &#125; int used=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;dep[d]+1==dep[u])&#123; int mi=dfs(d,min(node[i].val,flow-used)); if(mi)&#123; node[i].val-=mi; node[i^1].val+=mi; used+=mi; &#125; if(used==flow)return used; &#125; &#125; --gap[dep[u]]; if(gap[dep[u]]==0)dep[s]=n+1; dep[u]++; gap[dep[u]]++; return used; &#125;int ISAP()&#123; maxflow=0; bfs(); while(dep[s]&lt;n)dfs(s,inf); return maxflow;&#125;int main()&#123; int i=1; n=Read(),m=Read(),s=Read(),t=Read(); int u,v,w; for(i=1;i&lt;=m;i++)u=Read(),v=Read(),w=Read(),addedge(u,v,w),addedge(v,u,0); printf("%d",ISAP()); return 0;&#125; 当然，这东西也可以当前弧优化（原理见 Dinic ）只需要改一点即可： 1234while(dep[s]&lt;n)&#123; memcpy(cur,head,sizeof(head)); dfs(s,inf); &#125; dfs部分的修改就不放代码了，应该都会。 接下来就是相当抽象的预流推进算法了 在讲解算法之前，我们先来回顾一下最大流是干嘛的： 水流从一个源点s通过很多路径，经过很多点，到达汇点t，问你最多能有多少水能够到达t点。 在刚面对这个问题时，你或许会有这样的思路： 先从s往相邻点拼命灌水，然后让水不停地向t流，能流多少是多少。 这就是预流推进：能推流，就推流，最终t有多少水，最大流就是多少。 预流推进算法的思想：在讲思想之前，先引入一个概念： 余流： 听名字就知道是什么意思了，即每个点当前有多少水。 预留推进算法的思想是： 1.先假装s有无限多的水(余流)，从s向周围点推流（把该点的余流推给周围点，注意：推的流量不能超过边的容量也不能超过该点余流），并让周围点入队（ 注意：s和t不能入队 ） 2.不断地取队首元素，对队首元素推流 3.队列为空时结束算法，t点的余流即为最大流。 上述思路是不是看起来很简单，也感觉是完全正确的？ 但是这个思路有一个问题，就是可能会出现两个点不停地来回推流的情况，一直推到TLE。 怎么解决这个问题呢？ 给每个点一个高度，水只会从高处往低处流。在算法运行时， 不断地对有余流的点更改高度 ，直到这些点全部没有余流为止。 为什么这样就不会出现来回推流的情况了呢？ 当两个点开始来回推流时，它们的高度会不断上升，当它们的高度大于s时，会把余流还给s。 所以在开始预流推进前要先把s的高度改为n（点数），免得一开始s周围那些点就急着把余流还给s。 先用图解来表示算法的运行过程：以下图为例（反向边没画出来） 我们用深蓝色的字表示每个点的余流，用淡蓝色的字表示每个点的高度。 刚开始肯定是： 我们把s点的高度改成6（一共6个点） 然后从往s拼命地灌水，水流会顺着还没满的边向周围的节点流 此时1,3节点还有余流，于是更新1,3号点高度，更新为与它相邻且最低的点的高度+1。 此时我们对1号节点推流。 更新有余流的1,2号节点的高度 为什么1的高度变成了7呢？因为1与s有反向边，因为刚才推过流，反向边有了边权，与1连通的最低的点就是s。 然后是对3节点推流（更新高度是同时进行的只是刚才为了便于理解而分开画了） 然后是2号点推流，注意t点不能更新高度（否则好不容易流过去的水就会往回流了） 4号点推流 2号点推流 3号点推流 除了s和t以外，所有节点都无余流，算法结束，最大流就是t的余流。 完整代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// luogu-judger-enable-o2//效率相当低，吸氧气都过不了模板#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int inf=1&lt;&lt;30;;int n,m,s,t;struct Node&#123; int v; int val; int next;&#125;node[205202];int top=1;int inque[13000];int head[13000];int h[13000];int e[13000];//每个点的高度，每个点的剩余（多余）流量inline int Read()&#123; int x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;//读入优化 inline int min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline void addedge(int u,int v,int val)&#123; node[++top].v=v; node[top].val=val; node[top].next=head[u]; head[u]=top;&#125;inline void add(int u,int v,int val)&#123; addedge(u,v,val); addedge(v,u,0);&#125;int maxflow;inline void push_(int u,int i)&#123; int mi=min(e[u],node[i].val); node[i].val-=mi; node[i^1].val+=mi; e[u]-=mi; e[node[i].v]+=mi;&#125;//从u到v推流,i为u与v相连的那一条边的编号 inline bool relabel(int u)&#123; int mh=inf; register int i; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val)&#123; mh=min(mh,h[d]); &#125; &#125; if(mh==inf)return 0;//无可以流的路径 h[u]=mh+1;//把u点拉到可流点以上（使水流能从u流向周围的点） return 1; &#125;//判断点u是否能流向周围点int push_relabel()&#123; queue&lt;int&gt;q; h[s]=n;//把源点的高度设成n（图中的点数） for(register int i=head[s];i;i=node[i].next)&#123; int d=node[i].v; int val=node[i].val; if(val)&#123; node[i].val-=val; node[i^1].val+=val; e[s]-=val; e[d]+=val; if(inque[d]==0&amp;&amp;d!=t&amp;&amp;d!=s&amp;&amp;relabel(d))&#123; q.push(d); inque[d]=1; &#125; &#125;//给所有与s相连的点推入满流 &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); inque[u]=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(e[u]==0)break; if(node[i].val==0)continue; if(h[u]==h[d]+1) push_(u,i); if(e[d]!=0&amp;&amp;d!=t&amp;&amp;d!=s)&#123; if(inque[d]==0&amp;&amp;relabel(d))&#123; q.push(d); inque[d]=1; &#125; &#125; &#125; if(e[u]&amp;&amp;inque[u]==0&amp;&amp;relabel(u))&#123; q.push(u); inque[u]=1; &#125; &#125; return e[t];&#125;//push_relabelint main()&#123; n=Read(),m=Read(),s=Read(),t=Read(); register int i; int u,v,val; for(i=1;i&lt;=m;i++)u=Read(),v=Read(),val=Read(),add(u,v,val); printf("%d",push_relabel()); return 0;&#125; 这个预流推进算法相当慢，至于P4722 【模板】最大流 加强版 / 预流推进（毒瘤题）更没希望。 那为什么这么慢，我们还要学呢？ 为了下面的讲解做铺垫。 最高标号预流推进（HLPP）算法步骤： 1.先从t到s反向bfs，使每个点有一个初始高度 2.从s开始向外推流，将有余流的点放入优先队列 3.不断从优先队列里取出高度最高的点进行推流操作 4.若推完还有余流，更新高度标号，重新放入优先队列 5.当优先队列为空时结束算法，最大流即为t的余流 与基础的余流推进相比的优势： 通过bfs预先处理了高度标号，并利用优先队列（闲着没事可以手写堆）使得每次推流都是高度最高的顶点，以此减少推流的次数和重标号的次数。 优化： 和ISAP一样的gap优化，如果某个高度不存在，将所有比该高度高的节点标记为不可到达（使它的高度为n+1，这样就会直接向s推流了）。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;inline int Read()&#123; int x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;const int inf=1&lt;&lt;30;int top=1,head[10100];int n,m,s,t;int e[10100],h[10100],cnth[20100];//每个点对应的余流，高度；每个高度有多少个点 struct cmp&#123; inline bool operator () (int a,int b) const&#123; return h[a]&lt;h[b]; &#125;&#125;;struct Node&#123; int v; int val; int next;&#125;node[400100];inline void addedge(int u,int v,int val)&#123; node[++top].v=v; node[top].val=val; node[top].next=head[u]; head[u]=top;&#125;inline void add(int u,int v,int val)&#123; addedge(u,v,val); addedge(v,u,0);&#125;int inque[11000];void bfs()&#123; memset(h,0x3f,sizeof(h)); h[t]=0; queue&lt;int&gt;qu; qu.push(t); while(!qu.empty())&#123; int u=qu.front(); qu.pop(); inque[u]=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i^1].val&amp;&amp;h[d]&gt;h[u]+1)&#123;//反向跑 h[d]=h[u]+1; if(inque[d]==0)&#123; qu.push(d); inque[d]=1; &#125; &#125; &#125; &#125; return;&#125;priority_queue&lt;int,vector&lt;int&gt;,cmp&gt;q;inline void push_(int u)&#123; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;h[d]+1==h[u])&#123;//可以推流 int mi=min(node[i].val,e[u]); node[i].val-=mi; node[i^1].val+=mi; e[u]-=mi; e[d]+=mi; if(inque[d]==0&amp;&amp;d!=t&amp;&amp;d!=s)&#123; q.push(d); inque[d]=1; &#125; if(e[u]==0)break;//已经推完了 &#125; &#125;&#125;//推流 inline void relabel(int u)&#123; h[u]=inf; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;h[d]+1&lt;h[u])&#123; h[u]=h[d]+1; &#125; &#125;&#125;//把u的高度更改为与u相邻的最低的点的高度加1 int hlpp()&#123; register int i; bfs(); if(h[s]==0x3f3f3f3f)return 0;//s与t不连通 h[s]=n; for(i=1;i&lt;=n;i++)if(h[i]&lt;0x3f3f3f3f)cnth[h[i]]++;//统计各个高度的点数，注意不要让下标越界 for(i=head[s];i;i=node[i].next)&#123; int d=node[i].v; int mi=node[i].val; if(mi)&#123; e[s]-=mi; e[d]+=mi; node[i].val-=mi; node[i^1].val+=mi; if(d!=t&amp;&amp;inque[d]==0&amp;&amp;d!=s)&#123; q.push(d); inque[d]=1; &#125; &#125; &#125;//从s向周围点推流 while(!q.empty())&#123; int u=q.top(); inque[u]=0; q.pop(); push_(u); if(e[u])&#123;//还有余流 cnth[h[u]]--; if(cnth[h[u]]==0)&#123; for(int i=1;i&lt;=n;i++)&#123; if(i!=s&amp;&amp;i!=t&amp;&amp;h[i]&gt;h[u]&amp;&amp;h[i]&lt;n+1)&#123; h[i]=n+1;//标记无法到达 &#125; &#125; &#125;//gap优化 relabel(u); cnth[h[u]]++; q.push(u); inque[u]=1; &#125; &#125; return e[t];&#125; int main()&#123; n=Read(),m=Read(),s=Read(),t=Read(); register int i; int u,v,val; for(i=1;i&lt;=m;i++)u=Read(),v=Read(),val=Read(),add(u,v,val); printf("%d",hlpp()); return 0;&#125; 这次终于可以过掉那道毒瘤题了。 总结：ISAP的时间复杂度为O(n^2m),而HLPP的时间复杂度O(n^2sqrt(m)),但由于HLPP常数过大，在纯随机数据（模板题）下跑得还没有ISAP快，一般来说，用ISAP就够了。 最后感谢钱逸凡大佬的经验共享QWQ]]></content>
      <categories>
        <category>更多优秀的算法</category>
      </categories>
      <tags>
        <tag>Magical Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Grand Contest#016 F.Games on DAG]]></title>
    <url>%2F2019%2F02%2F14%2FAtcoder-Grand-Contest-016-F-Games-on-DAG%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题G.Games on DAG题面There is a directed graph $G$ with $N$ vertices and $M$ edges. The vertices are numbered $1$ through $M$. Edge $i$ is directed from $x_i$ to $y_i$ holds. Alse, there are no multiple edges in $G$. Consider selecting a subset of the set of the $M$ edges in $G$, and removing these edges from $G$ to obtain another graph $G’$. There are $2^M$ different possible graphs as $G’$. Alice and Bob play against each other in the following game played on $G’$. First, place two pieces on vertices $1$ and $2$, one on each. Then, starting from Alice, Alice and Bob alternately perform the following operation: Select an edge $i$ such that there is a piece placed on vertex $x_i$, and move the piece to vertex $y_i$(if there are two pieces on vertex $x_i$, only move one). The two pieces are allowed to be placed on the same vertex. The player loses when he(or she) becomes unable to perform the operation. We assume that both players play optimally. Among the $2^M$ different possible graphs as $G’$, how many lead to Alice’s victory? Find the count modulo $10^9+7$.]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#254 C.DZY Loves Colors]]></title>
    <url>%2F2019%2F02%2F14%2FCodeForces-254-C-DZY-Loves-Colors%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题F.DZY Loves Colors题面$DZY$ loves colors, and he enjoys painting. On a colorful day, $DZY$ gets a colorful ribbon, which consists of $n$ units (they are numbered from $1$ to $n$ from left to right). The color of the $i$-th unit of the ribbon is $i$ at first. It is colorful enough, but we still consider that the colorfulness of each unit is $0​$ at first. $DZY$ loves painting, we know. He takes up a paintbrush with color $x$ and uses it to draw a line on the ribbon. In such a case some contiguous units are painted. Imagine that the color of unit $i$ currently is $y$. When it is painted by this paintbrush, the color of the unit becomes $x$, and the colorfulness of the unit increases by $|x - y|$. $DZY$ wants to perform $m$ operations, each operation can be one of the following: Paint all the units with numbers between $l$ and $r$ (both inclusive) with color $x$. Ask the sum of colorfulness of the units between $l$ and $r​$ (both inclusive). Can you help $DZY$? 简要翻译$DZY$喜欢色彩，他热爱绘画。 在一个多姿多彩的日子里，$DZY$得到了一个彩色的缎带，它由$N$个单元组成（从左到右从$1$到$n$编号）。色带的第$i$个单位的最初颜色是$i$。虽然颜色足够丰富，但我们仍然认为每个单元的颜色数量最初是$0$。 $DZY$热衷于绘画，我们知道。他拿起一把彩色$X$笔，用它在缎带上画一条线。在这种情况下，他就绘制了一段连续的单元。想象一下，单位$i$被涂之前颜色是$Y$。被涂之后时，单元的颜色变为$X$，令单位的颜色增加了 $∣X−Y∣$。 $DZY$想要执行$M$个操作，每个操作可以是下列操作之一： $1$、将区间 [$L,R$] 内单元绘制为颜色$X$。 $2$、询问 [$L,R$] 之间的单位颜色的总和（包括两者）。 你能帮助$DZY$吗？ Input第一行包含两个整数$n,m$。 下面$m$行中每一行以一个整数$type$开头，表示操作类型。 若$type=1$，那么该行接下来有3个整数$L,R,X$，描述操作$1$； 若$type=2$，那么该行接下来有2个整数$L,R$，描述操作$2$。 Output对于每个操作$2$，输出一行，包含着色数量之和。 Sample Input 13 31 1 2 41 2 3 52 1 3 Sample Output 18 Sample Input 23 41 1 3 42 1 12 2 22 3 3 Sample Output 23 2 1 Sample Input 310 61 1 5 31 2 7 91 10 10 111 3 8 121 1 10 32 1 10 Sample Output 3129 Hint$1\leq n,m,\leq 10^5$ $1\leq type\leq 2$ $1\leq l\leq r\leq n$，$1\leq x\leq 10^8$。 本题的题意非常的明了，一开始的$a[i]=i,b[i]=0$，使区间 $[l,r]$的$b[i]+=|x-a[i]|$，$a[i]=x$，并查询 $[l,r]$ 的$b[i]$和。 我们用一个线段树就可以很容易地维护他们了。 不多说，直接上代码吧。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N=500010;struct seg_tree&#123; long long lazy,s,flag;&#125;t[N&lt;&lt;2];int n,m;void build(int root,int l,int r)&#123; if(l==r) &#123; t[root].flag=l; return; &#125; int mid=l+r&gt;&gt;1; build(root&lt;&lt;1,l,mid); build(root&lt;&lt;1|1,mid+1,r); // pushup(root);&#125;long long query(int root,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) return t[root].s; int mid=l+r&gt;&gt;1; long long ans=0; if(ll&lt;=mid) ans+=query(root&lt;&lt;1,l,mid,ll,rr); if(rr&gt;mid) ans+=query(root&lt;&lt;1|1,mid+1,r,ll,rr); return ans+max(0,min(r,rr)-max(l,ll)+1)*t[root].lazy;&#125;void empty(int root,int l,int r,int s)&#123; if(t[root].flag) &#123; t[root].lazy+=abs(t[root].flag-s); t[root].s+=abs(t[root].flag-s)*(r-l+1); t[root].flag=0; return; &#125; if(l==r) return; int mid=l+r&gt;&gt;1; empty(root&lt;&lt;1,l,mid,s); empty(root&lt;&lt;1|1,mid+1,r,s); t[root].s=t[root&lt;&lt;1].s+t[root&lt;&lt;1|1].s+t[root].lazy*(r-l+1);&#125;void pushdown(int root)&#123; if(!t[root].flag) return; t[root&lt;&lt;1].flag=t[root&lt;&lt;1|1].flag=t[root].flag; t[root].flag=0;&#125;void change(int root,int l,int r,int ll,int rr,int s)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123; empty(root,l,r,s); t[root].flag=s; return; &#125; int mid=l+r&gt;&gt;1; pushdown(root); if(ll&lt;=mid) change(root&lt;&lt;1,l,mid,ll,rr,s); if(rr&gt;mid) change(root&lt;&lt;1|1,mid+1,r,ll,rr,s); t[root].s=t[root&lt;&lt;1].s+t[root&lt;&lt;1|1].s+t[root].lazy*(r-l+1);&#125;int main(int argc, char const *argv[])&#123; n=read(),m=read(); build(1,1,n); while(m--) &#123; int type=read(); if(type==1) &#123; int l=read(),r=read(),x=read(); change(1,1,n,l,r,x); &#125; else &#123; int l=read(),r=read(); printf("%lld\n",query(1,1,n,l,r)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#271 F.Ant Colony]]></title>
    <url>%2F2019%2F02%2F14%2FCodeForces-271-F-Ant-Colony%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题D.Ant Colony题面Mole is hungry again. He found one ant colony, consisting of $n$ ants, ordered in a row. Each ant $i$ ($1\leq i\leq n$) has a strength $s_i$. In order to make his dinner more interesting, Mole organizes a version of «Hunger Games» for the ants. He chooses two numbers $l$ and $r$ ($1\leq l\leq r\leq n$) and each pair of ants with indices between $l$ and $r$ (inclusively) will fight. When two ants $i$ and $j$ fight, ant $s_i$ gets one battle point only if $s_i$ divides $s_j$ (also, ant $j$ gets one battle point only if $s_j$ divides $s_i$). After all fights have been finished, Mole makes the ranking. An ant $i​$, with $v_i​$ battle points obtained, is going to be freed only if $v_i=r-l​$, or in other words only if it took a point in every fight it participated. After that, Mole eats the rest of the ants. Note that there can be many ants freed or even none. In order to choose the best sequence, Mole gives you $t$ segments $[l_i,r_i]$ and asks for each of them how many ants is he going to eat if those ants fight. 简要翻译给定一个长度为$𝑛$的序列，$𝑞$个询问。 每次给定区间$ 𝑙,𝑟 $，将$ 𝑙,𝑟 $中所有数两两比较。 如果$𝑎,𝑏 ∈ 𝑙,𝑟 $，$𝑎|𝑏$则$𝑎$得一分，$𝑏|𝑎$则$𝑏$得一分。 问有多少个数没有得到满分。 Input第一行包含一个整数$n$，代表序列的大小。 第二行包含$n$个整数，$s_1,s_2,s_3…s_n$，代表序列的值。 第三行包含一个整数$t$，代表询问个数。 下面有$t$行，每行包含两个整数$l_i,r_i$描述一个询问。 Output输出包含$t$行。 第$i$行输出一个数表示 $[l_i,r_i]$ 中的没有满分的数的个数。 Sample Input5 1 3 2 4 2 4 1 5 2 5 3 5 4 5 Sample Output4 4 1 1 Note || （本来想搬样例解释的，不过既然是题解那就算了吧） Hint$1\leq n\leq 10^5$，$1\leq s_i\leq 10^9$。 $1\leq t\leq 10^5$，$1\leq l_i\leq r_i\leq n$。 我们可以比较显然的知道，能留下的数一定是区间的最小$gcd$，于是我们就只要找区间内与区间最小$gcd$相等的数的个数。 区间最小$gcd$一定小于等于区间$min$，我们只要判断最小值是否是区间最小$gcd$，如果是，就可以求出最小值的个数，也就能求出答案了。 根据数据范围和要求维护的数据，我们尝试用线段树来维护。 分别维护$gcd$，区间$min$，以及区间$min$的个数。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N=100010;struct seg_tree&#123; int min,gcd,cnt;&#125;t[N&lt;&lt;2];int a[N];int n,m;int minA,gcdA,cntA;int gcd(int a,int b)&#123; return !b? a:gcd(b,a%b);&#125;void pushup(int root)&#123; t[root].min=min(t[root&lt;&lt;1].min,t[root&lt;&lt;1|1].min); t[root].gcd=gcd(t[root&lt;&lt;1].gcd,t[root&lt;&lt;1|1].gcd); if(t[root&lt;&lt;1].min==t[root&lt;&lt;1|1].min) t[root].cnt=t[root&lt;&lt;1].cnt+t[root&lt;&lt;1|1].cnt; else if(t[root&lt;&lt;1].min&gt;t[root&lt;&lt;1|1].min) t[root].cnt=t[root&lt;&lt;1|1].cnt; else t[root].cnt=t[root&lt;&lt;1].cnt;&#125;void build(int root,int l,int r)&#123; if(l==r) &#123; t[root].min=t[root].gcd=a[l]; t[root].cnt=1; return; &#125; int mid=l+r&gt;&gt;1; build(root&lt;&lt;1,l,mid); build(root&lt;&lt;1|1,mid+1,r); pushup(root);&#125;void query(int root,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123; gcdA=gcd(gcdA,t[root].gcd); if(minA==t[root].min) cntA+=t[root].cnt; else if(minA&gt;t[root].min) cntA=t[root].cnt,minA=t[root].min; return; &#125; int mid=l+r&gt;&gt;1; if(ll&lt;=mid) query(root&lt;&lt;1,l,mid,ll,rr); if(rr&gt;mid) query(root&lt;&lt;1|1,mid+1,r,ll,rr);&#125;int main(int argc, char const *argv[])&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); build(1,1,n); // cout&lt;&lt;"YES"&lt;&lt;endl; m=read(); while(m--) &#123; int l=read(),r=read(); minA=1000000001; gcdA=cntA=0; query(1,1,n,l,r); if(gcdA==minA) printf("%d\n",r-l+1-cntA); else printf("%d\n",r-l+1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[image]]></title>
    <url>%2F2019%2F02%2F14%2Fimage%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Photo Collection</category>
      </categories>
      <tags>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚁群算法(Ant Colony)]]></title>
    <url>%2F2019%2F02%2F14%2F%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天，我在网上翻到一个神奇的算法蚁群算法！某大佬的blog：https://blog.csdn.net/lyxleft/article/details/82980760 记得学哈~]]></content>
      <categories>
        <category>空闲时间的零碎知识</category>
      </categories>
      <tags>
        <tag>Magical Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1848 Fibonacci again and again]]></title>
    <url>%2F2019%2F02%2F13%2FHDU-1848-Fibonacci-again-and-again%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题#.Fibonacci again and again题面 任何一个大学生对菲波那契数列($Fibonacci numbers$)应该都不会陌生，它是这样定义的：$F(1)=1;$$F(2)=2;$$F(n)=F(n-1)+F(n-2)(n&gt;=3);$所以，$1,2,3,5,8,13$……就是菲波那契数列。在HDOJ上有不少相关的题目，比如$1005\ Fibonacci\ again\ and\ again$就是曾经的浙江省赛题。今天，又一个关于$Fibonacci$的题目出现了，它是一个小游戏，定义如下：1、 这是一个二人游戏;2、 一共有$3$堆石子，数量分别是$m, n, p$个；3、 两人轮流走;4、 每走一步可以选择任意一堆石子，然后取走$f$个；5、 $f$只能是菲波那契数列中的元素（即每次只能取$\ 1，2，3，5，8$…等数量）；6、 最先取光所有石子的人为胜者； 假设双方都使用最优策略，请判断先手的人会赢还是后手的人会赢。 Input输入数据包含多个测试用例，每个测试用例占一行，包含$3​$个整数$m,n,p​$。$m=n=p=0​$则表示输入结束。 Output 如果先手的人能赢，请输出“$Fibo$”，否则请输出“$Nacci$”，每个实例的输出占一行。 Sample Input1 1 1 1 4 1 0 0 0 Sample OutputFibo Nacci Hint$1\leq m,n,p\leq 1,000$ 来自$ACM\ Short\ Term\ Exam\ 2007/12/13$ (Html Address:http://acm.hdu.edu.cn/search.php?field=problem&amp;key=ACM+Short+Term+Exam_2007%2F12%2F13&amp;source=1&amp;searchmode=source) 这题啊！ 裸的SG函数呀！ 没学过的大佬们逛一波博客吧！ （maybe…几万年以后我也会写一篇的吧~） Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x=0,w=0; char ch=0; while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return w? -x:x;&#125;const int MAXN=1010;int f[MAXN],sg[MAXN];void Fibonacci()&#123; f[1]=1,f[2]=2; for(int i=3;i&lt;=200;++i) &#123; f[i]=f[i-1]+f[i-2]; if(f[i]&gt;1000) break; &#125;&#125;map&lt;int,int&gt; ma;void Build_Map(int lim)&#123; for(int i=1;i&lt;=lim;++i) &#123; ma.clear(); for(int j=1;f[j]&lt;=i;++j) ++ma[sg[i-f[j]]]; for(int j=0;j&lt;=lim;++j) if(!ma[j]) &#123; sg[i]=j; break; &#125; &#125;&#125;int a,b,c;int main()&#123; Fibonacci(); Build_Map(1000); while(1) &#123; a=read(),b=read(),c=read(); if(!a&amp;&amp;!b&amp;&amp;!c) return 0; int sum=0; sum^=sg[a]^sg[b]^sg[c]; if(!sum) puts("Nacci"); else puts("Fibo"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.13-Contest]]></title>
    <url>%2F2019%2F02%2F13%2F2-13-Contest%2F</url>
    <content type="text"><![CDATA[本蒟蒻较懒，想直接贴pdf的图片。 于是下载了一个转化器，结果最后一张还带了水印。 (能看就行)]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2640 Help Me Escape]]></title>
    <url>%2F2019%2F02%2F12%2FZOJ-2640-Help-Me-Excape%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题B.Help Me Escape背景If thou doest well, shalt thou not be accepted? and if thou doest not well, sin lieth at the door. And unto thee shall be his desire, and thou shalt rule over him. And Cain talked with Abel his brother: and it came to pass, when they were in the field, that Cain rose up against Abel his brother, and slew him. And the LORD said unto Cain, Where is Abel thy brother? And he said, I know not: Am I my brother’s keeper? And he said, What hast thou done? the voice of thy brother’s blood crieth unto me from the ground. And now art thou cursed from the earth, which hath opened her mouth to receive thy brother’s blood from thy hand; When thou tillest the ground, it shall not henceforth yield unto thee her strength; a fugitive and a vagabond shalt thou be in the earth. ​ $ —— Bible Chapter 4$ 题面 Now Cain is unexpectedly trapped in a cave with N paths. Due to LORD’s punishment, all the paths are zigzag and dangerous. The difficulty of the ith path is ci. Then we define f as the fighting capacity of Cain. Every day, Cain will be sent to one of the N paths randomly. Suppose Cain is in front of the ith path. He can successfully take ti days to escape from the cave as long as his fighting capacity f is larger than ci. Otherwise, he has to keep trying day after day. However, if Cain failed to escape, his fighting capacity would increase ci as the result of actual combat. (A kindly reminder: Cain will never died.) As for ti, we can easily draw a conclusion that ti is closely related to ci. Let’s use the following function to describe their relationship: t_i=\lfloor \frac{1+\sqrt 5}2×c_i^2\rfloor After D days, Cain finally escapes from the cave. Please output the expectation of D. 简要翻译有$n$个妖怪，每个妖怪有一个战斗力$c_j$。小A有一个初始战斗力$f_0$。 每天，小A随机选择一个妖怪决斗。设小A在第𝑖天的战斗力为$f_i$。 设当前为第$𝑖$天，如果打赢，即$𝑓_i &gt; 𝑐_j$，就可以逃出去，需要花$t_j$天。 如果打不赢，小A会让自己变强，$𝑓_{i+1} = 𝑓_i+ 𝑐_j$。 求小A逃出来需要的期望天数。 Input输入包含多组数据。 每组数据包括两行。第一行包含一个$n$和$f$，第二行包含$n$个整数$c_i$。 Output对于每组数据你要输出期望值，保留小数点后三位。 Sample Input3 1 1 2 3 Sample Output6.889 Hint$n\leq 100$，$f\leq 10,000$，$c_i\leq10,000，1\leq i\leq n$。 用$f(i)$表示战斗力为$i$时，所需要的期望天数。 那么有：若$i&gt;c_j$，则$f(i)=f(i)+\frac 1n(t_j)$； 若（$i\leq c_j$），则$f(i)=f(i)+\frac 1n(f(i+c_j)+1)$。 然后进行记忆化搜索。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;struct data&#123; int c, t;&#125;;bool vis[100010];vector&lt;data&gt; vs;int N, F;double dp[100010];double dfs(int f)&#123; if (vis[f]) return dp[f]; vis[f] = 1; double A = 0; for (int i = 0; i &lt; N; ++i) if (vs[i].c &gt;= f) A += (1 + dfs(f + vs[i].c)) / N; else A += 1.0 * vs[i].t / N; return dp[f] = A;&#125;int main()&#123; while (~scanf("%d%d", &amp;N, &amp;F)) &#123; vs.clear(); memset(vis, 0, sizeof(vis)); for (int i = 0, g; i &lt; N; ++i) &#123; g = read(); int p = (1 + sqrt(5)) / 2 * g * g; vs.push_back((data) &#123;g, p&#125;); &#125; printf("%.3lf\n", dfs(F)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2096 Collecting Bugs]]></title>
    <url>%2F2019%2F02%2F12%2Fcollecting-bugs%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题A.Collecting Bugs（Html Address:http://poj.org/problem?id=2096）题面Ivan is fond of collecting. Unlike other people who collect post stamps,coins or other material stuff, he collects software bugs. When Ivan gets a new program, he classifies all possible bugs into n categories. Each day he discovers exactly one bug in the program and adds information about it and its category into a spreadsheet. When he finds bugs in all bug categories, he calls the program disgusting, publishes this spreadsheet on his home page, and forgets completely about the program. Two companies, Macrosoft and Microhard are in tight competition. Microhard wants to decrease sales of one Macrosoft program. They hire Ivan to prove that the program in question is disgusting. However, Ivan has a complicated problem. This new program has s subcomponents, and finding bugs of all types in each subcomponent would take too long before the target could be reached. So Ivan and Microhard agreed to use a simpler criteria —- Ivan should find at least one bug in each subsystem and at least one bug of each category. Macrosoft knows about these plans and it wants to estimate the time that is required for Ivan to call its program disgusting. It’s important because the company releases a new version soon, so it can correct its plans and release it quicker. Nobody would be interested in Ivan’s opinion about the reliability of the obsolete version. A bug found in the program can be of any category with equal probability. Similarly, the bug can be found in any given subsystem with equal probability. Any particular bug cannot belong to two different categories or happen simultaneously in two different subsystems. The number of bugs in the program is almost infinite, so the probability of finding a new bug of some category in some subsystem does not reduce after finding any number of bugs of that category in that subsystem. Find an average time (in days of Ivan’s work) required to name the program disgusting. 简要翻译一个软件有$s$个子系统，会产生$n$种$bug$。 你每天会发现一个$bug$，这个$bug$属于某个子系统，属于某种$bug$。 每天发现的$bug$，出现在每个子系统中的概率都是$\frac 1s$，属于每种$bug$的概率均为$\frac 1n$。 求找出所有的$n$种$bug$，且每个子系统都找到$bug$所需要的天数的期望。 Input输入两个整数$n,s$。 Output输出期望，保留小数点后四位小数。 Sample Input1 2 Sample Output3.0000 Hint$1&lt;n,s\leq 1,000$ 设$f(i,j)$表示已经找到$i$种$bug$，存在于$j$个子系统中的期望还要多少天。 那么$f(n,s)=0$，$f(0,0)$即为（正义）答案。 状态转移如下： $1.$发现了新$bug$种类，存在于新子系统，$p_1=\frac{n-i}n×\frac{s-j}s$，还需要$f(i+1,j+1)$天。 $2.$发现了新$bug$种类，存在于旧子系统，$p_2=\frac{n-i}n×\frac js$，还需要$f(i+1,j)$天。 $3.$发现了旧$bug$种类，存在于新子系统，$p_3=\frac in×\frac {s-j}s$，还需要$f(i,j+1)$天。 $4.$发现了旧$bug$种类，存在于旧子系统，$p_4=\frac in×\frac js$，还需要$f(i,j)$天。 所以期望的转移方程为： f(i,j)=p_1f(i+1,j+1)+p_2f(i+1,j)+p_3f(i,j+1)+p_4f(i,j)+1移项$f(i,j)$可得： f(i,j)=\frac{p_!f(i+1,j+1)+p_2f(i+1,j)+p_3f(i,j+1)+1}{1-p_4}​时间复杂度为$O(ns)$。 Code123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;int n, s;double f[1010][1010];int main(int argc, char const *argv[])&#123; while(~scanf("%d%d",&amp;n,&amp;s)) &#123; memset(f,0,sizeof(f)); for (int i = n; ~i; --i) for (int j = s; ~j; --j) &#123; if (i == n &amp;&amp; j == s) continue; double p1 = 1.0 * (n - i) / n * (s - j) / s; double p2 = 1.0 * (n - i) / n * j / s; double p3 = 1.0 * i / n * (s - j) / s; double p4 = 1.0 * i / n * j / s; f[i][j] = 1.0 * (p1 * f[i + 1][j + 1] + p2 * f[i + 1][j] + p3 * f[i][j + 1] + 1) / (1.0 - p4); &#125; printf("%.4f\n", f[0][0]); &#125; return 0;&#125; poj有毒啦！ 最后明明应该输出“$\%.4lf$”，结果强行”$\%.4f$”才过。 [○･｀Д´･ ○]！！！]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#301 D.Bad Luck Island]]></title>
    <url>%2F2019%2F02%2F12%2FCodeForces-301-D-Bad-Luck-Island%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题E.Bad Luck Island题面The Bad Luck Island is inhabited by three kinds of species: $r$ rocks, $s$ scissors and $p$ papers. At some moments of time two random individuals meet (all pairs of individuals can meet equiprobably), and if they belong to different species, then one individual kills the other one: a rock kills scissors,scissors kill paper, and paper kills a rock. Your task is to determine for each species what is the probability that this species will be the only one to inhabit this island after a long enough period of time. 简要题意在一个岛上，有 $𝑟 + 𝑠 + 𝑝$ 个人，其中有$𝑟$个人有石头，$𝑠$个人有剪刀，$𝑝$个人有布。 遵循石头剪刀布的原则，输的人就狗带了。每两个人遇到概率的相等。求每个人存活的概率。 显然有同种东西的人存活概率相等，你只需要输出有石头，剪刀，布的人的存活概率即可。 Input一行包括三个整数 $r,s,p$ ，如题意所示分别代表石头，剪刀，布。 Output输出三个实数，由空格隔开，分别代表石头，剪刀，布存活的概率，如果输出与答案的误差不超过$10^{-9}​$，则认为答案正确。 Sample Input 12 2 2 Sample Output 10.333333333333 0.333333333333 0.333333333333 Sample Input 22 1 2 Sample Output 20.150000000000 0.300000000000 0.550000000000 Sample Input 31 1 3 Sample Output 30.057142857143 0.657142857143 0.285714285714 Hint$1\leq r,s,p\leq100​$ 不解释了吧？ 一道期望$dp$，设$f[i][j][k]$，$i$为出石头的人，$j$为出剪刀的人，$k$为出布的人，组合一波即可。 初始状态为$f[r][s][p]=1$，转移方程见代码吧，基本相同。 Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 110;int r, s, p;double f[N][N][N], A1, A2, A3;long long calc(int x, int y, int z)&#123; return max(((x + y + z) * (x + y + z - 1) - x * (x - 1) - y * (y - 1) - z * (z - 1)) &gt;&gt; 1, 1);&#125;int main()&#123; r = read(), s = read(), p = read(); f[r][s][p] = 1; for (int i = r; ~i; --i) for (int j = s; ~j; --j) for (int k = p; ~k; --k) &#123; if (!i &amp;&amp; !j &amp;&amp; !k) continue; if (i == r &amp;&amp; j == s &amp;&amp; k == p) continue; f[i][j][k] += f[i + 1][j][k] * (1.0 * (i + 1) * k / calc(i + 1, j, k)); f[i][j][k] += f[i][j + 1][k] * (1.0 * (j + 1) * i / calc(i, j + 1, k)); f[i][j][k] += f[i][j][k + 1] * (1.0 * (k + 1) * j / calc(i, j, k + 1)); &#125; for (int i = 1; i &lt;= r; ++i) A1 += f[i][0][0]; for (int i = 1; i &lt;= s; ++i) A2 += f[0][i][0]; for (int i = 1; i &lt;= p; ++i) A3 += f[0][0][i]; printf("%.11lf %.11lf %.11lf", A1, A2, A3); return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu P1654 OSU!]]></title>
    <url>%2F2019%2F02%2F12%2Fluogu-P1654-OSU%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题D.OSU!题面 osu 是一款群众喜闻乐见的休闲软件。 我们可以把osu的规则简化与改编成以下的样子: 一共有n次操作，每次操作只有成功与失败之分，成功对应1，失败对应0，n次操作对应为1个长度为n的01串。在这个串中连续的 X个1可以贡献X^3 的分数，这x个1不能被其他连续的1所包含（也就是极长的一串1，具体见样例解释） 现在给出n，以及每个操作的成功率，请你输出期望分数，输出四舍五入后保留1位小数 Input 第一行有一个正整数n,表示操作个数。接下去n行每行有一个[0,1]之间的实数，表示每个操作的成功率。 Output 只有一个实数，表示答案。答案四舍五入后保留1位小数。 Sample Input30.50.50.5 Sample Output6.0 Hint 000分数为0，001分数为1，010分数为1，100分数为1，101分数为2，110分数为8，011分数为8，111分数为27，总和为48，期望为48/8=6.0 $N\leq 10^5$ 学习$luogu$上$hall_of_history$大佬简洁的题解。 首先，学过数学的幼儿园毕业生都知道$(x+1)^3=x^3+3x^2+3x+1​$ 每多增加一个1，则答案就变为原先的$(x+1)^3=x^3+3x^2+3x+1$， 也就是比原先多了$(x+1)^3-x^3=3x^2+3x+1$。 维护这个增加的期望，维护$x_1[i]$表示$x$的期望，维护$x_2[i]$表示$x^2$的期望。 则有$x_1[i]=(x_1[i-1]+1)×p[i]$，$x_2[i]=(x_2[i-1]+2×x_1[i-1]+1)×p[i]$。 所以有： $Ans[i]=Ans[i-1]+(3×x_2[i-1]+3×x_1[i-1]+1)×p[i]$。 我们求$Ans[n]$即可。 Code1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;long long read()&#123; long long x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e5 + 10;double p[N], x1[N], x2[N], Ans[N];long long n;int main()&#123; n = read(); for (int i = 1; i &lt;= n; ++i) scanf("%lf", &amp;p[i]); for (int i = 1; i &lt;= n; ++i) &#123; x1[i] = (x1[i - 1] + 1) * p[i]; x2[i] = (x2[i - 1] + 2 * x1[i - 1] + 1) * p[i]; Ans[i] = Ans[i - 1] + (3 * x2[i - 1] + 3 * x1[i - 1] + 1) * p[i]; &#125; printf("%.1lf", Ans[n]); return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6390 GUGUFISHTION]]></title>
    <url>%2F2019%2F02%2F11%2FHDU-6390-GUGUFISHTION%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题A.GUGUFISHTION题面给出$m,n,p$，求：$\sum_{a=1}^m\sum_{b=1}^n\frac {\phi(ab)}{\phi(a)\phi(b)}\ mod\ \ p$ Input第一行一个$T$代表组数。 之后的$T$行，每行包含三个整数$m,n,p$。 数据保证$p$是一个质数。 Output输出$T​$行，每行只有一个整数表示答案。 Sample Input1 5 7 23 Sample Output2 Hint$1\leq T \leq 3​$ $1\leq m,n\leq1,000,000$ $max(m,n)&lt; p \leq 10^9+7​$ 由欧拉函数的性质$\phi(p^k)=(p-1)×p^{k-1}(p为质数)$。 令$d=gcd(a,b)=p_1^{k_1}×p_2^{k_2}×…×p_n^{k_n}​$。 $G_u(a,b)=\frac {\phi(a,b)}{\phi(a)\phi(b)}=\frac{\phi(p_1^{2k_1}×p_2^{2k_2}×…×p_n^{2k_n})}{\phi(p_1^{k_1}×p_2^{k_2}×…×p_n^{k_n})^2}$ 由于欧拉函数为积性函数，且因为各项上下互质，展开约去。 $G_u(a,b)=\frac {(p_1-1)×(p_2-1)×(p_3-1)×…×(p_n-1)×p_1^{2k_1-1}×p_2^{2k_2-1}×…×p_n^{2k_n-1}}{(p_1-$1)^2×(p_2-1)^2×(p_3-1)^2×…×(p_n-1)^2×p_1^{k_1-1}×p_2^{k_2-1}×…×p_n^{k_n-1}}​$ $=\frac {p_1×p_2×p_3×…×p_n}{(p_1-1)×(p_2-1)×…×(p_n-1)}=\frac {p_1×p_2×p_3×…×p_n×p_1^{k_1-1}×p_2^{k_2-1}×…×p_n^{k_n-1}}{(p_1-1)×(p_2-1)×(p_3-1)×…×(p_n-1)×p_1^{k_1-1}×p_2^{k_2-2}×…×p_n^{k_n-1}}​$ $=\frac {p_1^{k_1}×p_2^{k_2}×…×p_n^{k_n}}{\phi(p_1^{k_1}×p_2^{k_2}×…×p_n^{k_n})}=\frac {d}{\phi{d}}​$ 令$a[i]=\frac i{\phi(i)}​$，$f(m,n)=\sum_{a=1}^m\sum_{b=1}^nG_u(a,b)=\sum_{a=1}^m\sum_{b=1}^na×d​$ $f(m,n)=\sum_{d=1}^{min(m,n)}\sum_{a=1}^m\sum_{b=1}^na[t]×[d==t]=\sum_{d=1}^{min(m,n)}\sum_{a=1}^{\lfloor \frac mt\rfloor}\sum_{b=1}^{\lfloor \frac nt\rfloor}a[t]×[d==1]$ $[到此处d的定义取消，懒得修改，写完发现不对了]​$╮(╯▽╰)╭ 令$g(m,n)=\sum_{a=1}^m\sum_{b=1}^n[d==1]=\sum_{a=1}^m\sum_{b=1}^n\sum_{d|gcd(a,b)}\mu(d)=\sum_{d=1}^{min(a,b)}\mu(d)×\frac md×\frac nd$ 因为有： $\sum_{d|n}\mu(d)=1\ \ (n==1)$ $\sum_{d|n}\mu(d)=0\ \ (n&gt;1)$ 当$gcd(a,b)==1$，则$\sum_{d|gcd(a,b)}\mu(d)=1$； 当$gcd(a,b)\ !\ =1​$，则$\sum_{d|gcd(a,b)}\mu(d)=0，=[gcd(a,b)==1]​$。 因为$\frac md$表示在$a∈[1,m]$中能被$d$整除的数的个数，$\frac nd$表示在$b∈[1,n]$中能被$d$整除的数的个数。 所以，可证等价。 所以有$f(m,n)=\sum_{d=1}^{min(m,n)}a[t]×(\sum_{a=1}^{\lfloor \frac mt\rfloor}\sum_{b=1}^{\lfloor \frac nt\rfloor}[d==1])=\sum_{d=1}^{min(m,n)}a[t]×g(\frac mt,\frac nt)$。 时间复杂度$\frac n1+\frac n2+\frac n3+\frac n4+…+\frac n{n-1}+\frac nn=nln(n)+C（C为欧拉函数）$ 没想平均时间复杂度为$O(ln(n))​$，所以总时间复杂度为$O(nln(n))​$。 CODE：因为总有$\phi(i)&lt;i$，预处理出$max(m,n)​$个逆元即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;long long read()&#123; long long x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e6 + 10;bool notprime[N];int mu[N], p[N], cnt;long long m, n, mod;long long phi[N], a[N], inv[N];void Prime()&#123; phi[1] = mu[1] = 1; notprime[1] = 1; for (int i = 2; i &lt;= 1000000; ++i) &#123; if (!notprime[i]) &#123; p[++cnt] = i; phi[i] = i - 1; mu[i] = -1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= 1000000; ++j) &#123; notprime[i * p[j]] = 1; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; else &#123; phi[i * p[j]] = phi[i] * (p[j] - 1); mu[i * p[j]] = -mu[i]; &#125; &#125; &#125;&#125;void inv_work(int lim)&#123; inv[1] = 1; for (int i = 2; i &lt;= lim; ++i) inv[i] = inv[mod % i] * (mod - mod / i) % mod; for (int i = 1; i &lt;= lim; ++i) a[i] = inv[phi[i]] * i % mod;&#125;int main()&#123; int T = read(); Prime(); while (T--) &#123; m = read(), n = read(), mod = read(); int lim = min(m, n); inv_work(lim); long long result = 0; for (int i = 1; i &lt;= lim; ++i) &#123; int pp = m / i, qq = n / i; long long t = 0; for (int j = 1; j &lt;= min(pp, qq); ++j) (t += 1ll * mu[j] * (pp / j) * (qq / j) + mod) %= mod; (result += a[i] * t % mod) %= mod; &#125; cout &lt;&lt; result &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4804 欧拉心算]]></title>
    <url>%2F2019%2F02%2F11%2Fbzoj-4804-%E6%AC%A7%E6%8B%89%E5%BF%83%E7%AE%97%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题C.欧拉心算题面给出一个数字N，求$\sum_{i=1}^n\sum_{j=1}^n\phi(gcd(i,j))$。 Input 第一行为一个正整数$T​$，表示数据组数。 接下来$T$行为询问，每行包含一个正整数$N$。 Output 按读入顺序输出答案。 Sample Input1 10 Sample Output 136 Hint $T\leq5000,N\leq10^7$ 解析莫比乌斯反演一波可得： Ans=\sum_{i=1}^n\sum_{j=1}^n\phi(gcd(i,j))=\sum_{i=1}^n\phi(i)\sum_{d=1}^{\lfloor\frac ni\rfloor}\mu(d)\lfloor\frac n{id}\rfloor^2令$g(n)=\sum_{d=1}^n\mu(d)\lfloor\frac nd\rfloor^2​$ 因为$\lfloor\frac nd\rfloor-\lfloor\frac {n-1}d\rfloor=1$成立当且仅当$d|n$ 那么$g(n)=g(n-1)+\sum_{d|n}\mu(d)(2\frac {n}d-1)$ 因为$\sum_{d|n}\frac {\mu(d)}d=\frac {\phi(n)}n$ $g(n)=g(n-1)+2\phi(d)-[n==1]​$ 于是有$Ans=\sum_{i=1}^n\phi(i)g(\lfloor\frac ni\rfloor)$ 该算法时间复杂度为$O(T\sqrt N)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e7 + 10;int p[N], cnt, q[5010], T;long long phi[N], g[N];bool notprime[N];void work(int m, long long ans = 0)&#123; for (int i = 1, ne; i &lt;= m; i = ne + 1) &#123; ne = m / (m / i); ans += (phi[ne] - phi[i - 1]) * g[m / i]; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;void Prime()&#123; phi[1] = g[1] = 1, notprime[1] = 1; for (int i = 2; i &lt;= 10000000; ++i) &#123; if (!notprime[i]) &#123; p[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= 10000000; ++j) &#123; notprime[i * p[j]] = 1; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; else phi[i * p[j]] = phi[i] * (p[j] - 1); &#125; g[i] = g[i - 1] + 2 * phi[i]; &#125; for (int i = 2; i &lt;= 10000000; ++i) phi[i] += phi[i - 1];&#125;int main()&#123; T = read(); Prime(); while (T--) work(read()); return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3994/luogu P3327 约数个数和]]></title>
    <url>%2F2019%2F02%2F11%2Fbzoj-3994(luogu-P3327)-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题D.约数个数和题面设d(x)为x的约数个数，给定N、M，求 $\sum_{i=1}^{N}\sum_{j=1}^{M}d(i×j)$. Input输入文件包含多组测试数据。 第一行，一个整数T，表示测试数据的组数。 接下来的T行，每行两个整数N、M。 OutputT行，每行一个整数，表示你所求的答案。 Sample Input27 45 6 Sample Output110 121 Hint$1\leq N,M \leq 50,000$ $1\leq T \leq 50,000$ 哎，今天fhj大佬讲课也是很无奈，莫比乌斯反演虽然是学了，但是确实不太会用哇。 公式恐惧症患者一枚…… 第一步​ 首先，我们证明一条结论：d(n×m)=\sum_{i|n}\sum_{j|m}[gcd(i,j)==1] ​ 证明：对于nm每一个质因子$p_i$，我们令$n={p_i}^{a_i}×n_x,m={p_i}^{b_i}×m_x$，则有d(n×m)=\Pi_i(a_i+b_i+1)​，设 $l$ 和 $t$ 互质且不含质因子$p_i$，那么$(l×{p_i}^{a_i},t),(l×{p_i}^{a_i-1})…(l,t)…(l,t×{p_i}^{b_i-1}),(l,t×{p_i}^{b_i})$都是互质的数对，而 $ l$ 和 $ t $ 的取法刚好是$\Pi_{k\neq i}(a_k+b_k+1)$种。 第二步​ 下面是公式恐惧症的“福利”？！ \sum_{i=1}^n\sum_{j=1}^md(i×j)=\sum_{i=1}^n\sum_{j=1}^m\sum_{k|i}\sum_{l|j}[gcd(k,l)==1]​​ 现在我们枚举每一个数对$(k,l)$,那么它们会被算多少遍呢？每一个$k$的倍数都会算一次$k$，每一个$l$的倍数又会算一次$l$,而用$\frac nk$来表示n以内k的倍数有多少个是显然的，所以： \sum_{k=1}^n\sum_{l=1}^m\frac nk×\frac ml[gcd(k,l)==1]​ 然后我们能够用莫比乌斯函数的性质： \sum_{d|n}\mu(d)=1\ (n==1)\sum_{d|n}\mu(d)=0\ (n>1)​ 那我们就可以得到： \sum_{k=1}^n\sum_{l=1}^m\frac nk×\frac ml\sum_{d|gcd(k,l)}\mu(d)​ 如果$gcd(k,l)==1$，此时后面的这些等于1，否则是0。 ​ 我们就能得到： \sum_{k=1}^n\sum_{l=1}^m\frac nk× \frac ml\sum_{d|k且d|l}\mu(d)​ 我们只要枚举$\mu(d)$，显然，我们只要枚举d的倍数来与$\mu(d)$相乘即可。 \sum_{d=1}^{min(n,m)}\mu(d)\sum_{i=1}^\frac nd\sum_{j=1}^\frac md\frac n{d_i}×\frac m{d_j}第三步​ 我们由第二步继续变形可得： \sum_{d=1}^{min(n,m)}\mu(d)×(\sum_{k=1}^{\frac nd}\frac n{dk})×(\sum_{l=1}^{\frac md}\frac m{dl})令$g(x)=\sum_{i=1}^x\frac xi​$ \sum_{d=1}^{min(n,m)}\mu(d)×g(\frac nd)×g(\frac md)我们预处理出$g(x)​$即可。 观察一下$g(x)$，就会发现其实式子可以这么理解：$x$以内有约数i的数的个数和，也就是可看作原题中$d(x)$的前缀和要求$d(x)$的前缀和，可以求出每一个$d(x)$,也就是用线性筛求啦，要记录一下$c(x)$:将$x$分解质因数后，最小质因数的指数。那么参见第一步，x的最小质因数对$d(x)$的贡献为$c(x)+1$。 第四步​ 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;int mu[500010],p[50010],cnt,n,m;long long a[500010],b[500010];bool notprime[500010];void Prime()&#123; mu[1]=a[1]=b[1]=1; for(int i=2;i&lt;=50000;++i) &#123; if(!notprime[i]) &#123; p[++cnt]=i; mu[i]=-1,a[i]=1,b[i]=2; &#125; for(int j=1;j&lt;=cnt&amp;&amp;i*p[j]&lt;=50000;++j) &#123; notprime[i*p[j]]=1; if(i%p[j]==0) &#123; b[i*p[j]]=b[i]/(a[i]+1)*(a[i]+2); a[i*p[j]]=a[i]+1; break; &#125; else &#123; b[i*p[j]]=b[i]*b[p[j]]; a[i*p[j]]=1; mu[i*p[j]]=-mu[i]; &#125; &#125; &#125; for(int i=2;i&lt;=50000;++i) &#123; b[i]+=b[i-1]; mu[i]+=mu[i-1]; &#125;&#125;int main()&#123; int T=read(); Prime(); while(T--) &#123; long long result=0; n=read(),m=read(); if(n&gt;m) swap(n,m); for(int i=1,j;i&lt;=n;i=j+1) &#123; j=min(n/(n/i),m/(m/i)); result+=(mu[j]-mu[i-1])*b[n/i]*b[m/i]; &#125; cout&lt;&lt;result&lt;&lt;endl; &#125; return 0;&#125; p.s.还有很重要的一点，如果初始化用这样a[N]={0,1}，会导致exe文件过大而无法提交，嘤嘤嘤，感谢vhosc巨佬……(/≧▽≦)/]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.5.30 集训总结]]></title>
    <url>%2F2018%2F05%2F30%2F2018-5-30%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~总结： 先从第一天的比赛开始看，其实光从题目来看，我排于第七名的成绩，也就是两道水题和一道比较熟练的BFS给的，后面几题是没有思路的（大佬们太强了啊），被完虐…… 我再从昨天的ACM欢乐赛开始说起————比赛第一个小时，从A题的水题十分钟完成的速度来看，稍稍放宽了心态，然而在B题上竟然栽了跟头。最初在第三个点WA了2遍，再在14点WA了好几遍，最后又卡在了35点。最后心态几乎爆炸（内心OS：这可是一道水题啊），同样，同组的大佬们，也没发现有什么问题。就这样纠结着，最后将一个双重判定换了方向的思维的另一种判定，于是，终于是A了……此时时间已经在两小时之后了（比赛半程刚过）。内心火急火燎得，也不知怎的其他两位大佬，竟然开始换顺序做，半小时过去，VHOS（太强了）竟然完成了G组题，然而不幸的是不能提交（辣鸡日本Vjudge）。这又是对我们心态的考验，于此同时半数以上的组早已经完成了3道了，我们的排名位置几乎已经可以看到榜底了。终于在最后的第三个小时————奇迹竟然出现了！三小时十分钟！C题！！AC！！三小时三十分！G题！！AC！！此时我们的排名已经挤到了前十，4道AC，最多的大神组早完成了5题，我心有不甘，继续奋战，此时只剩唯我一人奋笔疾书……周围的人早已懈怠，不，还不能那么早。努力的想着D题，dp方程却死也推不出来，最后十五分钟……！！！哦！！！突然有了想法，夺过键盘，最后13分钟！！！我知道这次我没有调试的时间了，只能要求自己一遍过，每个字都敲得小心翼翼，同时又得加快速度…………3min！2min！！敲完了！！！样例一过，直接提交，不敢浪费每一分钟！！！竟然成功AC了！！！！！同组的大佬高兴的欢呼！！我做到了！！！当自己平静下来时，我才发现自己的身体一直在颤抖，心跳十分的快。最后我们虽然罚时很久，但是最终也以唯一AC 6道的好成绩位居了榜首，十分不易啊！！ （P.S:最后从岳神和刘大佬的钱包里成功坑到一顿KFC）o(●ˇ∀ˇ●)o 下面是对这几天所学内容的总结，逐条枚举：（其实很多口胡一波，并不能上手当场码题） 1、$KMP$ （俗称“看*片算法”） （一%飞神）这是由三位大神同时发现的一种改进字符串匹配的算法（%%%），$KMP$算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个$next()$函数，函数本身包含了模式串的局部匹配信息。（强行解释一波失配函数）上波代码： 1234567891011121314151617181920int KMP(string W,string T)&#123; int i=1,j=1; while(i&lt;=n)&#123; while (j!=0&amp;&amp;W[j]!=T[i]) j=next[j]; if(j==m) return i-m+1;//匹配成功，返回匹配位置s else&#123;j++; i++;&#125; &#125; return -1;//匹配失败&#125;void GetNext(charT[],intnext[])&#123; next[1]=0; j=1;k=0; while(j&lt;T[0]) if((k==0)||(T[j]==T[k]))&#123; j++; k++; next[j]=k; &#125; else k=next[k];&#125; （其实并不太清楚它到底具体有什么用）=v= 2、数论、定理 （一堆奇奇怪怪的东西）（边打边复习）首先上场的是唯一分解和$lcm$、$gcd$（这货贼重要），由此引申的是欧几里得和扩展欧。 //威尔逊定理//：它给出了判定一个自然数是否为素数的充分必要条件，就是当且仅当$p$为素数时：$(p-1)!≡-1(mod p)$，但是由于阶乘是增长的速度实在是…………（所以结论对于实际操作意义不大，感觉说了废话） //小费马//：假如$p$是质数，且$gcd(a,p)=1$，那么$a(p-1)≡1(mod\ p)$（强制使用了一波$gcd$）（其中$gcd$为$1$代表互质）（结果证明出来了）（该同余式可以转为$ap≡p(mod\ p)$，不知道写的对不对，好像提到过） //欧拉函数与定理//：emmm，这玩意我实在不是很懂,认识了一下$φ$，还有欧拉定理：若$gcd(a,p)=1$，则$a^{φ(p)}≡1(mod\ p)$。 //关于这些定理的例题使用//：不太熟练，不献丑=w=，学习大神们的写法，费力的理解啊啊啊………… 3、$manacher$ （二%飞神）这个和$KMP$一样，是关于字符串的一种算法，主要针对回文串。以$O（n）$的时间复杂度以每个字符为中心，以回文串单程长度，将所取字符串扩展一倍。如果是奇数串就能顺利进行，如果偶数串，那必须插入奇怪的字符。但这种算法的神奇之处在于可以同时考虑奇串和偶串。（但不能拆坏原字符串）（代码好长，我决定不凑字数）(￣▽￣)” 4、状压$DP$好吧，我承认位运算我实在是烂透了，完全没记住，差点听成大弱智╮(╯-╰)╭ 。表示状压列举的子集既能完全枚举，还能节约不必要列举的时间……（来自萌新的神奇(⊙o⊙)） 5、树的$LCA$ （求树两点之间的最短路）先从树的$dfs$序入手，展开倍增（看得懂，表示不会写……），$tarjan$（竟然基于冰茶几（并查集）！！），$RMQ$，$emmm$（回去重新学习连通分量）。（不好随便口胡=-=，决定翻工学习） 6、差分 （一起讲了差分约束吧）差分所擅长做的就是把$a$数组中$l~r$范围内的数加上或减去某个$k$值，这样只要求前缀和，运用差分就只要求前缀和，就能在$O（n）$的时间内得到整个数组的值。差分约束嘛，是基于图论知识$SPFA$和判环的，比如我们得到$a[x]]]></content>
      <categories>
        <category>5/6月集训</category>
      </categories>
      <tags>
        <tag>Total Review</tag>
      </tags>
  </entry>
</search>
