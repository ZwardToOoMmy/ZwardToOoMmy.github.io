<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[è’Ÿè’»â„(â„ â„â€¢â„Ï‰â„â€¢â„ â„)â„æŠ¥é“ (ç½®é¡¶)(ç½®é¡¶)]]></title>
    <url>%2F2099%2F12%2F31%2F%E8%92%9F%E8%92%BB%E6%8A%A5%E9%81%93%2F</url>
    <content type="text"><![CDATA[è¿™ç¯‡æ–‡ç« çš„å‡ºç°ï¼Œé¢„ç¤ºç€æ—¶éš”å¤šå¹´ï¼Œæˆ‘çš„åšå®¢ç»ˆäºè¦å¯ç”¨å•¦ï¼æ’’èŠ±èŠ±]]></content>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#242 E.XOR on Segment]]></title>
    <url>%2F2019%2F02%2F15%2FCodeForces-242-E-XOR-on-Segment%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç©¶æçš„æœ€å¤§æµç®—æ³•ISAPä¸HLPPHLPPâ€”â€”é’±é€¸å‡¡]]></title>
    <url>%2F2019%2F02%2F15%2F%E7%A9%B6%E6%9E%81%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AE%97%E6%B3%95ISAP%E4%B8%8EHLPPHLPP__%E9%92%B1%E9%80%B8%E5%87%A1%2F</url>
    <content type="text"><![CDATA[æœ¬æ–‡æ¬è¿è‡ªæ´›è°·å¤§ä½¬é’±é€¸å‡¡çš„åšå®¢ ç©¶çº§çš„æœ€å¤§æµç®—æ³•ï¼šISAPä¸HLPPæœ€å¤§æµçš„å®šä¹‰åŠåŸºç¡€è§£æ³•è¿™é‡Œå°±ä¸å†èµ˜è¿°äº† æœ‰éœ€è¦çš„å¯ä»¥çœ‹ä¹‹å‰å†™çš„åŠ£è´¨æ–‡ç« EKä¸Dinicæ±‚è§£æœ€å¤§æµçš„æ–¹æ³•äº† å‰è¨€æœ€å¤§æµç®—æ³•ç›®å‰æœ‰å¢å¹¿è·¯ç®—æ³•å’Œé¢„æµæ¨è¿›ç®—æ³•ä¸¤ç§ï¼Œå¢å¹¿è·¯ç®—æ³•çš„æ€æƒ³æ˜¯ä¸æ–­åœ°å¯»æ‰¾å¢å¹¿è·¯æ¥å¢å¤§æœ€å¤§æµï¼Œè€Œé¢„æµæ¨è¿›ç®—æ³•çš„æ€æƒ³æ˜¯â€¦â€¦åé¢å†è®²ã€‚ å…ˆä»æœ€ç†Ÿæ‚‰çš„å¢å¹¿è·¯ç®—æ³•å¼€å§‹è®²ã€‚ ISAP(Improved Shortest Augumenting Pathï¼‰ï¼šå…¶å®Dinicå·²ç»è¶³å¤Ÿé«˜æ•ˆäº†ï¼Œä½†é‚£äº›ï¼ˆé—²ç€æ²¡äº‹å¹²ï¼‰çš„è®¡ç®—æœºç§‘å­¦å®¶ä»¬å¯¹Dinicçš„æ•ˆç‡ä»ä¸æ»¡è¶³ï¼Œäºæ˜¯å°±æœ‰äº†ISAPç®—æ³•ã€‚ åœ¨Dinicä¸­æˆ‘ä»¬æ¯æ¬¡å¢å¹¿å‰éƒ½è¿›è¡Œäº†ä¸€æ¬¡bfsæ¥åˆå§‹åŒ–æ¯ä¸ªç‚¹çš„æ·±åº¦ï¼Œè™½ç„¶ä¸€æ¬¡æ ‡å·å¢å¹¿äº†å¾ˆå¤šæ¡è·¯ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯å¾ˆæœ‰å¯èƒ½è¦è·‘å¾ˆå¤šébfså¯¼è‡´æ•ˆç‡ä¸é«˜ã€‚ é‚£æœ‰æ²¡æœ‰ä»€ä¹ˆåŠæ³•åªè·‘ä¸€æ¬¡bfså‘¢?é‚£å°±æ˜¯ISAPç®—æ³•äº†ï¼ISAPè¿è¡Œè¿‡ç¨‹ï¼š1.ä»tåˆ°sè·‘ä¸€ébfsï¼Œæ ‡è®°æ·±åº¦ï¼ˆä¸ºä»€ä¹ˆæ˜¯ä»tåˆ°så‘¢ï¼Ÿåé¢ä¼šè®²ï¼‰ 2.ä»såˆ°tè·‘dfsï¼Œå’ŒDinicç±»ä¼¼ï¼Œåªæ˜¯å½“ä¸€ä¸ªç‚¹è·‘å®Œåï¼Œå¦‚æœä»ä¸Šä¸€ä¸ªç‚¹ä¼ è¿‡æ¥çš„flowæ¯”è¯¥ç‚¹çš„usedå¤§ï¼ˆå¯¹äºè¯¥ç‚¹å½“å‰çš„æ·±åº¦æ¥è¯´ï¼Œè¯¥ç‚¹åœ¨è¯¥ç‚¹ä»¥åçš„è·¯ä¸Šå·²ç»åºŸäº†ï¼‰ï¼Œåˆ™æŠŠå®ƒçš„æ·±åº¦åŠ 1ï¼Œå¦‚æœå‡ºç°æ–­å±‚ï¼ˆæŸä¸ªæ·±åº¦æ²¡æœ‰ç‚¹ï¼‰ï¼Œç»“æŸç®—æ³• 3.å¦‚æœæ“ä½œ2æ²¡æœ‰ç»“æŸç®—æ³•ï¼Œé‡å¤æ“ä½œ2 å¥½æŠ½è±¡å•Šã€‚ä»€ä¹ˆåŸç†å‘¢ï¼Ÿ ISAPå…¶å®ä¸Dinicå·®ä¸å¤šï¼Œä½†æ˜¯å®ƒåªè·‘ä¸€ébfsï¼Œä½†æ˜¯æ¯ä¸ªç‚¹çš„å±‚æ•°éšç€dfsçš„è¿›è¡Œè€Œä¸æ–­æé«˜ï¼ˆè¿™æ ·å°±ä¸ç”¨åå¤è·‘bfsé‡æ–°åˆ†å±‚äº†ï¼‰ï¼Œå½“sçš„æ·±åº¦å¤§äºnæ—¶ï¼ˆè¿™å°±æ˜¯ä¸ºä»€ä¹ˆbfsè¦ä»tåˆ°sï¼‰ï¼Œç»“æŸç®—æ³•ã€‚ å…ˆç»™ä¸€äº›æ•°ç»„å®šä¹‰ï¼š 12int dep[13000],gap[13000];//dep[i]è¡¨ç¤ºèŠ‚ç‚¹içš„æ·±åº¦ï¼Œgap[i]è¡¨ç¤ºæ·±åº¦ä¸ºiçš„ç‚¹çš„æ•°é‡ bfséƒ¨åˆ†: 1234567891011121314151617181920void bfs()&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); dep[t]=0; gap[0]=1;// queue&lt;int&gt;q; q.push(t); while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=node[i].next)&#123; int v=node[i].v; if(dep[v]!=-1)continue;//é˜²æ­¢é‡å¤æ”¹æŸä¸ªç‚¹ q.push(v); dep[v]=dep[u]+1; gap[dep[v]]++; &#125; &#125; return;&#125;//åˆå§‹åŒ–bfsï¼Œä»tåˆ°sæœå‡ºæ¯ä¸ªç‚¹åˆå§‹æ·±åº¦ å¯ä»¥çœ‹å‡ºISAPé‡Œçš„bfså¯¹ è¾¹æƒ!=0 è¿™ä¸€æ¡ä»¶å¹¶æ²¡æœ‰é™åˆ¶ï¼Œåªè¦åœ¨åé¢çš„dfsé‡Œåˆ¤æ–­è¾¹æƒå°±å¥½äº†ã€‚ æ¥ä¸‹æ¥æ˜¯dfsï¼š 1234567891011121314151617181920212223242526272829int dfs(int u,int flow)&#123; if(u==t)&#123;//å¯ä»¥åˆ°è¾¾t maxflow+=flow; return flow; &#125; int used=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;dep[d]+1==dep[u])&#123; int mi=dfs(d,min(node[i].val,flow-used)); if(mi)&#123; node[i].val-=mi; node[i^1].val+=mi; used+=mi; &#125; if(used==flow)return used; &#125; &#125; //å‰åŠæ®µå’ŒDinicä¸€æ¨¡ä¸€æ · //å¦‚æœå·²ç»åˆ°äº†è¿™é‡Œï¼Œè¯´æ˜è¯¥ç‚¹å‡ºå»çš„æ‰€æœ‰ç‚¹éƒ½å·²ç»æµè¿‡äº† //å¹¶ä¸”ä»å‰é¢ç‚¹ä¼ è¿‡æ¥çš„æµé‡è¿˜æœ‰å‰©ä½™ //åˆ™æ­¤æ—¶ï¼Œè¦å¯¹è¯¥ç‚¹æ›´æ”¹dep //ä½¿å¾—è¯¥ç‚¹ä¸è¯¥ç‚¹å‡ºå»çš„ç‚¹åˆ†éš”å¼€ --gap[dep[u]]; if(gap[dep[u]]==0)dep[s]=n+1;//å‡ºç°æ–­å±‚ï¼Œæ— æ³•åˆ°è¾¾täº† dep[u]++;//å±‚++ gap[dep[u]]++;//å±‚æ•°å¯¹åº”ä¸ªæ•°++ return used; &#125; æ„Ÿè§‰å’ŒDinicå·®ä¸å¤šã€‚ åªæ˜¯å¤šå‡ å¥è¯æ¥ç»Ÿè®¡æ·±åº¦å¯¹åº”çš„ç‚¹æ•°ã€‚ è¿™é‡Œè¦è§£é‡Šä¸€ä¸‹ä¸ºä»€ä¹ˆè¦ç»Ÿè®¡æ¯ä¸ªæ·±åº¦çš„èŠ‚ç‚¹æ•°ï¼šä¸ºäº†ä¼˜åŒ–ï¼ç»Ÿè®¡æ¯ä¸ªæ·±åº¦å¯¹åº”ç‚¹æ•°åªä¸ºäº†è¿™å¥è¯ï¼š 1if(gap[dep[u]]==0)dep[s]=n+1; å› ä¸ºæˆ‘ä»¬æ˜¯æŒ‰ç…§æ·±åº¦æ¥å¾€å‰èµ°çš„ï¼Œè·¯å¾„ä¸Šçš„ç‚¹çš„æ·±åº¦ä¸€å®šæ˜¯è¿ç»­çš„ï¼Œè€Œtçš„æ·±åº¦ä¸º0ï¼Œå¦‚æœæŸä¸ªæ·±åº¦çš„ç‚¹ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ— æ³•åˆ°è¾¾täº†æ­¤æ—¶ç›´æ¥ç»“æŸç®—æ³•å¯ä»¥å¤§å¤§èŠ‚çœæ—¶é—´ã€‚ æ¥ä¸‹æ¥æ˜¯ä¸»å‡½æ•°ï¼š 123456int ISAP()&#123; maxflow=0; bfs(); while(dep[s]&lt;n)dfs(s,inf); return maxflow;&#125; ç”±äºdfséƒ¨åˆ†ï¼ˆæœ‰ç‚¹ï¼‰ç›¸å½“æŠ½è±¡ï¼Œå¯ä»¥ç»“åˆå›¾ç¤ºç†è§£ã€‚ä»¥ä¸‹å›¾ä¸ºä¾‹ï¼šï¼ˆåå‘è¾¹æ²¡æœ‰ç”»ï¼Œä½†æ˜¯æœ‰åå‘è¾¹ï¼‰ å…ˆ bfs åˆ†å±‚ï¼šï¼ˆè“è‰²å­—ä½“è¡¨ç¤ºå±‚æ•°ï¼‰ æŒ‰ç…§æ·±åº¦ï¼Œæˆ‘ä»¬åªèƒ½èµ°S-&gt;1-&gt;5-&gt;6-&gt;tè¿™æ¡å¢å¹¿è·¯ï¼Œæµé‡ä¸º3 åœ¨dfsè¿‡ç¨‹ä¸­ï¼Œä»5ä¼ åˆ°6æ—¶$flow==4$è€Œåœ¨6å·ç‚¹çš„$used==3$ï¼Œæ‰€ä»¥æ­¤æ—¶ä¸ä¼šç›´æ¥è¿”å›ï¼ˆè§ä¸Šæ–¹çš„ä»£ç ï¼‰ï¼Œè€Œæ˜¯æŠŠ6å·ç‚¹çš„æ·±åº¦åŠ 1ï¼ŒåŒç†s,1,5çš„ä¹Ÿè¦åŠ 1ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè·‘äº†è¿™æ¡å¢å¹¿è·¯åï¼Œå›¾å˜æˆäº†ï¼š çœ‹è§äº†å—ï¼Ÿs-&gt;1-&gt;5-&gt;6-&gt;tè¿™æ¡è·¯è¢«å°äº†ï¼Œä½†æ˜¯s-&gt;1-&gt;2-&gt;3-&gt;4-&gt;tè¿™æ¡è·¯å´èƒ½èµ°äº† æŒ‰ç…§æ·±åº¦ï¼Œè¿™æ¬¡è‚¯å®šæ˜¯èµ°s-&gt;1-&gt;2-&gt;3-&gt;4-&gt;tè¿™æ¡è·¯ã€‚ è¿™æ¬¡çš„æƒ…å†µå’Œä¸Šæ¬¡ä¸åŒï¼Œç”±äºä»2ä¼ åˆ°3æ—¶çš„flow==3è€Œä¹‹åçš„è·¯å¾„çš„usedéƒ½æ˜¯3ï¼Œæ‰€ä»¥2,3,4å·ç‚¹çš„æ·±åº¦ä¸ä¼šæ”¹å˜ï¼Œè€Œ1,sçš„æƒ…å†µä¸ä¸Šæ¬¡çš„é‚£äº›ç‚¹ç›¸åŒï¼Œæ·±åº¦ä¼šæ”¹å˜ã€‚ è·‘äº†è¿™æ¡è·¯ä¹‹åï¼Œå›¾å˜æˆäº†ï¼š å›¾ä¸­å‡ºç°äº†æ–­å±‚ï¼ˆæ·±åº¦ä¸º4çš„ç‚¹æ²¡æœ‰äº†ï¼‰ï¼Œæ‰€ä»¥ä¸€å®šä¸å­˜åœ¨å¢å¹¿è·¯äº†ï¼Œå¯ä»¥ç›´æ¥ç»“æŸç®—æ³•äº†ã€‚ åˆšæ‰é‚£å¼ å›¾å¦‚æœç”¨Dinicä¼šæ€ä¹ˆæ ·ï¼Ÿä¸‰ébfsï¼Œä¸¤édfsï¼ä¸ä¹‹ç›¸æ¯”ï¼ŒISAPçœŸæ˜¯å¤ªé«˜æ•ˆäº†ï¼è¿™é‡Œé¡ºä¾¿è¯´ä¸€ä¸‹ä¸ºä»€ä¹ˆç»ˆæ­¢æ¡ä»¶æ˜¯dep[s]&lt;n ä»ä¸Šé¢çš„è¿‡ç¨‹å¯ä»¥çœ‹å‡ºï¼šæ¯èµ°ä¸€éå¢å¹¿è·¯ï¼Œsçš„å±‚æ•°å°±ä¼šåŠ 1ï¼Œå¦‚æœä¸€ç›´æ²¡æœ‰å‡ºç°æ–­å±‚ï¼Œæœ€å¤šè·‘n-depï¼ˆåˆšbfså®Œæ—¶sçš„æ·±åº¦ï¼‰æ¡å¢å¹¿è·¯ï¼ˆå› ä¸ºä¸€å…±å°±nä¸ªç‚¹ï¼‰ å®Œæ•´ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int inf=1&lt;&lt;30;int cnt=1,head[13000];int n,m,s,t;inline int Read()&#123; int x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;struct Node&#123; int v; int next; int val;&#125;node[250000];inline void addedge(int u,int v,int val)&#123; node[++cnt].v=v; node[cnt].val=val; node[cnt].next=head[u]; head[u]=cnt;&#125;int dep[13000],gap[13000];void bfs()&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); dep[t]=0; gap[0]=1; queue&lt;int&gt;q; q.push(t); while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=node[i].next)&#123; int v=node[i].v; if(dep[v]!=-1)continue; q.push(v); dep[v]=dep[u]+1; gap[dep[v]]++; &#125; &#125; return;&#125;int maxflow;int dfs(int u,int flow)&#123; if(u==t)&#123; maxflow+=flow; return flow; &#125; int used=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;dep[d]+1==dep[u])&#123; int mi=dfs(d,min(node[i].val,flow-used)); if(mi)&#123; node[i].val-=mi; node[i^1].val+=mi; used+=mi; &#125; if(used==flow)return used; &#125; &#125; --gap[dep[u]]; if(gap[dep[u]]==0)dep[s]=n+1; dep[u]++; gap[dep[u]]++; return used; &#125;int ISAP()&#123; maxflow=0; bfs(); while(dep[s]&lt;n)dfs(s,inf); return maxflow;&#125;int main()&#123; int i=1; n=Read(),m=Read(),s=Read(),t=Read(); int u,v,w; for(i=1;i&lt;=m;i++)u=Read(),v=Read(),w=Read(),addedge(u,v,w),addedge(v,u,0); printf("%d",ISAP()); return 0;&#125; å½“ç„¶ï¼Œè¿™ä¸œè¥¿ä¹Ÿå¯ä»¥å½“å‰å¼§ä¼˜åŒ–ï¼ˆåŸç†è§ Dinic ï¼‰åªéœ€è¦æ”¹ä¸€ç‚¹å³å¯ï¼š 1234while(dep[s]&lt;n)&#123; memcpy(cur,head,sizeof(head)); dfs(s,inf); &#125; dfséƒ¨åˆ†çš„ä¿®æ”¹å°±ä¸æ”¾ä»£ç äº†ï¼Œåº”è¯¥éƒ½ä¼šã€‚ æ¥ä¸‹æ¥å°±æ˜¯ç›¸å½“æŠ½è±¡çš„é¢„æµæ¨è¿›ç®—æ³•äº† åœ¨è®²è§£ç®—æ³•ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥å›é¡¾ä¸€ä¸‹æœ€å¤§æµæ˜¯å¹²å˜›çš„ï¼š æ°´æµä»ä¸€ä¸ªæºç‚¹sé€šè¿‡å¾ˆå¤šè·¯å¾„ï¼Œç»è¿‡å¾ˆå¤šç‚¹ï¼Œåˆ°è¾¾æ±‡ç‚¹tï¼Œé—®ä½ æœ€å¤šèƒ½æœ‰å¤šå°‘æ°´èƒ½å¤Ÿåˆ°è¾¾tç‚¹ã€‚ åœ¨åˆšé¢å¯¹è¿™ä¸ªé—®é¢˜æ—¶ï¼Œä½ æˆ–è®¸ä¼šæœ‰è¿™æ ·çš„æ€è·¯ï¼š å…ˆä»så¾€ç›¸é‚»ç‚¹æ‹¼å‘½çŒæ°´ï¼Œç„¶åè®©æ°´ä¸åœåœ°å‘tæµï¼Œèƒ½æµå¤šå°‘æ˜¯å¤šå°‘ã€‚ è¿™å°±æ˜¯é¢„æµæ¨è¿›ï¼šèƒ½æ¨æµï¼Œå°±æ¨æµï¼Œæœ€ç»ˆtæœ‰å¤šå°‘æ°´ï¼Œæœ€å¤§æµå°±æ˜¯å¤šå°‘ã€‚ é¢„æµæ¨è¿›ç®—æ³•çš„æ€æƒ³ï¼šåœ¨è®²æ€æƒ³ä¹‹å‰ï¼Œå…ˆå¼•å…¥ä¸€ä¸ªæ¦‚å¿µï¼š ä½™æµï¼š å¬åå­—å°±çŸ¥é“æ˜¯ä»€ä¹ˆæ„æ€äº†ï¼Œå³æ¯ä¸ªç‚¹å½“å‰æœ‰å¤šå°‘æ°´ã€‚ é¢„ç•™æ¨è¿›ç®—æ³•çš„æ€æƒ³æ˜¯ï¼š 1.å…ˆå‡è£…sæœ‰æ— é™å¤šçš„æ°´(ä½™æµ)ï¼Œä»så‘å‘¨å›´ç‚¹æ¨æµï¼ˆæŠŠè¯¥ç‚¹çš„ä½™æµæ¨ç»™å‘¨å›´ç‚¹ï¼Œæ³¨æ„ï¼šæ¨çš„æµé‡ä¸èƒ½è¶…è¿‡è¾¹çš„å®¹é‡ä¹Ÿä¸èƒ½è¶…è¿‡è¯¥ç‚¹ä½™æµï¼‰ï¼Œå¹¶è®©å‘¨å›´ç‚¹å…¥é˜Ÿï¼ˆ æ³¨æ„ï¼šså’Œtä¸èƒ½å…¥é˜Ÿ ï¼‰ 2.ä¸æ–­åœ°å–é˜Ÿé¦–å…ƒç´ ï¼Œå¯¹é˜Ÿé¦–å…ƒç´ æ¨æµ 3.é˜Ÿåˆ—ä¸ºç©ºæ—¶ç»“æŸç®—æ³•ï¼Œtç‚¹çš„ä½™æµå³ä¸ºæœ€å¤§æµã€‚ ä¸Šè¿°æ€è·¯æ˜¯ä¸æ˜¯çœ‹èµ·æ¥å¾ˆç®€å•ï¼Œä¹Ÿæ„Ÿè§‰æ˜¯å®Œå…¨æ­£ç¡®çš„ï¼Ÿ ä½†æ˜¯è¿™ä¸ªæ€è·¯æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯å¯èƒ½ä¼šå‡ºç°ä¸¤ä¸ªç‚¹ä¸åœåœ°æ¥å›æ¨æµçš„æƒ…å†µï¼Œä¸€ç›´æ¨åˆ°TLEã€‚ æ€ä¹ˆè§£å†³è¿™ä¸ªé—®é¢˜å‘¢ï¼Ÿ ç»™æ¯ä¸ªç‚¹ä¸€ä¸ªé«˜åº¦ï¼Œæ°´åªä¼šä»é«˜å¤„å¾€ä½å¤„æµã€‚åœ¨ç®—æ³•è¿è¡Œæ—¶ï¼Œ ä¸æ–­åœ°å¯¹æœ‰ä½™æµçš„ç‚¹æ›´æ”¹é«˜åº¦ ï¼Œç›´åˆ°è¿™äº›ç‚¹å…¨éƒ¨æ²¡æœ‰ä½™æµä¸ºæ­¢ã€‚ ä¸ºä»€ä¹ˆè¿™æ ·å°±ä¸ä¼šå‡ºç°æ¥å›æ¨æµçš„æƒ…å†µäº†å‘¢ï¼Ÿ å½“ä¸¤ä¸ªç‚¹å¼€å§‹æ¥å›æ¨æµæ—¶ï¼Œå®ƒä»¬çš„é«˜åº¦ä¼šä¸æ–­ä¸Šå‡ï¼Œå½“å®ƒä»¬çš„é«˜åº¦å¤§äºsæ—¶ï¼Œä¼šæŠŠä½™æµè¿˜ç»™sã€‚ æ‰€ä»¥åœ¨å¼€å§‹é¢„æµæ¨è¿›å‰è¦å…ˆæŠŠsçš„é«˜åº¦æ”¹ä¸ºnï¼ˆç‚¹æ•°ï¼‰ï¼Œå…å¾—ä¸€å¼€å§‹så‘¨å›´é‚£äº›ç‚¹å°±æ€¥ç€æŠŠä½™æµè¿˜ç»™sã€‚ å…ˆç”¨å›¾è§£æ¥è¡¨ç¤ºç®—æ³•çš„è¿è¡Œè¿‡ç¨‹ï¼šä»¥ä¸‹å›¾ä¸ºä¾‹ï¼ˆåå‘è¾¹æ²¡ç”»å‡ºæ¥ï¼‰ æˆ‘ä»¬ç”¨æ·±è“è‰²çš„å­—è¡¨ç¤ºæ¯ä¸ªç‚¹çš„ä½™æµï¼Œç”¨æ·¡è“è‰²çš„å­—è¡¨ç¤ºæ¯ä¸ªç‚¹çš„é«˜åº¦ã€‚ åˆšå¼€å§‹è‚¯å®šæ˜¯ï¼š æˆ‘ä»¬æŠŠsç‚¹çš„é«˜åº¦æ”¹æˆ6ï¼ˆä¸€å…±6ä¸ªç‚¹ï¼‰ ç„¶åä»å¾€sæ‹¼å‘½åœ°çŒæ°´ï¼Œæ°´æµä¼šé¡ºç€è¿˜æ²¡æ»¡çš„è¾¹å‘å‘¨å›´çš„èŠ‚ç‚¹æµ æ­¤æ—¶1,3èŠ‚ç‚¹è¿˜æœ‰ä½™æµï¼Œäºæ˜¯æ›´æ–°1,3å·ç‚¹é«˜åº¦ï¼Œæ›´æ–°ä¸ºä¸å®ƒç›¸é‚»ä¸”æœ€ä½çš„ç‚¹çš„é«˜åº¦+1ã€‚ æ­¤æ—¶æˆ‘ä»¬å¯¹1å·èŠ‚ç‚¹æ¨æµã€‚ æ›´æ–°æœ‰ä½™æµçš„1,2å·èŠ‚ç‚¹çš„é«˜åº¦ ä¸ºä»€ä¹ˆ1çš„é«˜åº¦å˜æˆäº†7å‘¢ï¼Ÿå› ä¸º1ä¸sæœ‰åå‘è¾¹ï¼Œå› ä¸ºåˆšæ‰æ¨è¿‡æµï¼Œåå‘è¾¹æœ‰äº†è¾¹æƒï¼Œä¸1è¿é€šçš„æœ€ä½çš„ç‚¹å°±æ˜¯sã€‚ ç„¶åæ˜¯å¯¹3èŠ‚ç‚¹æ¨æµï¼ˆæ›´æ–°é«˜åº¦æ˜¯åŒæ—¶è¿›è¡Œçš„åªæ˜¯åˆšæ‰ä¸ºäº†ä¾¿äºç†è§£è€Œåˆ†å¼€ç”»äº†ï¼‰ ç„¶åæ˜¯2å·ç‚¹æ¨æµï¼Œæ³¨æ„tç‚¹ä¸èƒ½æ›´æ–°é«˜åº¦ï¼ˆå¦åˆ™å¥½ä¸å®¹æ˜“æµè¿‡å»çš„æ°´å°±ä¼šå¾€å›æµäº†ï¼‰ 4å·ç‚¹æ¨æµ 2å·ç‚¹æ¨æµ 3å·ç‚¹æ¨æµ é™¤äº†så’Œtä»¥å¤–ï¼Œæ‰€æœ‰èŠ‚ç‚¹éƒ½æ— ä½™æµï¼Œç®—æ³•ç»“æŸï¼Œæœ€å¤§æµå°±æ˜¯tçš„ä½™æµã€‚ å®Œæ•´ä»£ç : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// luogu-judger-enable-o2//æ•ˆç‡ç›¸å½“ä½ï¼Œå¸æ°§æ°”éƒ½è¿‡ä¸äº†æ¨¡æ¿#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int inf=1&lt;&lt;30;;int n,m,s,t;struct Node&#123; int v; int val; int next;&#125;node[205202];int top=1;int inque[13000];int head[13000];int h[13000];int e[13000];//æ¯ä¸ªç‚¹çš„é«˜åº¦ï¼Œæ¯ä¸ªç‚¹çš„å‰©ä½™ï¼ˆå¤šä½™ï¼‰æµé‡inline int Read()&#123; int x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;//è¯»å…¥ä¼˜åŒ– inline int min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline void addedge(int u,int v,int val)&#123; node[++top].v=v; node[top].val=val; node[top].next=head[u]; head[u]=top;&#125;inline void add(int u,int v,int val)&#123; addedge(u,v,val); addedge(v,u,0);&#125;int maxflow;inline void push_(int u,int i)&#123; int mi=min(e[u],node[i].val); node[i].val-=mi; node[i^1].val+=mi; e[u]-=mi; e[node[i].v]+=mi;&#125;//ä»uåˆ°væ¨æµ,iä¸ºuä¸vç›¸è¿çš„é‚£ä¸€æ¡è¾¹çš„ç¼–å· inline bool relabel(int u)&#123; int mh=inf; register int i; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val)&#123; mh=min(mh,h[d]); &#125; &#125; if(mh==inf)return 0;//æ— å¯ä»¥æµçš„è·¯å¾„ h[u]=mh+1;//æŠŠuç‚¹æ‹‰åˆ°å¯æµç‚¹ä»¥ä¸Šï¼ˆä½¿æ°´æµèƒ½ä»uæµå‘å‘¨å›´çš„ç‚¹ï¼‰ return 1; &#125;//åˆ¤æ–­ç‚¹uæ˜¯å¦èƒ½æµå‘å‘¨å›´ç‚¹int push_relabel()&#123; queue&lt;int&gt;q; h[s]=n;//æŠŠæºç‚¹çš„é«˜åº¦è®¾æˆnï¼ˆå›¾ä¸­çš„ç‚¹æ•°ï¼‰ for(register int i=head[s];i;i=node[i].next)&#123; int d=node[i].v; int val=node[i].val; if(val)&#123; node[i].val-=val; node[i^1].val+=val; e[s]-=val; e[d]+=val; if(inque[d]==0&amp;&amp;d!=t&amp;&amp;d!=s&amp;&amp;relabel(d))&#123; q.push(d); inque[d]=1; &#125; &#125;//ç»™æ‰€æœ‰ä¸sç›¸è¿çš„ç‚¹æ¨å…¥æ»¡æµ &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); inque[u]=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(e[u]==0)break; if(node[i].val==0)continue; if(h[u]==h[d]+1) push_(u,i); if(e[d]!=0&amp;&amp;d!=t&amp;&amp;d!=s)&#123; if(inque[d]==0&amp;&amp;relabel(d))&#123; q.push(d); inque[d]=1; &#125; &#125; &#125; if(e[u]&amp;&amp;inque[u]==0&amp;&amp;relabel(u))&#123; q.push(u); inque[u]=1; &#125; &#125; return e[t];&#125;//push_relabelint main()&#123; n=Read(),m=Read(),s=Read(),t=Read(); register int i; int u,v,val; for(i=1;i&lt;=m;i++)u=Read(),v=Read(),val=Read(),add(u,v,val); printf("%d",push_relabel()); return 0;&#125; è¿™ä¸ªé¢„æµæ¨è¿›ç®—æ³•ç›¸å½“æ…¢ï¼Œè‡³äºP4722 ã€æ¨¡æ¿ã€‘æœ€å¤§æµ åŠ å¼ºç‰ˆ / é¢„æµæ¨è¿›ï¼ˆæ¯’ç˜¤é¢˜ï¼‰æ›´æ²¡å¸Œæœ›ã€‚ é‚£ä¸ºä»€ä¹ˆè¿™ä¹ˆæ…¢ï¼Œæˆ‘ä»¬è¿˜è¦å­¦å‘¢ï¼Ÿ ä¸ºäº†ä¸‹é¢çš„è®²è§£åšé“ºå«ã€‚ æœ€é«˜æ ‡å·é¢„æµæ¨è¿›ï¼ˆHLPPï¼‰ç®—æ³•æ­¥éª¤ï¼š 1.å…ˆä»tåˆ°såå‘bfsï¼Œä½¿æ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªåˆå§‹é«˜åº¦ 2.ä»så¼€å§‹å‘å¤–æ¨æµï¼Œå°†æœ‰ä½™æµçš„ç‚¹æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ— 3.ä¸æ–­ä»ä¼˜å…ˆé˜Ÿåˆ—é‡Œå–å‡ºé«˜åº¦æœ€é«˜çš„ç‚¹è¿›è¡Œæ¨æµæ“ä½œ 4.è‹¥æ¨å®Œè¿˜æœ‰ä½™æµï¼Œæ›´æ–°é«˜åº¦æ ‡å·ï¼Œé‡æ–°æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ— 5.å½“ä¼˜å…ˆé˜Ÿåˆ—ä¸ºç©ºæ—¶ç»“æŸç®—æ³•ï¼Œæœ€å¤§æµå³ä¸ºtçš„ä½™æµ ä¸åŸºç¡€çš„ä½™æµæ¨è¿›ç›¸æ¯”çš„ä¼˜åŠ¿ï¼š é€šè¿‡bfsé¢„å…ˆå¤„ç†äº†é«˜åº¦æ ‡å·ï¼Œå¹¶åˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆé—²ç€æ²¡äº‹å¯ä»¥æ‰‹å†™å †ï¼‰ä½¿å¾—æ¯æ¬¡æ¨æµéƒ½æ˜¯é«˜åº¦æœ€é«˜çš„é¡¶ç‚¹ï¼Œä»¥æ­¤å‡å°‘æ¨æµçš„æ¬¡æ•°å’Œé‡æ ‡å·çš„æ¬¡æ•°ã€‚ ä¼˜åŒ–ï¼š å’ŒISAPä¸€æ ·çš„gapä¼˜åŒ–ï¼Œå¦‚æœæŸä¸ªé«˜åº¦ä¸å­˜åœ¨ï¼Œå°†æ‰€æœ‰æ¯”è¯¥é«˜åº¦é«˜çš„èŠ‚ç‚¹æ ‡è®°ä¸ºä¸å¯åˆ°è¾¾ï¼ˆä½¿å®ƒçš„é«˜åº¦ä¸ºn+1ï¼Œè¿™æ ·å°±ä¼šç›´æ¥å‘sæ¨æµäº†ï¼‰ã€‚ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;inline int Read()&#123; int x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;const int inf=1&lt;&lt;30;int top=1,head[10100];int n,m,s,t;int e[10100],h[10100],cnth[20100];//æ¯ä¸ªç‚¹å¯¹åº”çš„ä½™æµï¼Œé«˜åº¦ï¼›æ¯ä¸ªé«˜åº¦æœ‰å¤šå°‘ä¸ªç‚¹ struct cmp&#123; inline bool operator () (int a,int b) const&#123; return h[a]&lt;h[b]; &#125;&#125;;struct Node&#123; int v; int val; int next;&#125;node[400100];inline void addedge(int u,int v,int val)&#123; node[++top].v=v; node[top].val=val; node[top].next=head[u]; head[u]=top;&#125;inline void add(int u,int v,int val)&#123; addedge(u,v,val); addedge(v,u,0);&#125;int inque[11000];void bfs()&#123; memset(h,0x3f,sizeof(h)); h[t]=0; queue&lt;int&gt;qu; qu.push(t); while(!qu.empty())&#123; int u=qu.front(); qu.pop(); inque[u]=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i^1].val&amp;&amp;h[d]&gt;h[u]+1)&#123;//åå‘è·‘ h[d]=h[u]+1; if(inque[d]==0)&#123; qu.push(d); inque[d]=1; &#125; &#125; &#125; &#125; return;&#125;priority_queue&lt;int,vector&lt;int&gt;,cmp&gt;q;inline void push_(int u)&#123; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;h[d]+1==h[u])&#123;//å¯ä»¥æ¨æµ int mi=min(node[i].val,e[u]); node[i].val-=mi; node[i^1].val+=mi; e[u]-=mi; e[d]+=mi; if(inque[d]==0&amp;&amp;d!=t&amp;&amp;d!=s)&#123; q.push(d); inque[d]=1; &#125; if(e[u]==0)break;//å·²ç»æ¨å®Œäº† &#125; &#125;&#125;//æ¨æµ inline void relabel(int u)&#123; h[u]=inf; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;h[d]+1&lt;h[u])&#123; h[u]=h[d]+1; &#125; &#125;&#125;//æŠŠuçš„é«˜åº¦æ›´æ”¹ä¸ºä¸uç›¸é‚»çš„æœ€ä½çš„ç‚¹çš„é«˜åº¦åŠ 1 int hlpp()&#123; register int i; bfs(); if(h[s]==0x3f3f3f3f)return 0;//sä¸tä¸è¿é€š h[s]=n; for(i=1;i&lt;=n;i++)if(h[i]&lt;0x3f3f3f3f)cnth[h[i]]++;//ç»Ÿè®¡å„ä¸ªé«˜åº¦çš„ç‚¹æ•°ï¼Œæ³¨æ„ä¸è¦è®©ä¸‹æ ‡è¶Šç•Œ for(i=head[s];i;i=node[i].next)&#123; int d=node[i].v; int mi=node[i].val; if(mi)&#123; e[s]-=mi; e[d]+=mi; node[i].val-=mi; node[i^1].val+=mi; if(d!=t&amp;&amp;inque[d]==0&amp;&amp;d!=s)&#123; q.push(d); inque[d]=1; &#125; &#125; &#125;//ä»så‘å‘¨å›´ç‚¹æ¨æµ while(!q.empty())&#123; int u=q.top(); inque[u]=0; q.pop(); push_(u); if(e[u])&#123;//è¿˜æœ‰ä½™æµ cnth[h[u]]--; if(cnth[h[u]]==0)&#123; for(int i=1;i&lt;=n;i++)&#123; if(i!=s&amp;&amp;i!=t&amp;&amp;h[i]&gt;h[u]&amp;&amp;h[i]&lt;n+1)&#123; h[i]=n+1;//æ ‡è®°æ— æ³•åˆ°è¾¾ &#125; &#125; &#125;//gapä¼˜åŒ– relabel(u); cnth[h[u]]++; q.push(u); inque[u]=1; &#125; &#125; return e[t];&#125; int main()&#123; n=Read(),m=Read(),s=Read(),t=Read(); register int i; int u,v,val; for(i=1;i&lt;=m;i++)u=Read(),v=Read(),val=Read(),add(u,v,val); printf("%d",hlpp()); return 0;&#125; è¿™æ¬¡ç»ˆäºå¯ä»¥è¿‡æ‰é‚£é“æ¯’ç˜¤é¢˜äº†ã€‚ æ€»ç»“ï¼šISAPçš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n^2m),è€ŒHLPPçš„æ—¶é—´å¤æ‚åº¦O(n^2sqrt(m)),ä½†ç”±äºHLPPå¸¸æ•°è¿‡å¤§ï¼Œåœ¨çº¯éšæœºæ•°æ®ï¼ˆæ¨¡æ¿é¢˜ï¼‰ä¸‹è·‘å¾—è¿˜æ²¡æœ‰ISAPå¿«ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œç”¨ISAPå°±å¤Ÿäº†ã€‚ æœ€åæ„Ÿè°¢é’±é€¸å‡¡å¤§ä½¬çš„ç»éªŒå…±äº«QWQ]]></content>
      <categories>
        <category>æ›´å¤šä¼˜ç§€çš„ç®—æ³•</category>
      </categories>
      <tags>
        <tag>Magical Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Grand Contest#016 F.Games on DAG]]></title>
    <url>%2F2019%2F02%2F14%2FAtcoder-Grand-Contest-016-F-Games-on-DAG%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜G.Games on DAGé¢˜é¢There is a directed graph $G$ with $N$ vertices and $M$ edges. The vertices are numbered $1$ through $M$. Edge $i$ is directed from $x_i$ to $y_i$ holds. Alse, there are no multiple edges in $G$. Consider selecting a subset of the set of the $M$ edges in $G$, and removing these edges from $G$ to obtain another graph $Gâ€™$. There are $2^M$ different possible graphs as $Gâ€™$. Alice and Bob play against each other in the following game played on $Gâ€™$. First, place two pieces on vertices $1$ and $2$, one on each. Then, starting from Alice, Alice and Bob alternately perform the following operation: Select an edge $i$ such that there is a piece placed on vertex $x_i$, and move the piece to vertex $y_i$(if there are two pieces on vertex $x_i$, only move one). The two pieces are allowed to be placed on the same vertex. The player loses when he(or she) becomes unable to perform the operation. We assume that both players play optimally. Among the $2^M$ different possible graphs as $Gâ€™$, how many lead to Aliceâ€™s victory? Find the count modulo $10^9+7$.]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#254 C.DZY Loves Colors]]></title>
    <url>%2F2019%2F02%2F14%2FCodeForces-254-C-DZY-Loves-Colors%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜F.DZY Loves Colorsé¢˜é¢$DZY$ loves colors, and he enjoys painting. On a colorful day, $DZY$ gets a colorful ribbon, which consists of $n$ units (they are numbered from $1$ to $n$ from left to right). The color of the $i$-th unit of the ribbon is $i$ at first. It is colorful enough, but we still consider that the colorfulness of each unit is $0â€‹$ at first. $DZY$ loves painting, we know. He takes up a paintbrush with color $x$ and uses it to draw a line on the ribbon. In such a case some contiguous units are painted. Imagine that the color of unit $i$ currently is $y$. When it is painted by this paintbrush, the color of the unit becomes $x$, and the colorfulness of the unit increases by $|x - y|$. $DZY$ wants to perform $m$ operations, each operation can be one of the following: Paint all the units with numbers between $l$ and $r$ (both inclusive) with color $x$. Ask the sum of colorfulness of the units between $l$ and $râ€‹$ (both inclusive). Can you help $DZY$? ç®€è¦ç¿»è¯‘$DZY$å–œæ¬¢è‰²å½©ï¼Œä»–çƒ­çˆ±ç»˜ç”»ã€‚ åœ¨ä¸€ä¸ªå¤šå§¿å¤šå½©çš„æ—¥å­é‡Œï¼Œ$DZY$å¾—åˆ°äº†ä¸€ä¸ªå½©è‰²çš„ç¼å¸¦ï¼Œå®ƒç”±$N$ä¸ªå•å…ƒç»„æˆï¼ˆä»å·¦åˆ°å³ä»$1$åˆ°$n$ç¼–å·ï¼‰ã€‚è‰²å¸¦çš„ç¬¬$i$ä¸ªå•ä½çš„æœ€åˆé¢œè‰²æ˜¯$i$ã€‚è™½ç„¶é¢œè‰²è¶³å¤Ÿä¸°å¯Œï¼Œä½†æˆ‘ä»¬ä»ç„¶è®¤ä¸ºæ¯ä¸ªå•å…ƒçš„é¢œè‰²æ•°é‡æœ€åˆæ˜¯$0$ã€‚ $DZY$çƒ­è¡·äºç»˜ç”»ï¼Œæˆ‘ä»¬çŸ¥é“ã€‚ä»–æ‹¿èµ·ä¸€æŠŠå½©è‰²$X$ç¬”ï¼Œç”¨å®ƒåœ¨ç¼å¸¦ä¸Šç”»ä¸€æ¡çº¿ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä»–å°±ç»˜åˆ¶äº†ä¸€æ®µè¿ç»­çš„å•å…ƒã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œå•ä½$i$è¢«æ¶‚ä¹‹å‰é¢œè‰²æ˜¯$Y$ã€‚è¢«æ¶‚ä¹‹åæ—¶ï¼Œå•å…ƒçš„é¢œè‰²å˜ä¸º$X$ï¼Œä»¤å•ä½çš„é¢œè‰²å¢åŠ äº† $âˆ£Xâˆ’Yâˆ£$ã€‚ $DZY$æƒ³è¦æ‰§è¡Œ$M$ä¸ªæ“ä½œï¼Œæ¯ä¸ªæ“ä½œå¯ä»¥æ˜¯ä¸‹åˆ—æ“ä½œä¹‹ä¸€ï¼š $1$ã€å°†åŒºé—´ [$L,R$] å†…å•å…ƒç»˜åˆ¶ä¸ºé¢œè‰²$X$ã€‚ $2$ã€è¯¢é—® [$L,R$] ä¹‹é—´çš„å•ä½é¢œè‰²çš„æ€»å’Œï¼ˆåŒ…æ‹¬ä¸¤è€…ï¼‰ã€‚ ä½ èƒ½å¸®åŠ©$DZY$å—ï¼Ÿ Inputç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•°$n,m$ã€‚ ä¸‹é¢$m$è¡Œä¸­æ¯ä¸€è¡Œä»¥ä¸€ä¸ªæ•´æ•°$type$å¼€å¤´ï¼Œè¡¨ç¤ºæ“ä½œç±»å‹ã€‚ è‹¥$type=1$ï¼Œé‚£ä¹ˆè¯¥è¡Œæ¥ä¸‹æ¥æœ‰3ä¸ªæ•´æ•°$L,R,X$ï¼Œæè¿°æ“ä½œ$1$ï¼› è‹¥$type=2$ï¼Œé‚£ä¹ˆè¯¥è¡Œæ¥ä¸‹æ¥æœ‰2ä¸ªæ•´æ•°$L,R$ï¼Œæè¿°æ“ä½œ$2$ã€‚ Outputå¯¹äºæ¯ä¸ªæ“ä½œ$2$ï¼Œè¾“å‡ºä¸€è¡Œï¼ŒåŒ…å«ç€è‰²æ•°é‡ä¹‹å’Œã€‚ Sample Input 13 31 1 2 41 2 3 52 1 3 Sample Output 18 Sample Input 23 41 1 3 42 1 12 2 22 3 3 Sample Output 23 2 1 Sample Input 310 61 1 5 31 2 7 91 10 10 111 3 8 121 1 10 32 1 10 Sample Output 3129 Hint$1\leq n,m,\leq 10^5$ $1\leq type\leq 2$ $1\leq l\leq r\leq n$ï¼Œ$1\leq x\leq 10^8$ã€‚ æœ¬é¢˜çš„é¢˜æ„éå¸¸çš„æ˜äº†ï¼Œä¸€å¼€å§‹çš„$a[i]=i,b[i]=0$ï¼Œä½¿åŒºé—´ $[l,r]$çš„$b[i]+=|x-a[i]|$ï¼Œ$a[i]=x$ï¼Œå¹¶æŸ¥è¯¢ $[l,r]$ çš„$b[i]$å’Œã€‚ æˆ‘ä»¬ç”¨ä¸€ä¸ªçº¿æ®µæ ‘å°±å¯ä»¥å¾ˆå®¹æ˜“åœ°ç»´æŠ¤ä»–ä»¬äº†ã€‚ ä¸å¤šè¯´ï¼Œç›´æ¥ä¸Šä»£ç å§ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N=500010;struct seg_tree&#123; long long lazy,s,flag;&#125;t[N&lt;&lt;2];int n,m;void build(int root,int l,int r)&#123; if(l==r) &#123; t[root].flag=l; return; &#125; int mid=l+r&gt;&gt;1; build(root&lt;&lt;1,l,mid); build(root&lt;&lt;1|1,mid+1,r); // pushup(root);&#125;long long query(int root,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) return t[root].s; int mid=l+r&gt;&gt;1; long long ans=0; if(ll&lt;=mid) ans+=query(root&lt;&lt;1,l,mid,ll,rr); if(rr&gt;mid) ans+=query(root&lt;&lt;1|1,mid+1,r,ll,rr); return ans+max(0,min(r,rr)-max(l,ll)+1)*t[root].lazy;&#125;void empty(int root,int l,int r,int s)&#123; if(t[root].flag) &#123; t[root].lazy+=abs(t[root].flag-s); t[root].s+=abs(t[root].flag-s)*(r-l+1); t[root].flag=0; return; &#125; if(l==r) return; int mid=l+r&gt;&gt;1; empty(root&lt;&lt;1,l,mid,s); empty(root&lt;&lt;1|1,mid+1,r,s); t[root].s=t[root&lt;&lt;1].s+t[root&lt;&lt;1|1].s+t[root].lazy*(r-l+1);&#125;void pushdown(int root)&#123; if(!t[root].flag) return; t[root&lt;&lt;1].flag=t[root&lt;&lt;1|1].flag=t[root].flag; t[root].flag=0;&#125;void change(int root,int l,int r,int ll,int rr,int s)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123; empty(root,l,r,s); t[root].flag=s; return; &#125; int mid=l+r&gt;&gt;1; pushdown(root); if(ll&lt;=mid) change(root&lt;&lt;1,l,mid,ll,rr,s); if(rr&gt;mid) change(root&lt;&lt;1|1,mid+1,r,ll,rr,s); t[root].s=t[root&lt;&lt;1].s+t[root&lt;&lt;1|1].s+t[root].lazy*(r-l+1);&#125;int main(int argc, char const *argv[])&#123; n=read(),m=read(); build(1,1,n); while(m--) &#123; int type=read(); if(type==1) &#123; int l=read(),r=read(),x=read(); change(1,1,n,l,r,x); &#125; else &#123; int l=read(),r=read(); printf("%lld\n",query(1,1,n,l,r)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#271 F.Ant Colony]]></title>
    <url>%2F2019%2F02%2F14%2FCodeForces-271-F-Ant-Colony%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜D.Ant Colonyé¢˜é¢Mole is hungry again. He found one ant colony, consisting of $n$ ants, ordered in a row. Each ant $i$ ($1\leq i\leq n$) has a strength $s_i$. In order to make his dinner more interesting, Mole organizes a version of Â«Hunger GamesÂ» for the ants. He chooses two numbers $l$ and $r$ ($1\leq l\leq r\leq n$) and each pair of ants with indices between $l$ and $r$ (inclusively) will fight. When two ants $i$ and $j$ fight, ant $s_i$ gets one battle point only if $s_i$ divides $s_j$ (also, ant $j$ gets one battle point only if $s_j$ divides $s_i$). After all fights have been finished, Mole makes the ranking. An ant $iâ€‹$, with $v_iâ€‹$ battle points obtained, is going to be freed only if $v_i=r-lâ€‹$, or in other words only if it took a point in every fight it participated. After that, Mole eats the rest of the ants. Note that there can be many ants freed or even none. In order to choose the best sequence, Mole gives you $t$ segments $[l_i,r_i]$ and asks for each of them how many ants is he going to eat if those ants fight. ç®€è¦ç¿»è¯‘ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º$ğ‘›$çš„åºåˆ—ï¼Œ$ğ‘$ä¸ªè¯¢é—®ã€‚ æ¯æ¬¡ç»™å®šåŒºé—´$ ğ‘™,ğ‘Ÿ $ï¼Œå°†$ ğ‘™,ğ‘Ÿ $ä¸­æ‰€æœ‰æ•°ä¸¤ä¸¤æ¯”è¾ƒã€‚ å¦‚æœ$ğ‘,ğ‘ âˆˆ ğ‘™,ğ‘Ÿ $ï¼Œ$ğ‘|ğ‘$åˆ™$ğ‘$å¾—ä¸€åˆ†ï¼Œ$ğ‘|ğ‘$åˆ™$ğ‘$å¾—ä¸€åˆ†ã€‚ é—®æœ‰å¤šå°‘ä¸ªæ•°æ²¡æœ‰å¾—åˆ°æ»¡åˆ†ã€‚ Inputç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°$n$ï¼Œä»£è¡¨åºåˆ—çš„å¤§å°ã€‚ ç¬¬äºŒè¡ŒåŒ…å«$n$ä¸ªæ•´æ•°ï¼Œ$s_1,s_2,s_3â€¦s_n$ï¼Œä»£è¡¨åºåˆ—çš„å€¼ã€‚ ç¬¬ä¸‰è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°$t$ï¼Œä»£è¡¨è¯¢é—®ä¸ªæ•°ã€‚ ä¸‹é¢æœ‰$t$è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•°$l_i,r_i$æè¿°ä¸€ä¸ªè¯¢é—®ã€‚ Outputè¾“å‡ºåŒ…å«$t$è¡Œã€‚ ç¬¬$i$è¡Œè¾“å‡ºä¸€ä¸ªæ•°è¡¨ç¤º $[l_i,r_i]$ ä¸­çš„æ²¡æœ‰æ»¡åˆ†çš„æ•°çš„ä¸ªæ•°ã€‚ Sample Input5 1 3 2 4 2 4 1 5 2 5 3 5 4 5 Sample Output4 4 1 1 Note || ï¼ˆæœ¬æ¥æƒ³æ¬æ ·ä¾‹è§£é‡Šçš„ï¼Œä¸è¿‡æ—¢ç„¶æ˜¯é¢˜è§£é‚£å°±ç®—äº†å§ï¼‰ Hint$1\leq n\leq 10^5$ï¼Œ$1\leq s_i\leq 10^9$ã€‚ $1\leq t\leq 10^5$ï¼Œ$1\leq l_i\leq r_i\leq n$ã€‚ æˆ‘ä»¬å¯ä»¥æ¯”è¾ƒæ˜¾ç„¶çš„çŸ¥é“ï¼Œèƒ½ç•™ä¸‹çš„æ•°ä¸€å®šæ˜¯åŒºé—´çš„æœ€å°$gcd$ï¼Œäºæ˜¯æˆ‘ä»¬å°±åªè¦æ‰¾åŒºé—´å†…ä¸åŒºé—´æœ€å°$gcd$ç›¸ç­‰çš„æ•°çš„ä¸ªæ•°ã€‚ åŒºé—´æœ€å°$gcd$ä¸€å®šå°äºç­‰äºåŒºé—´$min$ï¼Œæˆ‘ä»¬åªè¦åˆ¤æ–­æœ€å°å€¼æ˜¯å¦æ˜¯åŒºé—´æœ€å°$gcd$ï¼Œå¦‚æœæ˜¯ï¼Œå°±å¯ä»¥æ±‚å‡ºæœ€å°å€¼çš„ä¸ªæ•°ï¼Œä¹Ÿå°±èƒ½æ±‚å‡ºç­”æ¡ˆäº†ã€‚ æ ¹æ®æ•°æ®èŒƒå›´å’Œè¦æ±‚ç»´æŠ¤çš„æ•°æ®ï¼Œæˆ‘ä»¬å°è¯•ç”¨çº¿æ®µæ ‘æ¥ç»´æŠ¤ã€‚ åˆ†åˆ«ç»´æŠ¤$gcd$ï¼ŒåŒºé—´$min$ï¼Œä»¥åŠåŒºé—´$min$çš„ä¸ªæ•°ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N=100010;struct seg_tree&#123; int min,gcd,cnt;&#125;t[N&lt;&lt;2];int a[N];int n,m;int minA,gcdA,cntA;int gcd(int a,int b)&#123; return !b? a:gcd(b,a%b);&#125;void pushup(int root)&#123; t[root].min=min(t[root&lt;&lt;1].min,t[root&lt;&lt;1|1].min); t[root].gcd=gcd(t[root&lt;&lt;1].gcd,t[root&lt;&lt;1|1].gcd); if(t[root&lt;&lt;1].min==t[root&lt;&lt;1|1].min) t[root].cnt=t[root&lt;&lt;1].cnt+t[root&lt;&lt;1|1].cnt; else if(t[root&lt;&lt;1].min&gt;t[root&lt;&lt;1|1].min) t[root].cnt=t[root&lt;&lt;1|1].cnt; else t[root].cnt=t[root&lt;&lt;1].cnt;&#125;void build(int root,int l,int r)&#123; if(l==r) &#123; t[root].min=t[root].gcd=a[l]; t[root].cnt=1; return; &#125; int mid=l+r&gt;&gt;1; build(root&lt;&lt;1,l,mid); build(root&lt;&lt;1|1,mid+1,r); pushup(root);&#125;void query(int root,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123; gcdA=gcd(gcdA,t[root].gcd); if(minA==t[root].min) cntA+=t[root].cnt; else if(minA&gt;t[root].min) cntA=t[root].cnt,minA=t[root].min; return; &#125; int mid=l+r&gt;&gt;1; if(ll&lt;=mid) query(root&lt;&lt;1,l,mid,ll,rr); if(rr&gt;mid) query(root&lt;&lt;1|1,mid+1,r,ll,rr);&#125;int main(int argc, char const *argv[])&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); build(1,1,n); // cout&lt;&lt;"YES"&lt;&lt;endl; m=read(); while(m--) &#123; int l=read(),r=read(); minA=1000000001; gcdA=cntA=0; query(1,1,n,l,r); if(gcdA==minA) printf("%d\n",r-l+1-cntA); else printf("%d\n",r-l+1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[image]]></title>
    <url>%2F2019%2F02%2F14%2Fimage%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Photo Collection</category>
      </categories>
      <tags>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[èšç¾¤ç®—æ³•(Ant Colony)]]></title>
    <url>%2F2019%2F02%2F14%2F%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©ï¼Œæˆ‘åœ¨ç½‘ä¸Šç¿»åˆ°ä¸€ä¸ªç¥å¥‡çš„ç®—æ³•èšç¾¤ç®—æ³•ï¼æŸå¤§ä½¬çš„blogï¼šhttps://blog.csdn.net/lyxleft/article/details/82980760 è®°å¾—å­¦å“ˆ~]]></content>
      <categories>
        <category>ç©ºé—²æ—¶é—´çš„é›¶ç¢çŸ¥è¯†</category>
      </categories>
      <tags>
        <tag>Magical Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1848 Fibonacci again and again]]></title>
    <url>%2F2019%2F02%2F13%2FHDU-1848-Fibonacci-again-and-again%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜#.Fibonacci again and againé¢˜é¢ ä»»ä½•ä¸€ä¸ªå¤§å­¦ç”Ÿå¯¹è²æ³¢é‚£å¥‘æ•°åˆ—($Fibonacci numbers$)åº”è¯¥éƒ½ä¸ä¼šé™Œç”Ÿï¼Œå®ƒæ˜¯è¿™æ ·å®šä¹‰çš„ï¼š$F(1)=1;$$F(2)=2;$$F(n)=F(n-1)+F(n-2)(n&gt;=3);$æ‰€ä»¥ï¼Œ$1,2,3,5,8,13$â€¦â€¦å°±æ˜¯è²æ³¢é‚£å¥‘æ•°åˆ—ã€‚åœ¨HDOJä¸Šæœ‰ä¸å°‘ç›¸å…³çš„é¢˜ç›®ï¼Œæ¯”å¦‚$1005\ Fibonacci\ again\ and\ again$å°±æ˜¯æ›¾ç»çš„æµ™æ±Ÿçœèµ›é¢˜ã€‚ä»Šå¤©ï¼Œåˆä¸€ä¸ªå…³äº$Fibonacci$çš„é¢˜ç›®å‡ºç°äº†ï¼Œå®ƒæ˜¯ä¸€ä¸ªå°æ¸¸æˆï¼Œå®šä¹‰å¦‚ä¸‹ï¼š1ã€ è¿™æ˜¯ä¸€ä¸ªäºŒäººæ¸¸æˆ;2ã€ ä¸€å…±æœ‰$3$å †çŸ³å­ï¼Œæ•°é‡åˆ†åˆ«æ˜¯$m, n, p$ä¸ªï¼›3ã€ ä¸¤äººè½®æµèµ°;4ã€ æ¯èµ°ä¸€æ­¥å¯ä»¥é€‰æ‹©ä»»æ„ä¸€å †çŸ³å­ï¼Œç„¶åå–èµ°$f$ä¸ªï¼›5ã€ $f$åªèƒ½æ˜¯è²æ³¢é‚£å¥‘æ•°åˆ—ä¸­çš„å…ƒç´ ï¼ˆå³æ¯æ¬¡åªèƒ½å–$\ 1ï¼Œ2ï¼Œ3ï¼Œ5ï¼Œ8$â€¦ç­‰æ•°é‡ï¼‰ï¼›6ã€ æœ€å…ˆå–å…‰æ‰€æœ‰çŸ³å­çš„äººä¸ºèƒœè€…ï¼› å‡è®¾åŒæ–¹éƒ½ä½¿ç”¨æœ€ä¼˜ç­–ç•¥ï¼Œè¯·åˆ¤æ–­å…ˆæ‰‹çš„äººä¼šèµ¢è¿˜æ˜¯åæ‰‹çš„äººä¼šèµ¢ã€‚ Inputè¾“å…¥æ•°æ®åŒ…å«å¤šä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å ä¸€è¡Œï¼ŒåŒ…å«$3â€‹$ä¸ªæ•´æ•°$m,n,pâ€‹$ã€‚$m=n=p=0â€‹$åˆ™è¡¨ç¤ºè¾“å…¥ç»“æŸã€‚ Output å¦‚æœå…ˆæ‰‹çš„äººèƒ½èµ¢ï¼Œè¯·è¾“å‡ºâ€œ$Fibo$â€ï¼Œå¦åˆ™è¯·è¾“å‡ºâ€œ$Nacci$â€ï¼Œæ¯ä¸ªå®ä¾‹çš„è¾“å‡ºå ä¸€è¡Œã€‚ Sample Input1 1 1 1 4 1 0 0 0 Sample OutputFibo Nacci Hint$1\leq m,n,p\leq 1,000$ æ¥è‡ª$ACM\ Short\ Term\ Exam\ 2007/12/13$ (Html Address:http://acm.hdu.edu.cn/search.php?field=problem&amp;key=ACM+Short+Term+Exam_2007%2F12%2F13&amp;source=1&amp;searchmode=source) è¿™é¢˜å•Šï¼ è£¸çš„SGå‡½æ•°å‘€ï¼ æ²¡å­¦è¿‡çš„å¤§ä½¬ä»¬é€›ä¸€æ³¢åšå®¢å§ï¼ ï¼ˆmaybeâ€¦å‡ ä¸‡å¹´ä»¥åæˆ‘ä¹Ÿä¼šå†™ä¸€ç¯‡çš„å§~ï¼‰ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x=0,w=0; char ch=0; while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return w? -x:x;&#125;const int MAXN=1010;int f[MAXN],sg[MAXN];void Fibonacci()&#123; f[1]=1,f[2]=2; for(int i=3;i&lt;=200;++i) &#123; f[i]=f[i-1]+f[i-2]; if(f[i]&gt;1000) break; &#125;&#125;map&lt;int,int&gt; ma;void Build_Map(int lim)&#123; for(int i=1;i&lt;=lim;++i) &#123; ma.clear(); for(int j=1;f[j]&lt;=i;++j) ++ma[sg[i-f[j]]]; for(int j=0;j&lt;=lim;++j) if(!ma[j]) &#123; sg[i]=j; break; &#125; &#125;&#125;int a,b,c;int main()&#123; Fibonacci(); Build_Map(1000); while(1) &#123; a=read(),b=read(),c=read(); if(!a&amp;&amp;!b&amp;&amp;!c) return 0; int sum=0; sum^=sg[a]^sg[b]^sg[c]; if(!sum) puts("Nacci"); else puts("Fibo"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.13-Contest]]></title>
    <url>%2F2019%2F02%2F13%2F2-13-Contest%2F</url>
    <content type="text"><![CDATA[æœ¬è’Ÿè’»è¾ƒæ‡’ï¼Œæƒ³ç›´æ¥è´´pdfçš„å›¾ç‰‡ã€‚ äºæ˜¯ä¸‹è½½äº†ä¸€ä¸ªè½¬åŒ–å™¨ï¼Œç»“æœæœ€åä¸€å¼ è¿˜å¸¦äº†æ°´å°ã€‚ (èƒ½çœ‹å°±è¡Œ)]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2640 Help Me Escape]]></title>
    <url>%2F2019%2F02%2F12%2FZOJ-2640-Help-Me-Excape%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜B.Help Me EscapeèƒŒæ™¯If thou doest well, shalt thou not be accepted? and if thou doest not well, sin lieth at the door. And unto thee shall be his desire, and thou shalt rule over him. And Cain talked with Abel his brother: and it came to pass, when they were in the field, that Cain rose up against Abel his brother, and slew him. And the LORD said unto Cain, Where is Abel thy brother? And he said, I know not: Am I my brotherâ€™s keeper? And he said, What hast thou done? the voice of thy brotherâ€™s blood crieth unto me from the ground. And now art thou cursed from the earth, which hath opened her mouth to receive thy brotherâ€™s blood from thy hand; When thou tillest the ground, it shall not henceforth yield unto thee her strength; a fugitive and a vagabond shalt thou be in the earth. â€‹ $ â€”â€” Bible Chapter 4$ é¢˜é¢ Now Cain is unexpectedly trapped in a cave with N paths. Due to LORDâ€™s punishment, all the paths are zigzag and dangerous. The difficulty of the ith path is ci. Then we define f as the fighting capacity of Cain. Every day, Cain will be sent to one of the N paths randomly. Suppose Cain is in front of the ith path. He can successfully take ti days to escape from the cave as long as his fighting capacity f is larger than ci. Otherwise, he has to keep trying day after day. However, if Cain failed to escape, his fighting capacity would increase ci as the result of actual combat. (A kindly reminder: Cain will never died.) As for ti, we can easily draw a conclusion that ti is closely related to ci. Letâ€™s use the following function to describe their relationship: t_i=\lfloor \frac{1+\sqrt 5}2Ã—c_i^2\rfloor After D days, Cain finally escapes from the cave. Please output the expectation of D. ç®€è¦ç¿»è¯‘æœ‰$n$ä¸ªå¦–æ€ªï¼Œæ¯ä¸ªå¦–æ€ªæœ‰ä¸€ä¸ªæˆ˜æ–—åŠ›$c_j$ã€‚å°Aæœ‰ä¸€ä¸ªåˆå§‹æˆ˜æ–—åŠ›$f_0$ã€‚ æ¯å¤©ï¼Œå°Aéšæœºé€‰æ‹©ä¸€ä¸ªå¦–æ€ªå†³æ–—ã€‚è®¾å°Aåœ¨ç¬¬ğ‘–å¤©çš„æˆ˜æ–—åŠ›ä¸º$f_i$ã€‚ è®¾å½“å‰ä¸ºç¬¬$ğ‘–$å¤©ï¼Œå¦‚æœæ‰“èµ¢ï¼Œå³$ğ‘“_i &gt; ğ‘_j$ï¼Œå°±å¯ä»¥é€ƒå‡ºå»ï¼Œéœ€è¦èŠ±$t_j$å¤©ã€‚ å¦‚æœæ‰“ä¸èµ¢ï¼Œå°Aä¼šè®©è‡ªå·±å˜å¼ºï¼Œ$ğ‘“_{i+1} = ğ‘“_i+ ğ‘_j$ã€‚ æ±‚å°Aé€ƒå‡ºæ¥éœ€è¦çš„æœŸæœ›å¤©æ•°ã€‚ Inputè¾“å…¥åŒ…å«å¤šç»„æ•°æ®ã€‚ æ¯ç»„æ•°æ®åŒ…æ‹¬ä¸¤è¡Œã€‚ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ª$n$å’Œ$f$ï¼Œç¬¬äºŒè¡ŒåŒ…å«$n$ä¸ªæ•´æ•°$c_i$ã€‚ Outputå¯¹äºæ¯ç»„æ•°æ®ä½ è¦è¾“å‡ºæœŸæœ›å€¼ï¼Œä¿ç•™å°æ•°ç‚¹åä¸‰ä½ã€‚ Sample Input3 1 1 2 3 Sample Output6.889 Hint$n\leq 100$ï¼Œ$f\leq 10,000$ï¼Œ$c_i\leq10,000ï¼Œ1\leq i\leq n$ã€‚ ç”¨$f(i)$è¡¨ç¤ºæˆ˜æ–—åŠ›ä¸º$i$æ—¶ï¼Œæ‰€éœ€è¦çš„æœŸæœ›å¤©æ•°ã€‚ é‚£ä¹ˆæœ‰ï¼šè‹¥$i&gt;c_j$ï¼Œåˆ™$f(i)=f(i)+\frac 1n(t_j)$ï¼› è‹¥ï¼ˆ$i\leq c_j$ï¼‰ï¼Œåˆ™$f(i)=f(i)+\frac 1n(f(i+c_j)+1)$ã€‚ ç„¶åè¿›è¡Œè®°å¿†åŒ–æœç´¢ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;struct data&#123; int c, t;&#125;;bool vis[100010];vector&lt;data&gt; vs;int N, F;double dp[100010];double dfs(int f)&#123; if (vis[f]) return dp[f]; vis[f] = 1; double A = 0; for (int i = 0; i &lt; N; ++i) if (vs[i].c &gt;= f) A += (1 + dfs(f + vs[i].c)) / N; else A += 1.0 * vs[i].t / N; return dp[f] = A;&#125;int main()&#123; while (~scanf("%d%d", &amp;N, &amp;F)) &#123; vs.clear(); memset(vis, 0, sizeof(vis)); for (int i = 0, g; i &lt; N; ++i) &#123; g = read(); int p = (1 + sqrt(5)) / 2 * g * g; vs.push_back((data) &#123;g, p&#125;); &#125; printf("%.3lf\n", dfs(F)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2096 Collecting Bugs]]></title>
    <url>%2F2019%2F02%2F12%2Fcollecting-bugs%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜A.Collecting Bugsï¼ˆHtml Address:http://poj.org/problem?id=2096ï¼‰é¢˜é¢Ivan is fond of collecting. Unlike other people who collect post stamps,coins or other material stuff, he collects software bugs. When Ivan gets a new program, he classifies all possible bugs into n categories. Each day he discovers exactly one bug in the program and adds information about it and its category into a spreadsheet. When he finds bugs in all bug categories, he calls the program disgusting, publishes this spreadsheet on his home page, and forgets completely about the program. Two companies, Macrosoft and Microhard are in tight competition. Microhard wants to decrease sales of one Macrosoft program. They hire Ivan to prove that the program in question is disgusting. However, Ivan has a complicated problem. This new program has s subcomponents, and finding bugs of all types in each subcomponent would take too long before the target could be reached. So Ivan and Microhard agreed to use a simpler criteria â€”- Ivan should find at least one bug in each subsystem and at least one bug of each category. Macrosoft knows about these plans and it wants to estimate the time that is required for Ivan to call its program disgusting. Itâ€™s important because the company releases a new version soon, so it can correct its plans and release it quicker. Nobody would be interested in Ivanâ€™s opinion about the reliability of the obsolete version. A bug found in the program can be of any category with equal probability. Similarly, the bug can be found in any given subsystem with equal probability. Any particular bug cannot belong to two different categories or happen simultaneously in two different subsystems. The number of bugs in the program is almost infinite, so the probability of finding a new bug of some category in some subsystem does not reduce after finding any number of bugs of that category in that subsystem. Find an average time (in days of Ivanâ€™s work) required to name the program disgusting. ç®€è¦ç¿»è¯‘ä¸€ä¸ªè½¯ä»¶æœ‰$s$ä¸ªå­ç³»ç»Ÿï¼Œä¼šäº§ç”Ÿ$n$ç§$bug$ã€‚ ä½ æ¯å¤©ä¼šå‘ç°ä¸€ä¸ª$bug$ï¼Œè¿™ä¸ª$bug$å±äºæŸä¸ªå­ç³»ç»Ÿï¼Œå±äºæŸç§$bug$ã€‚ æ¯å¤©å‘ç°çš„$bug$ï¼Œå‡ºç°åœ¨æ¯ä¸ªå­ç³»ç»Ÿä¸­çš„æ¦‚ç‡éƒ½æ˜¯$\frac 1s$ï¼Œå±äºæ¯ç§$bug$çš„æ¦‚ç‡å‡ä¸º$\frac 1n$ã€‚ æ±‚æ‰¾å‡ºæ‰€æœ‰çš„$n$ç§$bug$ï¼Œä¸”æ¯ä¸ªå­ç³»ç»Ÿéƒ½æ‰¾åˆ°$bug$æ‰€éœ€è¦çš„å¤©æ•°çš„æœŸæœ›ã€‚ Inputè¾“å…¥ä¸¤ä¸ªæ•´æ•°$n,s$ã€‚ Outputè¾“å‡ºæœŸæœ›ï¼Œä¿ç•™å°æ•°ç‚¹åå››ä½å°æ•°ã€‚ Sample Input1 2 Sample Output3.0000 Hint$1&lt;n,s\leq 1,000$ è®¾$f(i,j)$è¡¨ç¤ºå·²ç»æ‰¾åˆ°$i$ç§$bug$ï¼Œå­˜åœ¨äº$j$ä¸ªå­ç³»ç»Ÿä¸­çš„æœŸæœ›è¿˜è¦å¤šå°‘å¤©ã€‚ é‚£ä¹ˆ$f(n,s)=0$ï¼Œ$f(0,0)$å³ä¸ºï¼ˆæ­£ä¹‰ï¼‰ç­”æ¡ˆã€‚ çŠ¶æ€è½¬ç§»å¦‚ä¸‹ï¼š $1.$å‘ç°äº†æ–°$bug$ç§ç±»ï¼Œå­˜åœ¨äºæ–°å­ç³»ç»Ÿï¼Œ$p_1=\frac{n-i}nÃ—\frac{s-j}s$ï¼Œè¿˜éœ€è¦$f(i+1,j+1)$å¤©ã€‚ $2.$å‘ç°äº†æ–°$bug$ç§ç±»ï¼Œå­˜åœ¨äºæ—§å­ç³»ç»Ÿï¼Œ$p_2=\frac{n-i}nÃ—\frac js$ï¼Œè¿˜éœ€è¦$f(i+1,j)$å¤©ã€‚ $3.$å‘ç°äº†æ—§$bug$ç§ç±»ï¼Œå­˜åœ¨äºæ–°å­ç³»ç»Ÿï¼Œ$p_3=\frac inÃ—\frac {s-j}s$ï¼Œè¿˜éœ€è¦$f(i,j+1)$å¤©ã€‚ $4.$å‘ç°äº†æ—§$bug$ç§ç±»ï¼Œå­˜åœ¨äºæ—§å­ç³»ç»Ÿï¼Œ$p_4=\frac inÃ—\frac js$ï¼Œè¿˜éœ€è¦$f(i,j)$å¤©ã€‚ æ‰€ä»¥æœŸæœ›çš„è½¬ç§»æ–¹ç¨‹ä¸ºï¼š f(i,j)=p_1f(i+1,j+1)+p_2f(i+1,j)+p_3f(i,j+1)+p_4f(i,j)+1ç§»é¡¹$f(i,j)$å¯å¾—ï¼š f(i,j)=\frac{p_!f(i+1,j+1)+p_2f(i+1,j)+p_3f(i,j+1)+1}{1-p_4}â€‹æ—¶é—´å¤æ‚åº¦ä¸º$O(ns)$ã€‚ Code123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;int n, s;double f[1010][1010];int main(int argc, char const *argv[])&#123; while(~scanf("%d%d",&amp;n,&amp;s)) &#123; memset(f,0,sizeof(f)); for (int i = n; ~i; --i) for (int j = s; ~j; --j) &#123; if (i == n &amp;&amp; j == s) continue; double p1 = 1.0 * (n - i) / n * (s - j) / s; double p2 = 1.0 * (n - i) / n * j / s; double p3 = 1.0 * i / n * (s - j) / s; double p4 = 1.0 * i / n * j / s; f[i][j] = 1.0 * (p1 * f[i + 1][j + 1] + p2 * f[i + 1][j] + p3 * f[i][j + 1] + 1) / (1.0 - p4); &#125; printf("%.4f\n", f[0][0]); &#125; return 0;&#125; pojæœ‰æ¯’å•¦ï¼ æœ€åæ˜æ˜åº”è¯¥è¾“å‡ºâ€œ$\%.4lf$â€ï¼Œç»“æœå¼ºè¡Œâ€$\%.4f$â€æ‰è¿‡ã€‚ [â—‹ï½¥ï½€Ğ”Â´ï½¥ â—‹]ï¼ï¼ï¼]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#301 D.Bad Luck Island]]></title>
    <url>%2F2019%2F02%2F12%2FCodeForces-301-D-Bad-Luck-Island%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜E.Bad Luck Islandé¢˜é¢The Bad Luck Island is inhabited by three kinds of species: $r$ rocks, $s$ scissors and $p$ papers. At some moments of time two random individuals meet (all pairs of individuals can meet equiprobably), and if they belong to different species, then one individual kills the other one: a rock kills scissors,scissors kill paper, and paper kills a rock. Your task is to determine for each species what is the probability that this species will be the only one to inhabit this island after a long enough period of time. ç®€è¦é¢˜æ„åœ¨ä¸€ä¸ªå²›ä¸Šï¼Œæœ‰ $ğ‘Ÿ + ğ‘  + ğ‘$ ä¸ªäººï¼Œå…¶ä¸­æœ‰$ğ‘Ÿ$ä¸ªäººæœ‰çŸ³å¤´ï¼Œ$ğ‘ $ä¸ªäººæœ‰å‰ªåˆ€ï¼Œ$ğ‘$ä¸ªäººæœ‰å¸ƒã€‚ éµå¾ªçŸ³å¤´å‰ªåˆ€å¸ƒçš„åŸåˆ™ï¼Œè¾“çš„äººå°±ç‹—å¸¦äº†ã€‚æ¯ä¸¤ä¸ªäººé‡åˆ°æ¦‚ç‡çš„ç›¸ç­‰ã€‚æ±‚æ¯ä¸ªäººå­˜æ´»çš„æ¦‚ç‡ã€‚ æ˜¾ç„¶æœ‰åŒç§ä¸œè¥¿çš„äººå­˜æ´»æ¦‚ç‡ç›¸ç­‰ï¼Œä½ åªéœ€è¦è¾“å‡ºæœ‰çŸ³å¤´ï¼Œå‰ªåˆ€ï¼Œå¸ƒçš„äººçš„å­˜æ´»æ¦‚ç‡å³å¯ã€‚ Inputä¸€è¡ŒåŒ…æ‹¬ä¸‰ä¸ªæ•´æ•° $r,s,p$ ï¼Œå¦‚é¢˜æ„æ‰€ç¤ºåˆ†åˆ«ä»£è¡¨çŸ³å¤´ï¼Œå‰ªåˆ€ï¼Œå¸ƒã€‚ Outputè¾“å‡ºä¸‰ä¸ªå®æ•°ï¼Œç”±ç©ºæ ¼éš”å¼€ï¼Œåˆ†åˆ«ä»£è¡¨çŸ³å¤´ï¼Œå‰ªåˆ€ï¼Œå¸ƒå­˜æ´»çš„æ¦‚ç‡ï¼Œå¦‚æœè¾“å‡ºä¸ç­”æ¡ˆçš„è¯¯å·®ä¸è¶…è¿‡$10^{-9}â€‹$ï¼Œåˆ™è®¤ä¸ºç­”æ¡ˆæ­£ç¡®ã€‚ Sample Input 12 2 2 Sample Output 10.333333333333 0.333333333333 0.333333333333 Sample Input 22 1 2 Sample Output 20.150000000000 0.300000000000 0.550000000000 Sample Input 31 1 3 Sample Output 30.057142857143 0.657142857143 0.285714285714 Hint$1\leq r,s,p\leq100â€‹$ ä¸è§£é‡Šäº†å§ï¼Ÿ ä¸€é“æœŸæœ›$dp$ï¼Œè®¾$f[i][j][k]$ï¼Œ$i$ä¸ºå‡ºçŸ³å¤´çš„äººï¼Œ$j$ä¸ºå‡ºå‰ªåˆ€çš„äººï¼Œ$k$ä¸ºå‡ºå¸ƒçš„äººï¼Œç»„åˆä¸€æ³¢å³å¯ã€‚ åˆå§‹çŠ¶æ€ä¸º$f[r][s][p]=1$ï¼Œè½¬ç§»æ–¹ç¨‹è§ä»£ç å§ï¼ŒåŸºæœ¬ç›¸åŒã€‚ Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 110;int r, s, p;double f[N][N][N], A1, A2, A3;long long calc(int x, int y, int z)&#123; return max(((x + y + z) * (x + y + z - 1) - x * (x - 1) - y * (y - 1) - z * (z - 1)) &gt;&gt; 1, 1);&#125;int main()&#123; r = read(), s = read(), p = read(); f[r][s][p] = 1; for (int i = r; ~i; --i) for (int j = s; ~j; --j) for (int k = p; ~k; --k) &#123; if (!i &amp;&amp; !j &amp;&amp; !k) continue; if (i == r &amp;&amp; j == s &amp;&amp; k == p) continue; f[i][j][k] += f[i + 1][j][k] * (1.0 * (i + 1) * k / calc(i + 1, j, k)); f[i][j][k] += f[i][j + 1][k] * (1.0 * (j + 1) * i / calc(i, j + 1, k)); f[i][j][k] += f[i][j][k + 1] * (1.0 * (k + 1) * j / calc(i, j, k + 1)); &#125; for (int i = 1; i &lt;= r; ++i) A1 += f[i][0][0]; for (int i = 1; i &lt;= s; ++i) A2 += f[0][i][0]; for (int i = 1; i &lt;= p; ++i) A3 += f[0][0][i]; printf("%.11lf %.11lf %.11lf", A1, A2, A3); return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu P1654 OSU!]]></title>
    <url>%2F2019%2F02%2F12%2Fluogu-P1654-OSU%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜D.OSU!é¢˜é¢ osu æ˜¯ä¸€æ¬¾ç¾¤ä¼—å–œé—»ä¹è§çš„ä¼‘é—²è½¯ä»¶ã€‚ æˆ‘ä»¬å¯ä»¥æŠŠosuçš„è§„åˆ™ç®€åŒ–ä¸æ”¹ç¼–æˆä»¥ä¸‹çš„æ ·å­: ä¸€å…±æœ‰næ¬¡æ“ä½œï¼Œæ¯æ¬¡æ“ä½œåªæœ‰æˆåŠŸä¸å¤±è´¥ä¹‹åˆ†ï¼ŒæˆåŠŸå¯¹åº”1ï¼Œå¤±è´¥å¯¹åº”0ï¼Œnæ¬¡æ“ä½œå¯¹åº”ä¸º1ä¸ªé•¿åº¦ä¸ºnçš„01ä¸²ã€‚åœ¨è¿™ä¸ªä¸²ä¸­è¿ç»­çš„ Xä¸ª1å¯ä»¥è´¡çŒ®X^3 çš„åˆ†æ•°ï¼Œè¿™xä¸ª1ä¸èƒ½è¢«å…¶ä»–è¿ç»­çš„1æ‰€åŒ…å«ï¼ˆä¹Ÿå°±æ˜¯æé•¿çš„ä¸€ä¸²1ï¼Œå…·ä½“è§æ ·ä¾‹è§£é‡Šï¼‰ ç°åœ¨ç»™å‡ºnï¼Œä»¥åŠæ¯ä¸ªæ“ä½œçš„æˆåŠŸç‡ï¼Œè¯·ä½ è¾“å‡ºæœŸæœ›åˆ†æ•°ï¼Œè¾“å‡ºå››èˆäº”å…¥åä¿ç•™1ä½å°æ•° Input ç¬¬ä¸€è¡Œæœ‰ä¸€ä¸ªæ­£æ•´æ•°n,è¡¨ç¤ºæ“ä½œä¸ªæ•°ã€‚æ¥ä¸‹å»nè¡Œæ¯è¡Œæœ‰ä¸€ä¸ª[0,1]ä¹‹é—´çš„å®æ•°ï¼Œè¡¨ç¤ºæ¯ä¸ªæ“ä½œçš„æˆåŠŸç‡ã€‚ Output åªæœ‰ä¸€ä¸ªå®æ•°ï¼Œè¡¨ç¤ºç­”æ¡ˆã€‚ç­”æ¡ˆå››èˆäº”å…¥åä¿ç•™1ä½å°æ•°ã€‚ Sample Input30.50.50.5 Sample Output6.0 Hint 000åˆ†æ•°ä¸º0ï¼Œ001åˆ†æ•°ä¸º1ï¼Œ010åˆ†æ•°ä¸º1ï¼Œ100åˆ†æ•°ä¸º1ï¼Œ101åˆ†æ•°ä¸º2ï¼Œ110åˆ†æ•°ä¸º8ï¼Œ011åˆ†æ•°ä¸º8ï¼Œ111åˆ†æ•°ä¸º27ï¼Œæ€»å’Œä¸º48ï¼ŒæœŸæœ›ä¸º48/8=6.0 $N\leq 10^5$ å­¦ä¹ $luogu$ä¸Š$hall_of_history$å¤§ä½¬ç®€æ´çš„é¢˜è§£ã€‚ é¦–å…ˆï¼Œå­¦è¿‡æ•°å­¦çš„å¹¼å„¿å›­æ¯•ä¸šç”Ÿéƒ½çŸ¥é“$(x+1)^3=x^3+3x^2+3x+1â€‹$ æ¯å¤šå¢åŠ ä¸€ä¸ª1ï¼Œåˆ™ç­”æ¡ˆå°±å˜ä¸ºåŸå…ˆçš„$(x+1)^3=x^3+3x^2+3x+1$ï¼Œ ä¹Ÿå°±æ˜¯æ¯”åŸå…ˆå¤šäº†$(x+1)^3-x^3=3x^2+3x+1$ã€‚ ç»´æŠ¤è¿™ä¸ªå¢åŠ çš„æœŸæœ›ï¼Œç»´æŠ¤$x_1[i]$è¡¨ç¤º$x$çš„æœŸæœ›ï¼Œç»´æŠ¤$x_2[i]$è¡¨ç¤º$x^2$çš„æœŸæœ›ã€‚ åˆ™æœ‰$x_1[i]=(x_1[i-1]+1)Ã—p[i]$ï¼Œ$x_2[i]=(x_2[i-1]+2Ã—x_1[i-1]+1)Ã—p[i]$ã€‚ æ‰€ä»¥æœ‰ï¼š $Ans[i]=Ans[i-1]+(3Ã—x_2[i-1]+3Ã—x_1[i-1]+1)Ã—p[i]$ã€‚ æˆ‘ä»¬æ±‚$Ans[n]$å³å¯ã€‚ Code1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;long long read()&#123; long long x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e5 + 10;double p[N], x1[N], x2[N], Ans[N];long long n;int main()&#123; n = read(); for (int i = 1; i &lt;= n; ++i) scanf("%lf", &amp;p[i]); for (int i = 1; i &lt;= n; ++i) &#123; x1[i] = (x1[i - 1] + 1) * p[i]; x2[i] = (x2[i - 1] + 2 * x1[i - 1] + 1) * p[i]; Ans[i] = Ans[i - 1] + (3 * x2[i - 1] + 3 * x1[i - 1] + 1) * p[i]; &#125; printf("%.1lf", Ans[n]); return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6390 GUGUFISHTION]]></title>
    <url>%2F2019%2F02%2F11%2FHDU-6390-GUGUFISHTION%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜A.GUGUFISHTIONé¢˜é¢ç»™å‡º$m,n,p$ï¼Œæ±‚ï¼š$\sum_{a=1}^m\sum_{b=1}^n\frac {\phi(ab)}{\phi(a)\phi(b)}\ mod\ \ p$ Inputç¬¬ä¸€è¡Œä¸€ä¸ª$T$ä»£è¡¨ç»„æ•°ã€‚ ä¹‹åçš„$T$è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸‰ä¸ªæ•´æ•°$m,n,p$ã€‚ æ•°æ®ä¿è¯$p$æ˜¯ä¸€ä¸ªè´¨æ•°ã€‚ Outputè¾“å‡º$Tâ€‹$è¡Œï¼Œæ¯è¡Œåªæœ‰ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚ Sample Input1 5 7 23 Sample Output2 Hint$1\leq T \leq 3â€‹$ $1\leq m,n\leq1,000,000$ $max(m,n)&lt; p \leq 10^9+7â€‹$ ç”±æ¬§æ‹‰å‡½æ•°çš„æ€§è´¨$\phi(p^k)=(p-1)Ã—p^{k-1}(pä¸ºè´¨æ•°)$ã€‚ ä»¤$d=gcd(a,b)=p_1^{k_1}Ã—p_2^{k_2}Ã—â€¦Ã—p_n^{k_n}â€‹$ã€‚ $G_u(a,b)=\frac {\phi(a,b)}{\phi(a)\phi(b)}=\frac{\phi(p_1^{2k_1}Ã—p_2^{2k_2}Ã—â€¦Ã—p_n^{2k_n})}{\phi(p_1^{k_1}Ã—p_2^{k_2}Ã—â€¦Ã—p_n^{k_n})^2}$ ç”±äºæ¬§æ‹‰å‡½æ•°ä¸ºç§¯æ€§å‡½æ•°ï¼Œä¸”å› ä¸ºå„é¡¹ä¸Šä¸‹äº’è´¨ï¼Œå±•å¼€çº¦å»ã€‚ $G_u(a,b)=\frac {(p_1-1)Ã—(p_2-1)Ã—(p_3-1)Ã—â€¦Ã—(p_n-1)Ã—p_1^{2k_1-1}Ã—p_2^{2k_2-1}Ã—â€¦Ã—p_n^{2k_n-1}}{(p_1-$1)^2Ã—(p_2-1)^2Ã—(p_3-1)^2Ã—â€¦Ã—(p_n-1)^2Ã—p_1^{k_1-1}Ã—p_2^{k_2-1}Ã—â€¦Ã—p_n^{k_n-1}}â€‹$ $=\frac {p_1Ã—p_2Ã—p_3Ã—â€¦Ã—p_n}{(p_1-1)Ã—(p_2-1)Ã—â€¦Ã—(p_n-1)}=\frac {p_1Ã—p_2Ã—p_3Ã—â€¦Ã—p_nÃ—p_1^{k_1-1}Ã—p_2^{k_2-1}Ã—â€¦Ã—p_n^{k_n-1}}{(p_1-1)Ã—(p_2-1)Ã—(p_3-1)Ã—â€¦Ã—(p_n-1)Ã—p_1^{k_1-1}Ã—p_2^{k_2-2}Ã—â€¦Ã—p_n^{k_n-1}}â€‹$ $=\frac {p_1^{k_1}Ã—p_2^{k_2}Ã—â€¦Ã—p_n^{k_n}}{\phi(p_1^{k_1}Ã—p_2^{k_2}Ã—â€¦Ã—p_n^{k_n})}=\frac {d}{\phi{d}}â€‹$ ä»¤$a[i]=\frac i{\phi(i)}â€‹$ï¼Œ$f(m,n)=\sum_{a=1}^m\sum_{b=1}^nG_u(a,b)=\sum_{a=1}^m\sum_{b=1}^naÃ—dâ€‹$ $f(m,n)=\sum_{d=1}^{min(m,n)}\sum_{a=1}^m\sum_{b=1}^na[t]Ã—[d==t]=\sum_{d=1}^{min(m,n)}\sum_{a=1}^{\lfloor \frac mt\rfloor}\sum_{b=1}^{\lfloor \frac nt\rfloor}a[t]Ã—[d==1]$ $[åˆ°æ­¤å¤„dçš„å®šä¹‰å–æ¶ˆï¼Œæ‡’å¾—ä¿®æ”¹ï¼Œå†™å®Œå‘ç°ä¸å¯¹äº†]â€‹$â•®(â•¯â–½â•°)â•­ ä»¤$g(m,n)=\sum_{a=1}^m\sum_{b=1}^n[d==1]=\sum_{a=1}^m\sum_{b=1}^n\sum_{d|gcd(a,b)}\mu(d)=\sum_{d=1}^{min(a,b)}\mu(d)Ã—\frac mdÃ—\frac nd$ å› ä¸ºæœ‰ï¼š $\sum_{d|n}\mu(d)=1\ \ (n==1)$ $\sum_{d|n}\mu(d)=0\ \ (n&gt;1)$ å½“$gcd(a,b)==1$ï¼Œåˆ™$\sum_{d|gcd(a,b)}\mu(d)=1$ï¼› å½“$gcd(a,b)\ !\ =1â€‹$ï¼Œåˆ™$\sum_{d|gcd(a,b)}\mu(d)=0ï¼Œ=[gcd(a,b)==1]â€‹$ã€‚ å› ä¸º$\frac md$è¡¨ç¤ºåœ¨$aâˆˆ[1,m]$ä¸­èƒ½è¢«$d$æ•´é™¤çš„æ•°çš„ä¸ªæ•°ï¼Œ$\frac nd$è¡¨ç¤ºåœ¨$bâˆˆ[1,n]$ä¸­èƒ½è¢«$d$æ•´é™¤çš„æ•°çš„ä¸ªæ•°ã€‚ æ‰€ä»¥ï¼Œå¯è¯ç­‰ä»·ã€‚ æ‰€ä»¥æœ‰$f(m,n)=\sum_{d=1}^{min(m,n)}a[t]Ã—(\sum_{a=1}^{\lfloor \frac mt\rfloor}\sum_{b=1}^{\lfloor \frac nt\rfloor}[d==1])=\sum_{d=1}^{min(m,n)}a[t]Ã—g(\frac mt,\frac nt)$ã€‚ æ—¶é—´å¤æ‚åº¦$\frac n1+\frac n2+\frac n3+\frac n4+â€¦+\frac n{n-1}+\frac nn=nln(n)+Cï¼ˆCä¸ºæ¬§æ‹‰å‡½æ•°ï¼‰$ æ²¡æƒ³å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º$O(ln(n))â€‹$ï¼Œæ‰€ä»¥æ€»æ—¶é—´å¤æ‚åº¦ä¸º$O(nln(n))â€‹$ã€‚ CODEï¼šå› ä¸ºæ€»æœ‰$\phi(i)&lt;i$ï¼Œé¢„å¤„ç†å‡º$max(m,n)â€‹$ä¸ªé€†å…ƒå³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;long long read()&#123; long long x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e6 + 10;bool notprime[N];int mu[N], p[N], cnt;long long m, n, mod;long long phi[N], a[N], inv[N];void Prime()&#123; phi[1] = mu[1] = 1; notprime[1] = 1; for (int i = 2; i &lt;= 1000000; ++i) &#123; if (!notprime[i]) &#123; p[++cnt] = i; phi[i] = i - 1; mu[i] = -1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= 1000000; ++j) &#123; notprime[i * p[j]] = 1; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; else &#123; phi[i * p[j]] = phi[i] * (p[j] - 1); mu[i * p[j]] = -mu[i]; &#125; &#125; &#125;&#125;void inv_work(int lim)&#123; inv[1] = 1; for (int i = 2; i &lt;= lim; ++i) inv[i] = inv[mod % i] * (mod - mod / i) % mod; for (int i = 1; i &lt;= lim; ++i) a[i] = inv[phi[i]] * i % mod;&#125;int main()&#123; int T = read(); Prime(); while (T--) &#123; m = read(), n = read(), mod = read(); int lim = min(m, n); inv_work(lim); long long result = 0; for (int i = 1; i &lt;= lim; ++i) &#123; int pp = m / i, qq = n / i; long long t = 0; for (int j = 1; j &lt;= min(pp, qq); ++j) (t += 1ll * mu[j] * (pp / j) * (qq / j) + mod) %= mod; (result += a[i] * t % mod) %= mod; &#125; cout &lt;&lt; result &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4804 æ¬§æ‹‰å¿ƒç®—]]></title>
    <url>%2F2019%2F02%2F11%2Fbzoj-4804-%E6%AC%A7%E6%8B%89%E5%BF%83%E7%AE%97%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜C.æ¬§æ‹‰å¿ƒç®—é¢˜é¢ç»™å‡ºä¸€ä¸ªæ•°å­—Nï¼Œæ±‚$\sum_{i=1}^n\sum_{j=1}^n\phi(gcd(i,j))$ã€‚ Input ç¬¬ä¸€è¡Œä¸ºä¸€ä¸ªæ­£æ•´æ•°$Tâ€‹$ï¼Œè¡¨ç¤ºæ•°æ®ç»„æ•°ã€‚ æ¥ä¸‹æ¥$T$è¡Œä¸ºè¯¢é—®ï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªæ­£æ•´æ•°$N$ã€‚ Output æŒ‰è¯»å…¥é¡ºåºè¾“å‡ºç­”æ¡ˆã€‚ Sample Input1 10 Sample Output 136 Hint $T\leq5000,N\leq10^7$ è§£æè«æ¯”ä¹Œæ–¯åæ¼”ä¸€æ³¢å¯å¾—ï¼š Ans=\sum_{i=1}^n\sum_{j=1}^n\phi(gcd(i,j))=\sum_{i=1}^n\phi(i)\sum_{d=1}^{\lfloor\frac ni\rfloor}\mu(d)\lfloor\frac n{id}\rfloor^2ä»¤$g(n)=\sum_{d=1}^n\mu(d)\lfloor\frac nd\rfloor^2â€‹$ å› ä¸º$\lfloor\frac nd\rfloor-\lfloor\frac {n-1}d\rfloor=1$æˆç«‹å½“ä¸”ä»…å½“$d|n$ é‚£ä¹ˆ$g(n)=g(n-1)+\sum_{d|n}\mu(d)(2\frac {n}d-1)$ å› ä¸º$\sum_{d|n}\frac {\mu(d)}d=\frac {\phi(n)}n$ $g(n)=g(n-1)+2\phi(d)-[n==1]â€‹$ äºæ˜¯æœ‰$Ans=\sum_{i=1}^n\phi(i)g(\lfloor\frac ni\rfloor)$ è¯¥ç®—æ³•æ—¶é—´å¤æ‚åº¦ä¸º$O(T\sqrt N)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e7 + 10;int p[N], cnt, q[5010], T;long long phi[N], g[N];bool notprime[N];void work(int m, long long ans = 0)&#123; for (int i = 1, ne; i &lt;= m; i = ne + 1) &#123; ne = m / (m / i); ans += (phi[ne] - phi[i - 1]) * g[m / i]; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;void Prime()&#123; phi[1] = g[1] = 1, notprime[1] = 1; for (int i = 2; i &lt;= 10000000; ++i) &#123; if (!notprime[i]) &#123; p[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= 10000000; ++j) &#123; notprime[i * p[j]] = 1; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; else phi[i * p[j]] = phi[i] * (p[j] - 1); &#125; g[i] = g[i - 1] + 2 * phi[i]; &#125; for (int i = 2; i &lt;= 10000000; ++i) phi[i] += phi[i - 1];&#125;int main()&#123; T = read(); Prime(); while (T--) work(read()); return 0;&#125;]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3994/luogu P3327 çº¦æ•°ä¸ªæ•°å’Œ]]></title>
    <url>%2F2019%2F02%2F11%2Fbzoj-3994(luogu-P3327)-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~2019å¯’å‡é›†è®­é¢˜D.çº¦æ•°ä¸ªæ•°å’Œé¢˜é¢è®¾d(x)ä¸ºxçš„çº¦æ•°ä¸ªæ•°ï¼Œç»™å®šNã€Mï¼Œæ±‚ $\sum_{i=1}^{N}\sum_{j=1}^{M}d(iÃ—j)$. Inputè¾“å…¥æ–‡ä»¶åŒ…å«å¤šç»„æµ‹è¯•æ•°æ®ã€‚ ç¬¬ä¸€è¡Œï¼Œä¸€ä¸ªæ•´æ•°Tï¼Œè¡¨ç¤ºæµ‹è¯•æ•°æ®çš„ç»„æ•°ã€‚ æ¥ä¸‹æ¥çš„Tè¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•°Nã€Mã€‚ OutputTè¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºä½ æ‰€æ±‚çš„ç­”æ¡ˆã€‚ Sample Input27 45 6 Sample Output110 121 Hint$1\leq N,M \leq 50,000$ $1\leq T \leq 50,000$ å“ï¼Œä»Šå¤©fhjå¤§ä½¬è®²è¯¾ä¹Ÿæ˜¯å¾ˆæ— å¥ˆï¼Œè«æ¯”ä¹Œæ–¯åæ¼”è™½ç„¶æ˜¯å­¦äº†ï¼Œä½†æ˜¯ç¡®å®ä¸å¤ªä¼šç”¨å“‡ã€‚ å…¬å¼ææƒ§ç—‡æ‚£è€…ä¸€æšâ€¦â€¦ ç¬¬ä¸€æ­¥â€‹ é¦–å…ˆï¼Œæˆ‘ä»¬è¯æ˜ä¸€æ¡ç»“è®ºï¼šd(nÃ—m)=\sum_{i|n}\sum_{j|m}[gcd(i,j)==1] â€‹ è¯æ˜ï¼šå¯¹äºnmæ¯ä¸€ä¸ªè´¨å› å­$p_i$ï¼Œæˆ‘ä»¬ä»¤$n={p_i}^{a_i}Ã—n_x,m={p_i}^{b_i}Ã—m_x$ï¼Œåˆ™æœ‰d(nÃ—m)=\Pi_i(a_i+b_i+1)â€‹ï¼Œè®¾ $l$ å’Œ $t$ äº’è´¨ä¸”ä¸å«è´¨å› å­$p_i$ï¼Œé‚£ä¹ˆ$(lÃ—{p_i}^{a_i},t),(lÃ—{p_i}^{a_i-1})â€¦(l,t)â€¦(l,tÃ—{p_i}^{b_i-1}),(l,tÃ—{p_i}^{b_i})$éƒ½æ˜¯äº’è´¨çš„æ•°å¯¹ï¼Œè€Œ $ l$ å’Œ $ t $ çš„å–æ³•åˆšå¥½æ˜¯$\Pi_{k\neq i}(a_k+b_k+1)$ç§ã€‚ ç¬¬äºŒæ­¥â€‹ ä¸‹é¢æ˜¯å…¬å¼ææƒ§ç—‡çš„â€œç¦åˆ©â€ï¼Ÿï¼ \sum_{i=1}^n\sum_{j=1}^md(iÃ—j)=\sum_{i=1}^n\sum_{j=1}^m\sum_{k|i}\sum_{l|j}[gcd(k,l)==1]â€‹â€‹ ç°åœ¨æˆ‘ä»¬æšä¸¾æ¯ä¸€ä¸ªæ•°å¯¹$(k,l)$,é‚£ä¹ˆå®ƒä»¬ä¼šè¢«ç®—å¤šå°‘éå‘¢ï¼Ÿæ¯ä¸€ä¸ª$k$çš„å€æ•°éƒ½ä¼šç®—ä¸€æ¬¡$k$ï¼Œæ¯ä¸€ä¸ª$l$çš„å€æ•°åˆä¼šç®—ä¸€æ¬¡$l$,è€Œç”¨$\frac nk$æ¥è¡¨ç¤ºnä»¥å†…kçš„å€æ•°æœ‰å¤šå°‘ä¸ªæ˜¯æ˜¾ç„¶çš„ï¼Œæ‰€ä»¥ï¼š \sum_{k=1}^n\sum_{l=1}^m\frac nkÃ—\frac ml[gcd(k,l)==1]â€‹ ç„¶åæˆ‘ä»¬èƒ½å¤Ÿç”¨è«æ¯”ä¹Œæ–¯å‡½æ•°çš„æ€§è´¨ï¼š \sum_{d|n}\mu(d)=1\ (n==1)\sum_{d|n}\mu(d)=0\ (n>1)â€‹ é‚£æˆ‘ä»¬å°±å¯ä»¥å¾—åˆ°ï¼š \sum_{k=1}^n\sum_{l=1}^m\frac nkÃ—\frac ml\sum_{d|gcd(k,l)}\mu(d)â€‹ å¦‚æœ$gcd(k,l)==1$ï¼Œæ­¤æ—¶åé¢çš„è¿™äº›ç­‰äº1ï¼Œå¦åˆ™æ˜¯0ã€‚ â€‹ æˆ‘ä»¬å°±èƒ½å¾—åˆ°ï¼š \sum_{k=1}^n\sum_{l=1}^m\frac nkÃ— \frac ml\sum_{d|kä¸”d|l}\mu(d)â€‹ æˆ‘ä»¬åªè¦æšä¸¾$\mu(d)$ï¼Œæ˜¾ç„¶ï¼Œæˆ‘ä»¬åªè¦æšä¸¾dçš„å€æ•°æ¥ä¸$\mu(d)$ç›¸ä¹˜å³å¯ã€‚ \sum_{d=1}^{min(n,m)}\mu(d)\sum_{i=1}^\frac nd\sum_{j=1}^\frac md\frac n{d_i}Ã—\frac m{d_j}ç¬¬ä¸‰æ­¥â€‹ æˆ‘ä»¬ç”±ç¬¬äºŒæ­¥ç»§ç»­å˜å½¢å¯å¾—ï¼š \sum_{d=1}^{min(n,m)}\mu(d)Ã—(\sum_{k=1}^{\frac nd}\frac n{dk})Ã—(\sum_{l=1}^{\frac md}\frac m{dl})ä»¤$g(x)=\sum_{i=1}^x\frac xiâ€‹$ \sum_{d=1}^{min(n,m)}\mu(d)Ã—g(\frac nd)Ã—g(\frac md)æˆ‘ä»¬é¢„å¤„ç†å‡º$g(x)â€‹$å³å¯ã€‚ è§‚å¯Ÿä¸€ä¸‹$g(x)$ï¼Œå°±ä¼šå‘ç°å…¶å®å¼å­å¯ä»¥è¿™ä¹ˆç†è§£ï¼š$x$ä»¥å†…æœ‰çº¦æ•°içš„æ•°çš„ä¸ªæ•°å’Œï¼Œä¹Ÿå°±æ˜¯å¯çœ‹ä½œåŸé¢˜ä¸­$d(x)$çš„å‰ç¼€å’Œè¦æ±‚$d(x)$çš„å‰ç¼€å’Œï¼Œå¯ä»¥æ±‚å‡ºæ¯ä¸€ä¸ª$d(x)$,ä¹Ÿå°±æ˜¯ç”¨çº¿æ€§ç­›æ±‚å•¦ï¼Œè¦è®°å½•ä¸€ä¸‹$c(x)$:å°†$x$åˆ†è§£è´¨å› æ•°åï¼Œæœ€å°è´¨å› æ•°çš„æŒ‡æ•°ã€‚é‚£ä¹ˆå‚è§ç¬¬ä¸€æ­¥ï¼Œxçš„æœ€å°è´¨å› æ•°å¯¹$d(x)$çš„è´¡çŒ®ä¸º$c(x)+1$ã€‚ ç¬¬å››æ­¥â€‹ ä»£ç å®ç° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;int mu[500010],p[50010],cnt,n,m;long long a[500010],b[500010];bool notprime[500010];void Prime()&#123; mu[1]=a[1]=b[1]=1; for(int i=2;i&lt;=50000;++i) &#123; if(!notprime[i]) &#123; p[++cnt]=i; mu[i]=-1,a[i]=1,b[i]=2; &#125; for(int j=1;j&lt;=cnt&amp;&amp;i*p[j]&lt;=50000;++j) &#123; notprime[i*p[j]]=1; if(i%p[j]==0) &#123; b[i*p[j]]=b[i]/(a[i]+1)*(a[i]+2); a[i*p[j]]=a[i]+1; break; &#125; else &#123; b[i*p[j]]=b[i]*b[p[j]]; a[i*p[j]]=1; mu[i*p[j]]=-mu[i]; &#125; &#125; &#125; for(int i=2;i&lt;=50000;++i) &#123; b[i]+=b[i-1]; mu[i]+=mu[i-1]; &#125;&#125;int main()&#123; int T=read(); Prime(); while(T--) &#123; long long result=0; n=read(),m=read(); if(n&gt;m) swap(n,m); for(int i=1,j;i&lt;=n;i=j+1) &#123; j=min(n/(n/i),m/(m/i)); result+=(mu[j]-mu[i-1])*b[n/i]*b[m/i]; &#125; cout&lt;&lt;result&lt;&lt;endl; &#125; return 0;&#125; p.s.è¿˜æœ‰å¾ˆé‡è¦çš„ä¸€ç‚¹ï¼Œå¦‚æœåˆå§‹åŒ–ç”¨è¿™æ ·a[N]={0,1}ï¼Œä¼šå¯¼è‡´exeæ–‡ä»¶è¿‡å¤§è€Œæ— æ³•æäº¤ï¼Œå˜¤å˜¤å˜¤ï¼Œæ„Ÿè°¢vhoscå·¨ä½¬â€¦â€¦(/â‰§â–½â‰¦)/]]></content>
      <categories>
        <category>å¯’å‡é›†è®­</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.5.30 é›†è®­æ€»ç»“]]></title>
    <url>%2F2018%2F05%2F30%2F2018-5-30%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[~{â†’çœ‹ä¸è§LaTexæ ¼å¼çš„Dalaoä»¬è¯·åˆ·æ–°æœ¬é¡µThanksâ™ª(ï½¥Ï‰ï½¥)ï¾‰â†}~æ€»ç»“ï¼š å…ˆä»ç¬¬ä¸€å¤©çš„æ¯”èµ›å¼€å§‹çœ‹ï¼Œå…¶å®å…‰ä»é¢˜ç›®æ¥çœ‹ï¼Œæˆ‘æ’äºç¬¬ä¸ƒåçš„æˆç»©ï¼Œä¹Ÿå°±æ˜¯ä¸¤é“æ°´é¢˜å’Œä¸€é“æ¯”è¾ƒç†Ÿç»ƒçš„BFSç»™çš„ï¼Œåé¢å‡ é¢˜æ˜¯æ²¡æœ‰æ€è·¯çš„ï¼ˆå¤§ä½¬ä»¬å¤ªå¼ºäº†å•Šï¼‰ï¼Œè¢«å®Œè™â€¦â€¦ æˆ‘å†ä»æ˜¨å¤©çš„ACMæ¬¢ä¹èµ›å¼€å§‹è¯´èµ·â€”â€”â€”â€”æ¯”èµ›ç¬¬ä¸€ä¸ªå°æ—¶ï¼Œä»Aé¢˜çš„æ°´é¢˜ååˆ†é’Ÿå®Œæˆçš„é€Ÿåº¦æ¥çœ‹ï¼Œç¨ç¨æ”¾å®½äº†å¿ƒæ€ï¼Œç„¶è€Œåœ¨Bé¢˜ä¸Šç«Ÿç„¶æ ½äº†è·Ÿå¤´ã€‚æœ€åˆåœ¨ç¬¬ä¸‰ä¸ªç‚¹WAäº†2éï¼Œå†åœ¨14ç‚¹WAäº†å¥½å‡ éï¼Œæœ€ååˆå¡åœ¨äº†35ç‚¹ã€‚æœ€åå¿ƒæ€å‡ ä¹çˆ†ç‚¸ï¼ˆå†…å¿ƒOSï¼šè¿™å¯æ˜¯ä¸€é“æ°´é¢˜å•Šï¼‰ï¼ŒåŒæ ·ï¼ŒåŒç»„çš„å¤§ä½¬ä»¬ï¼Œä¹Ÿæ²¡å‘ç°æœ‰ä»€ä¹ˆé—®é¢˜ã€‚å°±è¿™æ ·çº ç»“ç€ï¼Œæœ€åå°†ä¸€ä¸ªåŒé‡åˆ¤å®šæ¢äº†æ–¹å‘çš„æ€ç»´çš„å¦ä¸€ç§åˆ¤å®šï¼Œäºæ˜¯ï¼Œç»ˆäºæ˜¯Aäº†â€¦â€¦æ­¤æ—¶æ—¶é—´å·²ç»åœ¨ä¸¤å°æ—¶ä¹‹åäº†ï¼ˆæ¯”èµ›åŠç¨‹åˆšè¿‡ï¼‰ã€‚å†…å¿ƒç«æ€¥ç«ç‡å¾—ï¼Œä¹Ÿä¸çŸ¥æ€çš„å…¶ä»–ä¸¤ä½å¤§ä½¬ï¼Œç«Ÿç„¶å¼€å§‹æ¢é¡ºåºåšï¼ŒåŠå°æ—¶è¿‡å»ï¼ŒVHOSï¼ˆå¤ªå¼ºäº†ï¼‰ç«Ÿç„¶å®Œæˆäº†Gç»„é¢˜ï¼Œç„¶è€Œä¸å¹¸çš„æ˜¯ä¸èƒ½æäº¤ï¼ˆè¾£é¸¡æ—¥æœ¬Vjudgeï¼‰ã€‚è¿™åˆæ˜¯å¯¹æˆ‘ä»¬å¿ƒæ€çš„è€ƒéªŒï¼Œäºæ­¤åŒæ—¶åŠæ•°ä»¥ä¸Šçš„ç»„æ—©å·²ç»å®Œæˆäº†3é“äº†ï¼Œæˆ‘ä»¬çš„æ’åä½ç½®å‡ ä¹å·²ç»å¯ä»¥çœ‹åˆ°æ¦œåº•äº†ã€‚ç»ˆäºåœ¨æœ€åçš„ç¬¬ä¸‰ä¸ªå°æ—¶â€”â€”â€”â€”å¥‡è¿¹ç«Ÿç„¶å‡ºç°äº†ï¼ä¸‰å°æ—¶ååˆ†é’Ÿï¼Cé¢˜ï¼ï¼ACï¼ï¼ä¸‰å°æ—¶ä¸‰ååˆ†ï¼Gé¢˜ï¼ï¼ACï¼ï¼æ­¤æ—¶æˆ‘ä»¬çš„æ’åå·²ç»æŒ¤åˆ°äº†å‰åï¼Œ4é“ACï¼Œæœ€å¤šçš„å¤§ç¥ç»„æ—©å®Œæˆäº†5é¢˜ï¼Œæˆ‘å¿ƒæœ‰ä¸ç”˜ï¼Œç»§ç»­å¥‹æˆ˜ï¼Œæ­¤æ—¶åªå‰©å”¯æˆ‘ä¸€äººå¥‹ç¬”ç–¾ä¹¦â€¦â€¦å‘¨å›´çš„äººæ—©å·²æ‡ˆæ€ ï¼Œä¸ï¼Œè¿˜ä¸èƒ½é‚£ä¹ˆæ—©ã€‚åŠªåŠ›çš„æƒ³ç€Dé¢˜ï¼Œdpæ–¹ç¨‹å´æ­»ä¹Ÿæ¨ä¸å‡ºæ¥ï¼Œæœ€ååäº”åˆ†é’Ÿâ€¦â€¦ï¼ï¼ï¼å“¦ï¼ï¼ï¼çªç„¶æœ‰äº†æƒ³æ³•ï¼Œå¤ºè¿‡é”®ç›˜ï¼Œæœ€å13åˆ†é’Ÿï¼ï¼ï¼æˆ‘çŸ¥é“è¿™æ¬¡æˆ‘æ²¡æœ‰è°ƒè¯•çš„æ—¶é—´äº†ï¼Œåªèƒ½è¦æ±‚è‡ªå·±ä¸€éè¿‡ï¼Œæ¯ä¸ªå­—éƒ½æ•²å¾—å°å¿ƒç¿¼ç¿¼ï¼ŒåŒæ—¶åˆå¾—åŠ å¿«é€Ÿåº¦â€¦â€¦â€¦â€¦3minï¼2minï¼ï¼æ•²å®Œäº†ï¼ï¼ï¼æ ·ä¾‹ä¸€è¿‡ï¼Œç›´æ¥æäº¤ï¼Œä¸æ•¢æµªè´¹æ¯ä¸€åˆ†é’Ÿï¼ï¼ï¼ç«Ÿç„¶æˆåŠŸACäº†ï¼ï¼ï¼ï¼ï¼åŒç»„çš„å¤§ä½¬é«˜å…´çš„æ¬¢å‘¼ï¼ï¼æˆ‘åšåˆ°äº†ï¼ï¼ï¼å½“è‡ªå·±å¹³é™ä¸‹æ¥æ—¶ï¼Œæˆ‘æ‰å‘ç°è‡ªå·±çš„èº«ä½“ä¸€ç›´åœ¨é¢¤æŠ–ï¼Œå¿ƒè·³ååˆ†çš„å¿«ã€‚æœ€åæˆ‘ä»¬è™½ç„¶ç½šæ—¶å¾ˆä¹…ï¼Œä½†æ˜¯æœ€ç»ˆä¹Ÿä»¥å”¯ä¸€AC 6é“çš„å¥½æˆç»©ä½å±…äº†æ¦œé¦–ï¼Œååˆ†ä¸æ˜“å•Šï¼ï¼ ï¼ˆP.S:æœ€åä»å²³ç¥å’Œåˆ˜å¤§ä½¬çš„é’±åŒ…é‡ŒæˆåŠŸå‘åˆ°ä¸€é¡¿KFCï¼‰o(â—Ë‡âˆ€Ë‡â—)o ä¸‹é¢æ˜¯å¯¹è¿™å‡ å¤©æ‰€å­¦å†…å®¹çš„æ€»ç»“ï¼Œé€æ¡æšä¸¾ï¼šï¼ˆå…¶å®å¾ˆå¤šå£èƒ¡ä¸€æ³¢ï¼Œå¹¶ä¸èƒ½ä¸Šæ‰‹å½“åœºç é¢˜ï¼‰ 1ã€$KMP$ ï¼ˆä¿—ç§°â€œçœ‹*ç‰‡ç®—æ³•â€ï¼‰ ï¼ˆä¸€%é£ç¥ï¼‰è¿™æ˜¯ç”±ä¸‰ä½å¤§ç¥åŒæ—¶å‘ç°çš„ä¸€ç§æ”¹è¿›å­—ç¬¦ä¸²åŒ¹é…çš„ç®—æ³•ï¼ˆ%%%ï¼‰ï¼Œ$KMP$ç®—æ³•çš„å…³é”®æ˜¯åˆ©ç”¨åŒ¹é…å¤±è´¥åçš„ä¿¡æ¯ï¼Œå°½é‡å‡å°‘æ¨¡å¼ä¸²ä¸ä¸»ä¸²çš„åŒ¹é…æ¬¡æ•°ä»¥è¾¾åˆ°å¿«é€ŸåŒ¹é…çš„ç›®çš„ã€‚å…·ä½“å®ç°å°±æ˜¯å®ç°ä¸€ä¸ª$next()$å‡½æ•°ï¼Œå‡½æ•°æœ¬èº«åŒ…å«äº†æ¨¡å¼ä¸²çš„å±€éƒ¨åŒ¹é…ä¿¡æ¯ã€‚ï¼ˆå¼ºè¡Œè§£é‡Šä¸€æ³¢å¤±é…å‡½æ•°ï¼‰ä¸Šæ³¢ä»£ç ï¼š 1234567891011121314151617181920int KMP(string W,string T)&#123; int i=1,j=1; while(i&lt;=n)&#123; while (j!=0&amp;&amp;W[j]!=T[i]) j=next[j]; if(j==m) return i-m+1;//åŒ¹é…æˆåŠŸï¼Œè¿”å›åŒ¹é…ä½ç½®s else&#123;j++; i++;&#125; &#125; return -1;//åŒ¹é…å¤±è´¥&#125;void GetNext(charT[],intnext[])&#123; next[1]=0; j=1;k=0; while(j&lt;T[0]) if((k==0)||(T[j]==T[k]))&#123; j++; k++; next[j]=k; &#125; else k=next[k];&#125; ï¼ˆå…¶å®å¹¶ä¸å¤ªæ¸…æ¥šå®ƒåˆ°åº•å…·ä½“æœ‰ä»€ä¹ˆç”¨ï¼‰=v= 2ã€æ•°è®ºã€å®šç† ï¼ˆä¸€å †å¥‡å¥‡æ€ªæ€ªçš„ä¸œè¥¿ï¼‰ï¼ˆè¾¹æ‰“è¾¹å¤ä¹ ï¼‰é¦–å…ˆä¸Šåœºçš„æ˜¯å”¯ä¸€åˆ†è§£å’Œ$lcm$ã€$gcd$ï¼ˆè¿™è´§è´¼é‡è¦ï¼‰ï¼Œç”±æ­¤å¼•ç”³çš„æ˜¯æ¬§å‡ é‡Œå¾—å’Œæ‰©å±•æ¬§ã€‚ //å¨å°”é€Šå®šç†//ï¼šå®ƒç»™å‡ºäº†åˆ¤å®šä¸€ä¸ªè‡ªç„¶æ•°æ˜¯å¦ä¸ºç´ æ•°çš„å……åˆ†å¿…è¦æ¡ä»¶ï¼Œå°±æ˜¯å½“ä¸”ä»…å½“$p$ä¸ºç´ æ•°æ—¶ï¼š$(p-1)!â‰¡-1(mod p)$ï¼Œä½†æ˜¯ç”±äºé˜¶ä¹˜æ˜¯å¢é•¿çš„é€Ÿåº¦å®åœ¨æ˜¯â€¦â€¦â€¦â€¦ï¼ˆæ‰€ä»¥ç»“è®ºå¯¹äºå®é™…æ“ä½œæ„ä¹‰ä¸å¤§ï¼Œæ„Ÿè§‰è¯´äº†åºŸè¯ï¼‰ //å°è´¹é©¬//ï¼šå‡å¦‚$p$æ˜¯è´¨æ•°ï¼Œä¸”$gcd(a,p)=1$ï¼Œé‚£ä¹ˆ$a(p-1)â‰¡1(mod\ p)$ï¼ˆå¼ºåˆ¶ä½¿ç”¨äº†ä¸€æ³¢$gcd$ï¼‰ï¼ˆå…¶ä¸­$gcd$ä¸º$1$ä»£è¡¨äº’è´¨ï¼‰ï¼ˆç»“æœè¯æ˜å‡ºæ¥äº†ï¼‰ï¼ˆè¯¥åŒä½™å¼å¯ä»¥è½¬ä¸º$apâ‰¡p(mod\ p)$ï¼Œä¸çŸ¥é“å†™çš„å¯¹ä¸å¯¹ï¼Œå¥½åƒæåˆ°è¿‡ï¼‰ //æ¬§æ‹‰å‡½æ•°ä¸å®šç†//ï¼šemmmï¼Œè¿™ç©æ„æˆ‘å®åœ¨ä¸æ˜¯å¾ˆæ‡‚,è®¤è¯†äº†ä¸€ä¸‹$Ï†$ï¼Œè¿˜æœ‰æ¬§æ‹‰å®šç†ï¼šè‹¥$gcd(a,p)=1$ï¼Œåˆ™$a^{Ï†(p)}â‰¡1(mod\ p)$ã€‚ //å…³äºè¿™äº›å®šç†çš„ä¾‹é¢˜ä½¿ç”¨//ï¼šä¸å¤ªç†Ÿç»ƒï¼Œä¸çŒ®ä¸‘=w=ï¼Œå­¦ä¹ å¤§ç¥ä»¬çš„å†™æ³•ï¼Œè´¹åŠ›çš„ç†è§£å•Šå•Šå•Šâ€¦â€¦â€¦â€¦ 3ã€$manacher$ ï¼ˆäºŒ%é£ç¥ï¼‰è¿™ä¸ªå’Œ$KMP$ä¸€æ ·ï¼Œæ˜¯å…³äºå­—ç¬¦ä¸²çš„ä¸€ç§ç®—æ³•ï¼Œä¸»è¦é’ˆå¯¹å›æ–‡ä¸²ã€‚ä»¥$Oï¼ˆnï¼‰$çš„æ—¶é—´å¤æ‚åº¦ä»¥æ¯ä¸ªå­—ç¬¦ä¸ºä¸­å¿ƒï¼Œä»¥å›æ–‡ä¸²å•ç¨‹é•¿åº¦ï¼Œå°†æ‰€å–å­—ç¬¦ä¸²æ‰©å±•ä¸€å€ã€‚å¦‚æœæ˜¯å¥‡æ•°ä¸²å°±èƒ½é¡ºåˆ©è¿›è¡Œï¼Œå¦‚æœå¶æ•°ä¸²ï¼Œé‚£å¿…é¡»æ’å…¥å¥‡æ€ªçš„å­—ç¬¦ã€‚ä½†è¿™ç§ç®—æ³•çš„ç¥å¥‡ä¹‹å¤„åœ¨äºå¯ä»¥åŒæ—¶è€ƒè™‘å¥‡ä¸²å’Œå¶ä¸²ã€‚ï¼ˆä½†ä¸èƒ½æ‹†ååŸå­—ç¬¦ä¸²ï¼‰ï¼ˆä»£ç å¥½é•¿ï¼Œæˆ‘å†³å®šä¸å‡‘å­—æ•°ï¼‰(ï¿£â–½ï¿£)â€ 4ã€çŠ¶å‹$DP$å¥½å§ï¼Œæˆ‘æ‰¿è®¤ä½è¿ç®—æˆ‘å®åœ¨æ˜¯çƒ‚é€äº†ï¼Œå®Œå…¨æ²¡è®°ä½ï¼Œå·®ç‚¹å¬æˆå¤§å¼±æ™ºâ•®(â•¯-â•°)â•­ ã€‚è¡¨ç¤ºçŠ¶å‹åˆ—ä¸¾çš„å­é›†æ—¢èƒ½å®Œå…¨æšä¸¾ï¼Œè¿˜èƒ½èŠ‚çº¦ä¸å¿…è¦åˆ—ä¸¾çš„æ—¶é—´â€¦â€¦ï¼ˆæ¥è‡ªèŒæ–°çš„ç¥å¥‡(âŠ™oâŠ™)ï¼‰ 5ã€æ ‘çš„$LCA$ ï¼ˆæ±‚æ ‘ä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯ï¼‰å…ˆä»æ ‘çš„$dfs$åºå…¥æ‰‹ï¼Œå±•å¼€å€å¢ï¼ˆçœ‹å¾—æ‡‚ï¼Œè¡¨ç¤ºä¸ä¼šå†™â€¦â€¦ï¼‰ï¼Œ$tarjan$ï¼ˆç«Ÿç„¶åŸºäºå†°èŒ¶å‡ ï¼ˆå¹¶æŸ¥é›†ï¼‰ï¼ï¼ï¼‰ï¼Œ$RMQ$ï¼Œ$emmm$ï¼ˆå›å»é‡æ–°å­¦ä¹ è¿é€šåˆ†é‡ï¼‰ã€‚ï¼ˆä¸å¥½éšä¾¿å£èƒ¡=-=ï¼Œå†³å®šç¿»å·¥å­¦ä¹ ï¼‰ 6ã€å·®åˆ† ï¼ˆä¸€èµ·è®²äº†å·®åˆ†çº¦æŸå§ï¼‰å·®åˆ†æ‰€æ“…é•¿åšçš„å°±æ˜¯æŠŠ$a$æ•°ç»„ä¸­$l~r$èŒƒå›´å†…çš„æ•°åŠ ä¸Šæˆ–å‡å»æŸä¸ª$k$å€¼ï¼Œè¿™æ ·åªè¦æ±‚å‰ç¼€å’Œï¼Œè¿ç”¨å·®åˆ†å°±åªè¦æ±‚å‰ç¼€å’Œï¼Œå°±èƒ½åœ¨$Oï¼ˆnï¼‰$çš„æ—¶é—´å†…å¾—åˆ°æ•´ä¸ªæ•°ç»„çš„å€¼ã€‚å·®åˆ†çº¦æŸå˜›ï¼Œæ˜¯åŸºäºå›¾è®ºçŸ¥è¯†$SPFA$å’Œåˆ¤ç¯çš„ï¼Œæ¯”å¦‚æˆ‘ä»¬å¾—åˆ°$a[x]]]></content>
      <categories>
        <category>5/6æœˆé›†è®­</category>
      </categories>
      <tags>
        <tag>Total Review</tag>
      </tags>
  </entry>
</search>
