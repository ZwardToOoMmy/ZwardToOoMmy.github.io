<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[蒟蒻⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄报道 (置顶)(置顶)]]></title>
    <url>%2F2099%2F12%2F31%2F%E8%92%9F%E8%92%BB%E6%8A%A5%E9%81%93!(%E5%8D%9A%E5%AE%A2%E5%BA%8F%E6%9B%B2)%2F</url>
    <content type="text"><![CDATA[这篇文章的出现，预示着时隔多年，我的博客终于要启用啦！撒花花]]></content>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想看的电影噫~]]></title>
    <url>%2F2098%2F03%2F17%2F%E6%83%B3%E7%9C%8B%E7%9A%84%E7%94%B5%E5%BD%B1%E5%99%AB%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~清单1、《比悲伤更悲伤的故事》 2、我想吃掉你的胰脏]]></content>
      <tags>
        <tag>Life is Wonderful!</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Z Function (Z Algorithm)]]></title>
    <url>%2F2019%2F04%2F10%2FZ-Function-Z-Algorithm%2F</url>
    <content type="text"><![CDATA[有一种算法，名叫 “Z Function”CF的原文 一位大佬的解释]]></content>
      <categories>
        <category>空闲时间的小点心</category>
      </categories>
      <tags>
        <tag>Magical Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2005 聪聪与可可]]></title>
    <url>%2F2019%2F04%2F07%2FNOI2005-%E8%81%AA%E8%81%AA%E4%B8%8E%E5%8F%AF%E5%8F%AF%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~聪聪与可可题面在一个魔法森林里，住着一只聪明的小猫聪聪和一只可爱的小老鼠可可。虽 然灰姑娘非常喜欢她们俩，但是，聪聪终究是一只猫，而可可终究是一只老鼠， 同样不变的是，聪聪成天想着要吃掉可可。 一天，聪聪意外得到了一台非常有用的机器，据说是叫 $GPS$，对可可能准确 的定位。有了这台机器，聪聪要吃可可就易如反掌了。于是，聪聪准备马上出发， 去找可可。而可怜的可可还不知道大难即将临头，仍在森林里无忧无虑的玩耍。 小兔子乖乖听到这件事，马上向灰姑娘报告。灰姑娘决定尽快阻止聪聪，拯救可 可，可她不知道还有没有足够的时间。 整个森林可以认为是一个无向图，图中有 $N$ 个美丽的景点，景点从 $1$ 至 $N$ 编号。小动物们都只在景点休息、玩耍。在景点之间有一些路连接。 当聪聪得到 $GPS$ 时，可可正在景点 $M$($M\le N$)处。以后的每个时间单位，可可 都会选择去相邻的景点(可能有多个)中的一个或停留在原景点不动。而去这些地方所发生的概率是相等的。假设有 $P$ 个景点与景点 M 相邻，它们分别是景点 R、 景点 S，……景点 Q，在时刻 $T$ 可可处在景点 M，则在( $T+1$ )时刻，可可有 $\frac 1{1+p}$ 的可能在景点 R，有 $\frac 1{1+p}$ 的可能在景点 S，……，有 $\frac 1{1+p}$ 的可能在景点 Q，还有$\frac 1{1+p}​$ 的可能停在景点 M。 我们知道，聪聪是很聪明的，所以，当她在景点 C 时，她会选一个更靠近 可可的景点，如果这样的景点有多个，她会选一个标号最小的景点。由于聪聪太 想吃掉可可了，如果走完第一步以后仍然没吃到可可，她还可以在本段时间内再 向可可走近一步。 在每个时间单位，假设聪聪先走，可可后走。在某一时刻，若聪聪和可可位 于同一个景点，则可怜的可可就被吃掉了。 灰姑娘想知道，平均情况下，聪聪几步就可能吃到可可。而你需要帮助灰姑 娘尽快的找到答案。 Input数据的第 $1$ 行为两个整数 $N$ 和 $E$，以空格分隔，分别表示森林中的景点数和 连接相邻景点的路的条数。 第 $2$ 行包含两个整数 $C$ 和 $M$，以空格分隔，分别表示初始时聪聪和可可所在的景点的编号。 接下来 $E$ 行，每行两个整数，第 $i+2$ 行的两个整数 $A_i$和$B_i$ 表示景点 $A_i$和景点 $B_i$ 之间有一条路。 所有的路都是无向的，即：如果能从 $A$ 走到 $B$，就可以从 $B$ 走到 $A$。 输入保证任何两个景点之间不会有多于一条路直接相连，且聪聪和可可之间必有路直接或间接的相连。 Output 输出 $1$ 个实数，四舍五入保留三位小数，表示平均多少个时间单位后聪聪会把可可吃掉。 Sample Input 14 31 41 22 33 4 Sample Output 11.500 Sample Input 29 99 31 22 33 44 53 64 64 77 88 9 Sample Output 22.167 Hint对于 $50\%$ 的数据，$1≤N≤50​$。 对于所有的数据，$1\le N,E\le 1000​$。 题目是说，聪聪能走一步或两步，可可能不动；聪聪一定会走离可可最近的点中编号最小的点。 预处理 ： 预处理出每个点之间的最短路径$Dis​$。 枚举聪聪和可可各在$i、j$的情况，聪聪下一步会走到的点$NextStep$。 设$dp_{i,j}$表示聪聪在$i$，可可在$j$时，聪聪抓到可可的概率。 我们很容易的分类推出： 聪聪可可在一个点上时 → $dp_{i,j}=0$ 聪聪可以在一次行动后就能够抓到可可 → $dp_{i,j}=1$ 非以上情况，则猫肯定要走两步以上，那么走两步的结果肯定优于只走一步，设聪聪在走$2$步之后会走到$k$，可可能够到达$l$ → $dp_{i,j}=\frac 1{p_j+1}\sum dp_{k,l}+1$ 通过记搜来优化即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x=0,w=0; char ch=0; while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return w? -x:x;&#125;const int N=1010;struct edge&#123; int to,nxt;&#125;e[N&lt;&lt;1];int linkk[N&lt;&lt;1],len;int n,E,c,m;void insert(int u,int v)&#123; e[++len].to=v,e[len].nxt=linkk[u],linkk[u]=len; e[++len].to=u,e[len].nxt=linkk[v],linkk[v]=len;&#125;int dis[N][N],nextstep[N][N];bool flag[N][N],vis[N];double dp[N][N];int p[N];queue&lt;int&gt; q;void spfa(int i)&#123; memset(vis,0,sizeof(vis)); dis[i][i]=0; q.push(i); while(!q.empty()) &#123; int x=q.front(); q.pop(); vis[x]=0; for(int j=linkk[x];j;j=e[j].nxt) &#123; int to=e[j].to; if(dis[i][x]+1&lt;dis[i][to]) &#123; dis[i][to]=dis[i][x]+1; if(vis[to]) continue; vis[to]=1; q.push(to); &#125; &#125; &#125;&#125;bool visi[N][N];double DP(int u,int v)&#123; // cerr&lt;&lt;"TET"&lt;&lt;endl; if(visi[u][v]) return dp[u][v]; if(u==v) return 0; int p1=nextstep[u][v],p2=nextstep[p1][v]; if(p1==v||p2==v) return 1; dp[u][v]=1; for(int i=linkk[v];i;i=e[i].nxt) &#123; int to=e[i].to; dp[u][v]+=DP(p2,to)/(p[v]+1); &#125; dp[u][v]+=DP(p2,v)/(p[v]+1); visi[u][v]=1; return dp[u][v];&#125;int main(int argc, char const *argv[])&#123; n=read(),E=read(),c=read(),m=read(); for(int i=1;i&lt;=E;++i) &#123; int a=read(),b=read(); insert(a,b); ++p[a],++p[b]; &#125; memset(dis,0x7f,sizeof(dis)); memset(nextstep,0x7f,sizeof(nextstep)); for(int i=1;i&lt;=n;++i) spfa(i); for(int i=1;i&lt;=n;++i) &#123; for(int j=linkk[i];j;j=e[j].nxt) &#123; int to=e[j].to; for(int k=1;k&lt;=n;++k) if(dis[i][k]-1==dis[to][k]) nextstep[i][k]=min(nextstep[i][k],to); &#125; &#125; printf("%.3lf\n",DP(c,m)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Daily-Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO2019.JAN Exercise Route]]></title>
    <url>%2F2019%2F04%2F01%2FUSACO2019-JAN-Exercise-Route%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~#.Exercise Route简要翻译奶牛Bessie意识到为了保持好的体形她需要更多地进行锻炼。她需要你帮助她选择在农场里每天用来晨跑的路线。 农场由N块草地组成，方便起见编号为$1…N$，由$M$条双向的小路连接。作为一种遵循规律的生物，奶牛们倾向于使用其中特定的$N−1​$条小路作为她们日常在草地之间移动的路线——她们管这些叫“常规的”小路。从每块草地出发都可以仅通过常规的小路到达所有其他草地。 为了使她的晨跑更加有趣，Bessie觉得她应该选择一条包含一些非常规的小路的路线。然而，使用常规的小路能够使她感到舒适，所以她不是很想在她的路线中使用过多非常规的小路。经过一些思考，她认为一条好的路线应当形成一个简单环（能够不经过任何草地超过一次的情况下回到起点），其中包含恰好两条非常规的小路。 请帮助Bessie计算她可以使用的好的路线的数量。两条路线被认为是相同的，如果它们包含的小路的集合相等。 Input输入的第一行包含$N$和$M$。以下$M$行每行包含两个整数$a_i$和$b_i$，描述了一条小路的两端。其中前$N−1$条是常规的小路。 Output输出一个整数代表Bessie可以选择的路线数。 Sample Input5 81 21 31 41 52 33 44 55 2 Sample Output4 Hint$1≤N≤2×10^5$，$1≤M≤2×10^5$。 显然常规的小路就是一棵树（规定的树），非常规的小路就是非树边。 $Bessie$ 想要选择的路线，是一个简单环，即能够从起点出发回到起点的过程中至多经过其他所有的点一次，同时要求这个环上有两条非树边 。 我们可以自己手推出一个结论： 每条非树边在树上两端点之间的路径如果和另一条非树边在树上两端点之间的路径有重边，那么树上的边加上这两条边就能组成一个环，而这两条非树边两端点树上路径之间的重边则不属于这个环。 （下文非树边在树上两端点之间的路径简称“graph”） 由这个结论又可以推得： 如果两条graph1和graph2之间有重叠，则他们各自LCA1和LCA2下都可拆为两条链，判断这些链是否相交即可。重复计算的情况可从结果中记录减掉。 那怎么统计要减掉重复的路径呢？ 我们回去看看题目，发现这题并没有在查询间的加入修改，那么可以离线处理。 在每一段询问区间的开始减掉最前端的节点在该区间之前的区间的数量；同时在每个区间的结尾加上最前端的节点在该区间的结尾之前的区间数量。 这样遍历一遍所有区间，然后再开始和结尾做差分处理，对于这个类似于做了差分处理的区间求前缀和，再遍历所有区间，每个区间进行答案的刚才做的统计的加减即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;int n, m;struct edge &#123; int to, nxt;&#125; e[400010];int linkk[400010], len;void insert(int u, int v)&#123; e[++len].to = v, e[len].nxt = linkk[u], linkk[u] = len; e[++len].to = u, e[len].nxt = linkk[v], linkk[v] = len;&#125;int fa[22][200010];int depth[200010];bool vis[200010];pair&lt;int, int&gt; p[200010];int bucket[200010], cnt[200010], ans[200010];map&lt;pair&lt;int, int&gt;, int&gt; CntP;void dfs(int x, int father)&#123; vis[x] = 1; depth[x] = depth[father] + 1; for (int j = 1; j &lt;= 20; ++j) fa[j][x] = fa[j - 1][fa[j - 1][x]]; for (int i = linkk[x]; i; i = e[i].nxt) &#123; int to = e[i].to; if (to == father || vis[to]) continue; fa[0][to] = x; dfs(to, x); &#125;&#125;int lca(int x, int y)&#123; if (depth[x] &lt; depth[y]) swap(x, y); for (int i = 20; ~i; --i) if (depth[fa[i][x]] &gt;= depth[y]) x = fa[i][x]; if (x == y) return x; for (int i = 20; ~i; --i) if (fa[i][x] != fa[i][y]) x = fa[i][x], y = fa[i][y]; return fa[0][x];&#125;int gofront(int bottom, int top)&#123; if (bottom == top) return -521; for (int i = 20; ~i; --i) if (depth[fa[i][bottom]] &gt; depth[top]) bottom = fa[i][bottom]; return bottom;&#125;void finddfs(int x, int t)&#123; cnt[x] = t; for (int i = linkk[x]; i; i = e[i].nxt) &#123; int to = e[i].to; if (to == fa[0][x]) continue; finddfs(to, t + bucket[to]); &#125;&#125;long long res = 0;int main(int argc, char const *argv[])&#123; n = read(), m = read(); for (int i = 1; i &lt; n; ++i) &#123; int U = read(), V = read(); insert(U, V); &#125; dfs(1, 1); for (int i = 1; i &lt;= m - n + 1; ++i) &#123; p[i].first = read(); p[i].second = read(); ans[i] = lca(p[i].first, p[i].second); int x = gofront(p[i].first, ans[i]); if (x != -521) res -= bucket[x] + 1, ++bucket[x]; int y = gofront(p[i].second, ans[i]); if (y != -521) res -= bucket[y] + 1, ++bucket[y]; if (x != -521 &amp;&amp; y != -521) &#123; if (x &gt; y) swap(x, y); res -= CntP[make_pair(x, y)]; ++CntP[make_pair(x, y)]; &#125; &#125; finddfs(1, 0); for (int i = 1; i &lt;= m - n + 1; ++i) res += cnt[p[i].first] + cnt[p[i].second] - (cnt[ans[i]] &lt;&lt; 1); printf("%lld\n", res); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Daily-Probablity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#123 E.Maze]]></title>
    <url>%2F2019%2F04%2F01%2FCodeForces-123-E-Maze%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~#.Maze题面A maze is represented by a tree (an undirected graph, where exactly one way exists between each pair of vertices). In the maze the entrance vertex and the exit vertex are chosen with some probability. The exit from the maze is sought by Deep First Search. If there are several possible ways to move, the move is chosen equiprobably. Consider thefollowing pseudo-code: 12345678910DFS(x) if x == exit vertex then finish search flag[x] &lt;- TRUE random shuffle the vertices' order in V(x) // here all permutations have equal probability to be chosen for i &lt;- 1 to length[V] do if flag[V[i]] = FALSE then count++; DFS(y); count++; $V(x)$ is the list vertices adjacent to $x$. The $flag$ array is initially filled as FALSE. $DFS$ initially starts with a parameter of an entrance vertex. When the search is finished, variable $count$ will contain the number of moves. 简要翻译一棵 $n$ 个点的树，起点和终点随机选取。运行如下程序， $V(x)$ 是与 $x$ 相邻的顶点列表，最初 $flag$ 数组为 $false$,$DFS$ 的参数是起点，你要求 $count$ 的期望值。 （自己给洛谷的翻译跪着也要搬过来） Input第一行一个数 $n$，表示个节点。接下来 $n-1$ 行，每行两个数$(u,v)$,表示有一条从 $u$，到$v$的无向边。然后是$n$行，每行描述一个节点表示该节点被选为进入点的 $x$ 和该节点被选为离开的 $y$ 。 此处的x和y用于求每个点被选为进入点的概率和被选为离开点的概率，即：$p[x]=\frac{x}{sum(x)}$,$p[y]=\frac{y}{sum(y)}​$. Output一个实数表示$count$的期望。 （误差允许范围$\le 10^9$） Sample Input 12 1 2 0 1 1 0 Sample Output 11.00000000000000000000 Sample Input 23 1 2 1 3 1 0 0 2 0 3 Sample Output 22.00000000000000000000 Sample Input 37 1 2 1 3 2 4 2 5 3 6 3 7 1 1 1 1 1 1 1 1 1 1 1 1 1 1 Sample Output 34.04081632653 Hint$n&lt;10^5​$ 突然发现这是一道比较经典的题，讲课时被提到了好几次，我神奇般的给了某谷一个强有力的翻译，不扯了（竟然知道在扯）。 看过随机树那篇题解的都知道。（又骗人去刷博客访问量） (原谅我直接截图) 题面非常的显然，那么我们先求出每一棵子树的大小，设一个$P_x$表示当$x$被当做离开点时，从别的子树出发到达他的概率。 使用$DFS$求出子树大小，同时求出该子树中每个点被选为$Enter$的概率和，并且枚举每个点作为$Exit​$。 用之前的那个公式求出以该节点为根节点的子树出发到该节点的期望以及从别的子树出发到该节点的期望。 设这个点为$x$，对于它以外的子树将其看作$x​$的另一子树。 这样一设计，这题似乎就可以Van爆了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x=0,w=0; char ch=0; while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return w? -x:x;&#125;int n;vector&lt;int&gt; v[100010];int sz[100010],fa[100010];double P_in[100010],P_out[100010],res,Sin,Sout;bool vis[100010];#define Size_ v[x].size() #define to v[x][i]void dfs(int x,int father)&#123; ++sz[x]; vis[x]=1; for(int i=0;i&lt;Size_;++i) &#123; if(to==father||vis[to]) continue; dfs(to,x); fa[to]=x; sz[x]+=sz[to],P_in[x]+=P_in[to]; &#125;&#125;int main(int argc, char const *argv[])&#123; n=read(); for(int i=1;i&lt;n;++i) &#123; int U=read(),V=read(); v[U].push_back(V); v[V].push_back(U); &#125; for(int i=1;i&lt;=n;++i) Sin+=P_in[i]=read(),Sout+=P_out[i]=read(); for(int i=1;i&lt;=n;++i) P_in[i]/=Sin; dfs(1,1); for(int x=1;x&lt;=n;++x) for(int i=0;i&lt;Size_;++i) &#123; if(to==fa[x]) res+=(1-P_in[x])*(n-sz[x])*P_out[x]; else res+=P_in[to]*sz[to]*P_out[x]; &#125; printf("%.12lf",res/Sout); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Daily-Probablity</tag>
        <tag>Daily-Expectation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NewCoder The Trip On Abandoned Railway]]></title>
    <url>%2F2019%2F03%2F27%2FNewCoder-The-Trip-On-Abandoned-Railway%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~The Trip On Abandoned Railway题面There are many ghosts at the abandoned station on unknown railway. We mark the abandoned stations as $1,2..n$ according to the order. There are $a_i$ ghosts at the $i^{th}$ station.Yakumo Yukari often opens a black hole and makes a train appearing at a certain station. For example, the train appears at the $x$ station, and $k$ ghosts get off at the station. Then there would be $k+d$ ghosts at the $x+1$ station to get off,$k+2×d$ at $x+2$ station and so on….There would be $k+y∗d$ ghosts at the $x+y$ station to get off ($0≤y,x+y≤n$). In others words, the numbers getting off at $x,x+1,x+2..n$ station form a tolerance of $d$ arithmetic progression.(you can consider ghosts getting off at the same time.)Onozuka Komachi would comes a certain station to take away the ghosts.(The number of ghosts at the station would become $0$)You have the records of trains appearing and Komachi coming. You should tell Komachi how much ghosts at a certain station when she come to there. 简要翻译一开始给定一个序列$a_i$，你要进行两种操作。 从第$x$个位置到第$n$个位置，分别加上$y,y+d,y+2×d,y+3×d…$的一个等差数列。 询问第$x$个位置的数，并且将该位置清零。 Input第一行包含一个整数$T$，表示测试数据的组数。 每组数据第一行包含三个整数$n$,$m$,$d$，其中$n$表示序列长度，$m$表示操作个数，$d$表示等差数列的公差。第二行包含$n$个整数，表示$a_i$。下面包含$m$行，每行开头一个整数$1/2$，表示操作类型。 如果是$1$，则下面有两个整数$x$,$y$如题意。 如果是$2$，则下面包含一个整数$x$表示要查询的位置。 Output对于每个$2$操作，输出一个整数表示答案。 Sample Input26 6 11 2 3 3 2 11 1 12 12 22 32 42 55 3 21 2 3 4 51 3 02 42 4 Simple Output2467760 Hint$1\le T\le 10$。 $1\le n\le 10^5$，$1\le m\le 10^5$，$1\le d\le 10^3$。 $1\le a_i\le 10^3$，$1\le x\le n$，$0\le y\le 10^3$。 样例说明说明每一次操作后的序列： 12345678case1：1 2 3 3 2 12 4 6 7 7 70 4 6 7 7 70 0 6 7 7 70 0 0 7 7 70 0 0 0 7 70 0 0 0 0 7 12345case2：1 2 3 4 51 2 3 6 91 2 3 0 91 2 3 0 9 emmmmm，之前做过一道题，所以这题切起来比较轻松。 加上等差数列，我们明显就可以知道，等差数列每一项之差就是$d$，所以我们只要将$x+1$~$n$的位置都加上$d$，用线段树修改区间，在$x$的位置上用树状数组单点修改。查询时，求出线段树上$x$的前缀表示修改的总和，加上树状数组$x$位置的值和原本该位置上的值，求和即可。对于清空操作，也只要对这位减掉查询出来的值即可。 Code说起来容易，但是，我只想说，这题的代码真的有毒，中间取模你的答案就错了，中间不能取模，也不会爆掉long long。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;using namespace std;long long read()&#123; long long x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const long long mod = 1e9 + 7;int T;long long n, m, d;struct seg_tree&#123; long long s, lazy_tag;&#125; t[100010 &lt;&lt; 2];long long tpre[100010 &lt;&lt; 2];int lowbit(int x)&#123; return x &amp; -x;&#125;void modify(int x, long long y)&#123; while (x &lt;= 100000) &#123; (tpre[x] += y) %= mod; x += lowbit(x); &#125;&#125;long long getpre(int x)&#123; long long ans = 0; while (x) &#123; (ans += tpre[x]) %= mod; x -= lowbit(x); &#125; return ans;&#125;long long a[100010];inline void pushdown(int root, int len)&#123; if (!t[root].lazy_tag) return; t[root &lt;&lt; 1].lazy_tag += t[root].lazy_tag; t[root &lt;&lt; 1 | 1].lazy_tag += t[root].lazy_tag; t[root &lt;&lt; 1].s += (len - (len &gt;&gt; 1)) * t[root].lazy_tag; t[root &lt;&lt; 1 | 1].s += (len &gt;&gt; 1) * t[root].lazy_tag; t[root].lazy_tag = 0;&#125;inline void pushup(int root)&#123; t[root].s = t[root &lt;&lt; 1].s + t[root &lt;&lt; 1 | 1].s;&#125;void build(int root, int l, int r)&#123; if (l == r) &#123; t[root].s = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(root &lt;&lt; 1, l, mid); build(root &lt;&lt; 1 | 1, mid + 1, r); pushup(root);&#125;void change(int root, int l, int r, int ll, int rr, long long y)&#123; if (l &gt; rr || r &lt; ll) return; if (ll &lt;= l &amp;&amp; r &lt;= rr) &#123; t[root].s += (r - l + 1) * y; t[root].lazy_tag += y; return; &#125; pushdown(root, r - l + 1); int mid = l + r &gt;&gt; 1; if (ll &lt;= mid) change(root &lt;&lt; 1, l, mid, ll, rr, y); if (rr &gt; mid) change(root &lt;&lt; 1 | 1, mid + 1, r, ll, rr, y); pushup(root);&#125;long long query(int root, int l, int r, int ll, int pos)&#123; if (l &gt; pos || r &lt; ll) return 0; if (ll &lt;= l &amp;&amp; r &lt;= pos) return t[root].s; pushdown(root, r - l + 1); int mid = l + r &gt;&gt; 1; long long A = 0; if (ll &lt;= mid) A += query(root &lt;&lt; 1, l, mid, ll, pos); if (pos &gt; mid) A += query(root &lt;&lt; 1 | 1, mid + 1, r, ll, pos); pushup(root); return A;&#125;// long long cutt[100010];int main()&#123; T = read(); while (T--) &#123; memset(t, 0, sizeof(t)); memset(tpre, 0, sizeof(tpre)); n = read(), m = read(), d = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); // build(1,1,n); for (int i = 1; i &lt;= m; ++i) &#123; int opt = read(); if (opt == 1) &#123; long long x = read(), y = read(); modify(x, y); if (x &lt; n) change(1, 1, n, x + 1, n, 1); &#125; else &#123; int x = read(); // cerr&lt;&lt;"-----"&lt;&lt;t[8].s&lt;&lt;"-----"&lt;&lt;endl; long long p = (getpre(x) + query(1, 1, n, 1, x) * d + a[x]); // cerr&lt;&lt;"-----"&lt;&lt;p&lt;&lt;"-----"&lt;&lt;endl; printf("%lld\n", p % mod); a[x] -= p; // cut(1,1,n,x,x,p+a[x]); // (((cutt[x] += a[x] + p) %= mod) += mod) %= mod; // for(int j=1;j&lt;=n;++j) cerr&lt;&lt;"---"&lt;&lt;a[j]+query(1,1,n,1,j); // cerr&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Daily-Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.3.17周末省选模拟爆零赛]]></title>
    <url>%2F2019%2F03%2F17%2F2019-3-17%E5%91%A8%E6%9C%AB%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%E7%88%86%E9%9B%B6%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~3.17周末训练 Code~ Wolf ~12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x=0,w=0; char ch=0; while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return w? -x:x;&#125;int n,attack;struct wolf_data&#123; int atk,bonus,hp;&#125;w[410];int times[410];int f[910][910];int main(int argc, char const *argv[])&#123; freopen("wolf.in","r",stdin); freopen("wolf.out","w",stdout); n=read(),attack=read(); for(int i=1;i&lt;=n;++i) w[i].atk=read(),w[i].bonus=read(),w[i].hp=read(),times[i]=(w[i].hp/attack)+(w[i].hp%attack!=0); memset(f,0x3f,sizeof(f)); for(int i=1;i&lt;=n;++i) f[i][i]=times[i]*(w[i].atk+w[i-1].bonus+w[i+1].bonus); for(int i=1;i&lt;=n+10;++i) f[i][i-1]=0; for(int i=2;i&lt;=n;++i) for(int len=1;len&lt;=n-i+1;++len) &#123; int j=i+len-1; for(int k=len;k&lt;=j;++k) f[len][j]=min(f[len][j],f[len][k-1]+f[k+1][j]+(w[k].atk+w[len-1].bonus+w[j+1].bonus)*times[k]); &#125; cout&lt;&lt;f[1][n]&lt;&lt;endl; return 0;&#125; ~ Sum ~12 ~ RSMT ~（提交答案）12]]></content>
      <categories>
        <category>日常-训练</category>
      </categories>
      <tags>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2009普及 T4 道路游戏]]></title>
    <url>%2F2019%2F03%2F11%2FNOIP2009%E6%99%AE%E5%8F%8A-T4-%E9%81%93%E8%B7%AF%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~[NOIP2009普及]T4 道路游戏题面小新正在玩一个简单的电脑游戏。 游戏中有一条环形马路，马路上有 $n$ 个机器人工厂，两个相邻机器人工厂之间由一小段马路连接。小新以某个机器人工厂为起点，按顺时针顺序依次将这 $n$ 个机器人工厂编号为$1−n$，因为马路是环形的，所以第$n$个机器人工厂和第$1$个机器人工厂是由一段马路连接在一起的。小新将连接机器人工厂的这 $n$ 段马路也编号为 $1−n$，并规定第 $i$ 段马路连接第 $i$ 个机器人工厂和第 $i+1$ 个机器人工厂（$1≤i≤n-1$），第 $n$ 段马路连接第 $n$ 个机器人工厂和第$1$个机器人工厂。 游戏过程中，每个单位时间内，每段马路上都会出现一些金币，金币的数量会随着时间发生变化，即不同单位时间内同一段马路上出现的金币数量可能是不同的。小新需要机器人的帮助才能收集到马路上的金币。所需的机器人必须在机器人工厂用一些金币来购买，机器人一旦被购买，便会沿着环形马路按顺时针方向一直行走，在每个单位时间内行走一次，即从当前所在的机器人工厂到达相邻的下一个机器人工厂，并将经过的马路上的所有金币收集给小新，例如，小新在 $i$（$1≤i≤n$）号机器人工厂购买了一个机器人，这个机器人会从i号机器人工厂开始，顺时针在马路上行走，第一次行走会经过i号马路，到达 $i+1$号机器人工厂（如果$i=n$，机器人会到达第$1$个机器人工厂），并将$i$号马路上的所有金币收集给小新。 游戏中，环形马路上不能同时存在$2$个或者$2$个以上的机器人，并且每个机器人最多能够在环形马路上行走$p$次。小新购买机器人的同时，需要给这个机器人设定行走次数，行走次数可以为 $1$~$p$ 之间的任意整数。当马路上的机器人行走完规定的次数之后会自动消失，小新必须立刻在任意一个机器人工厂中购买一个新的机器人，并给新的机器人设定新的行走次数。 以下是游戏的一些补充说明： 游戏从小新第一次购买机器人开始计时。 购买机器人和设定机器人的行走次数是瞬间完成的，不需要花费时间。 购买机器人和机器人行走是两个独立的过程，机器人行走时不能购买机器人，购买完机器人并且设定机器人行走次数之后机器人才能行走。 在同一个机器人工厂购买机器人的花费是相同的，但是在不同机器人工厂购买机器人的花费不一定相同。 购买机器人花费的金币，在游戏结束时再从小新收集的金币中扣除，所以在游戏过程中小新不用担心因金币不足，无法购买机器人而导致游戏无法进行。也因为如此，游戏结束后，收集的金币数量可能为负。 现在已知每段马路上 $m​$ 个单位时间后，扣除购买机器人的花费，小新最多能收集到多少金币。 Input第一行 $3$ 个正整数$n,m,p$，意义如题目所述。 接下来的$n​$行，每行有 $m​$ 个正整数，每两个整数之间用一个空格隔开，其中第 $i​$ 行描述了 $i​$ 号马路上每个单位时间内出现的金币数量（$1≤金币数量≤100​$），即第 $i​$ 行的第 $j​$（$1≤j≤m​$）个数表示第 $j​$ 个单位时间内 $i​$ 号马路上出现的金币数量。 最后一行，有 $n​$ 个整数，每两个整数之间用一个空格隔开，其中第 $i​$ 个数表示在 $i​$ 号机器人工厂购买机器人需要花费的金币数量（$1≤金币数量≤100​$）。 Output共一行，包含 $1$ 个整数，表示在 $m$ 个单位时间内，扣除购买机器人 花费的金币之后，小新最多能收集到多少金币。 Sample Input2 3 21 2 32 3 41 2 Sample Output5 Hint【数据范围】 对于 40%的数据，$2≤n≤40,1≤m≤40$。 对于 90%的数据，$2≤n≤200,1≤m≤200$。 对于 100%的数据，$2≤n≤1000,1≤m≤1000,1≤p≤m$。 题解我们在做此题之前，先将环的标号标为$0$~$n-1​$以便于取模直接处理。 我们先来手推一波样例（$t_{i,j}$表示第i条路在第j个单位时间的价值，路边的×n代表该条路会被经过n次，我们给第一个机器人设定2个单位时间，第二个机器人设定1个单位时间）： 我们用$f_i$表示在第$i$个单位时间的最大金币数，$cost_i$代表第$i$个工厂买机器人的钱，$val_{i,j}$代表在第$i$个时刻到达$j$号工厂的价值，$sum_{i,j}$为其前缀和。 我们先将节点编号为0~n-1。 由于第$i$条路指向第$i+1$号工厂，那么，我们不妨直接把第$i$条路的价值变成第$i+1$号工厂的价值。 因为价值受到工厂序号和单位时间这两个约束限制，我们对价值进行二维前缀和处理，我们可以在当前机器人始末进行差分处理，求出总共经过的路的取得的价值。 先从$O(n^3)$说起。 首先，我们可以写出一个$dp$方程来： f_i=Max(f_{i-k}+sum_{i,j}-sum_{i-k,j-k}-cost_{j-k})机器人从$j-k$号工厂出发，走$k$个时间单位在$i$个时间单位走到$j$号工厂，求出$Max(f)$。 唔，其实如果考试时间不够，我觉得对于$n\le 200$的数据完全没有问题，想想你已经拿到了$90$分。 但是对于练题来说，我们应该去想想1000的数据： emmm，$i,j$固定，只在枚举$k$时，好像$sum[i][j]$不会改变，先拿出来再说。 f_i=Max(f_{i-k}-sum_{i-k,j-k}-cost_{j-k})+sum_{i,j}我们其实可以发现： $f_{i-k}-sum_{i-k,j-k}-cost_{j-k}$中，我们各项随着$k$的改变而变动，那么由于所有的下标都同时减$k$其实就是在二维前缀$sum$的对角线上取$f_{i-k}-sum_{i-k,j-k}-cost_{j-k}$整体的最大值。 ok，那么直接用堆来维护这一坨的最大值吧！好像这样复杂度就降为了$O(n^2logn)​$，足以过这题了。 Code12]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Daily-Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.3.9三八爆零赛II]]></title>
    <url>%2F2019%2F03%2F09%2F2019-3-9%E4%B8%89%E5%85%AB%E7%88%86%E9%9B%B6%E8%B5%9BII%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019.3.8 三八爆零赛II]]></content>
      <categories>
        <category>日常-训练</category>
      </categories>
      <tags>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.3.8三八爆零赛I]]></title>
    <url>%2F2019%2F03%2F08%2F2019-3-8%E4%B8%89%E5%85%AB%E7%88%86%E9%9B%B6%E8%B5%9BI%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019.3.8 三八爆零赛I]]></content>
      <categories>
        <category>日常-训练</category>
      </categories>
      <tags>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHOI 2012 D1-T3 随机树]]></title>
    <url>%2F2019%2F03%2F03%2FSHOI-2012-D1-T3-%E9%9A%8F%E6%9C%BA%E6%A0%91%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~[SHOI2012] 随机树题面 Input输入仅有一行，包含两个正整数 $q, n​$，分别表示问题编号以及叶结点的个数。 Output输出仅有一行，包含一个实数 $d​$，四舍五入精确到小数点后 $6​$ 位。如果 $q = 1​$，则 $d​$ 表示叶结点平均深度的数学期望值；如果 $q = 2​$，则 $d​$ 表示树深度的数学期望值。 Sample Input/Output Sample Input 1 Sample Output 1 1 4 2.166667 Sample Input 2 Sample Output 2 2 4 2.666667 Sample Input 3 Sample Output 3 1 12 4.206421 Sample Input 4 Sample Output 4 2 12 5.916614 Hint#1,2:$q=1,2\le n\le 10$ #3,4,5:$q=1,2\le n\le 100$ #6,7:$q=2,2\le n\le 10$ #8,9,10:$q=2,2\le n\le 100​$ 对于第1问： 要求平均叶子节点的深度的期望，用$dp$写。 有个很显然的$dp$方程，设$f[i]$代表有$i$个叶子节点时树的平均深度，每展开一次就会多出来一个叶子节点，所以状态直接由$f[i-1]→f[i]$，有一个比较显然的方程$f[i]=f[i-1]+\frac 2i$。 怎么说呢，比较显然的规律： 假设我们当前已经生成了$i-1​$的节点，因为这是一棵二叉树，所以我们第$i​$个节点只有$i​$个地方可以生成（不信的话你们可以自己xjb画一棵树试试）。我们只有在深度最深的那个节点处加左/右儿子的话才能够使$i​$个节点的树平均深度增加，即我们有$\frac 2i​$的概率能使$i-1​$个节点的树$+1​$深度，就能得到上一方程。 （好像有点问题，下面好像比较对，2019.3.13留） 由于我们要求平均值，若我们当我们要生成$i​$个叶节点时，设当前要展开一个叶子节点$x​$，原$i-1​$个叶子节点深度和为$f[i-1]×(i-1)​$，我们可以所有已有的叶节点的深度看成是平均深度（本题的精髓），即我们新展开出来的叶节点$i​$的父亲$x​$深度为$f[i-1]​$，$i​$的深度是$f[i-1]+1​$，那么我们要使原叶子节点$x​$同时有左右儿子，并且我们此时的$x​$节点已经不是叶子节点了，所以有$dp​$方程： f[i]=\frac {f[i-1]×(i-1)+(f[i-1]+1)×2-f[i-1]}{i}=\frac {f[i-1]*i+2}{i}=f[i-1]+\frac 2i​初始状态$f[1]​$=0。 答案为$ans=f[n]​$。 对于第2问： 在做这一问前，我们先来看个公式： 令任意一个变量$k​$的期望为$E(x)​$。 那么$E(x)=\sum_{i=1}^{+∞}P_iW_i$。 展开一次的贡献只能是$1$，此时有$W_i=1(i∈N^*)$ 这样我们就将题目中所要求的的期望转化成了求概率。 那么我们所要求的$E(x)=\sum_{i=1}^{+∞}P_i​$ 对于第二问，设我们当前这棵树有$i$个叶子节点，深度$≥j$，出现这样的状态的概率为$f[i][j]$。 我们是否要$for(int\ i=1;;++i)​$呢？ 显然是不用的： ∵i&gt;=n时是没有意义的，不存在这样的情况，所以我们将上述公式里的+∞缩减为$n-1​$就足够了 ∴我们要求的答案：ans=\sum_{i=1}^{n-1}f[n][i] 我们逐个枚举；因为我们枚举左右子树各有多少叶子节点时，令一边的子树内有$num$个点，由于我们展开一个节点，必定都有左右子树，所以子树大小$num$至少为1，两边的深度都$≥j-1$（此时自动去掉计算根节点，去调用左右子树$f[num][j-1]$和$f[i-num][j-1]$的概率）的情况会计算两次，直接套用一下容斥原理，减掉一次。 转移方程为：f[i][j]=\sum_{num=1}^{i-1}\frac{f[num][j-1]+f[i-num][j-1]-f[num][j-1]×f[i-num][j-1]}{i-1}​ Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;double f1[110], f2[110][110], ans;int main(int argc, char const *argv[])&#123; int q = read(), n = read(); if (q == 1) &#123; f1[1] = 0.0; for (int i = 2; i &lt;= n; ++i) f1[i] = f1[i - 1] + 2.0 / i; printf("%.6lf", f1[n]); &#125; else &#123; for (int i = 1; i &lt;= n; ++i) f2[i][0] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i; ++j) &#123; for (int num = 1; num &lt; i; ++num) f2[i][j] += f2[num][j - 1] + f2[i - num][j - 1] - f2[num][j - 1] * f2[i - num][j - 1]; f2[i][j] = f2[i][j] / (i - 1); &#125; &#125; for (int i = 1; i &lt; n; ++i) ans += f2[n][i]; printf("%.6lf", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Daily-Probablity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POI 2008 KLO-Building blocks]]></title>
    <url>%2F2019%2F02%2F25%2FPOI-2008-KLO-Building-blocks%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题#.KLO-Building blocks题面Byteasar loved to play with building blocks as a child. He used to arrange the blocks into nnn columns of random height and then organize them in the following manner: Byteasar would choose a number $k$ and try to arrange the blocks in such a way that some $k$ consecutive columns would be of equal height. Furthermore he always tried to achieve this goal in a minimum number of moves possible, where a single move consists in: laying one block on top of any column (Byteasar had a huge box with spare blocks, ensuring this move could always be performed), or removing the uppermost block from the top of any column. However, Byteasar was never quite sure if his sequence of moves was indeed optimal, therefore he has asked you to write a programme that will help him solve the problem. Task Write a programme that: reads the number $k$ along with the initial setup of the blocks from the standard input,determines the optimal solution (shortest possible sequence of moves),writes out the solution to the standard output. 简要翻译有$N$柱砖,希望有连续$K$柱的高度是一样的. 你可以选择以下两个动作 $1.$从某柱砖的顶端拿一块砖出来,丢掉不要了. $2.$从仓库中拿出一块砖,放到另一柱.仓库无限大. 现在希望用最小次数的动作完成任务.你还要求输出结束状态时,每柱砖的高度。 Input第一行输入两个整数$n$和$k$。 以下包含$n$行每行包含一个整数$h_i$代表砖的高度。 OutputThe optimal solution should be written out to the standard output, ie. such arrangement of blocks that: contains $k$ consecutive columns of equal height, can be obtained from the initial setup in a minimum possible number of moves. The output should consist of $n+1$ lines, each one containing a single integer. The number in the first line should be the minimum number of moves needed to get the desired arrangement. The line no. $i+1$ (for $1\le i\le n$) should contain the number $h_i$ - the final height of the $i_{th}$ column. If more than one optimal solution exists, write out one chosen arbitrarily. Sample Input5 339231 Sample Output239222 Hint$1\le k\le n\le 100,000$ $0\le h_i\le 1,000,000$ 说明本题SPJ的提示说明（按照SPJ判断顺序给出）： Out of Range:输出的数字不在答案可能的范围内。 Wrong Solution:输出方案中不包含连续k个相同高度的柱。 Wrong Result:提交的程序的步数和输出方案的步数不相等。 Expected cost = a,found cost = b:期望步数为a，程序的步数为b。 OK!Correct Answer!:答案正确。 题解自行luogu Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;long long read()&#123; long long x=0,w=0; char ch=0; while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return w? -x:x;&#125;const int N=1e5+10,M=1e6+10;struct seg_tree&#123; long long l,r,w,s;&#125;t[M*23];long long n,k;long long root[N],cnt,w[N],result=1e16,root_,tot,b,dd;void pushup(int rot)&#123; t[rot].w=t[t[rot].l].w+t[t[rot].r].w; t[rot].s=t[t[rot].l].s+t[t[rot].r].s;&#125;void insert(int last,int rot,long long pos,int l=0,int r=1000000)&#123; if(l==r) &#123; t[rot].w=t[last].w+1; t[rot].s=t[last].s+l; return; &#125; int mid=l+r&gt;&gt;1; if(pos&lt;=mid) &#123; t[rot].l=++cnt; t[rot].r=t[last].r; insert(t[last].l,t[rot].l,pos,l,mid); &#125; else &#123; t[rot].r=++cnt; t[rot].l=t[last].l; insert(t[last].r,t[rot].r,pos,mid+1,r); &#125; pushup(rot);&#125;int k_th(int last,int rot,long long pos,int l=0,int r=1000000)&#123; if(l==r) return l; int mid=l+r&gt;&gt;1; long long s=t[t[rot].l].w-t[t[last].l].w; if(pos&lt;=s) return k_th(t[last].l,t[rot].l,pos,l,mid); else return k_th(t[last].r,t[rot].r,pos-s,mid+1,r);&#125;long long sum(int last,int rot,long long pos,int l=0,int r=1000000)&#123; if(l==r) return min(pos,t[rot].w-t[last].w)*l; int mid=l+r&gt;&gt;1; long long s=t[t[rot].l].w-t[t[last].l].w; if(pos&lt;=s) return sum(t[last].l,t[rot].l,pos,l,mid); else return t[t[rot].l].s-t[t[last].l].s+sum(t[last].r,t[rot].r,pos-s,mid+1,r);&#125;int main(int argc, char const *argv[])&#123; n=read(),k=read(); for(int i=1;i&lt;k;++i) &#123; tot+=(w[i]=read()); root[i]=++cnt; insert(root[i-1],root[i],w[i]); &#125; for(int i=k;i&lt;=n;++i) &#123; w[i]=read(); root[i]=++cnt; tot+=w[i]-w[i-k]; insert(root[i-1],root[i],w[i]); int pos=k+1&gt;&gt;1; int id=k_th(root[i-k],root[i],pos); long long ans=sum(root[i-k],root[i],pos); ans=tot-(ans&lt;&lt;1)-(k-2*pos)*id; if(ans&lt;result) dd=i,result=ans,b=id; &#125; printf("%lld\n",result); for(int i=1;i&lt;=n;++i) if(dd&gt;=i&amp;&amp;dd&lt;i+k) printf("%lld\n",b); else printf("%lld\n",w[i]); return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2104 K-th Number]]></title>
    <url>%2F2019%2F02%2F25%2FPOJ-2104-K-th-Number%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题#.K-th Number题面You are working for Macrohard company in data structures department. After failing your previous task about key insertion you were asked to write a new data structure that would be able to return quickly $k​$-th order statistics in the array segment. That is, given an array $a[1…n]$ of different integer numbers, yourprogram must answer a series of questions $Q(i, j, k)$ in the form: “What would be the k-th number in $a[i…j]$ segment, if this segment was sorted?” For example, consider the array $a = (1, 5, 2, 6, 3, 7, 4)$. Let the question be $Q(2, 5, 3)$. The segment $a[2…5]$ is $(5, 2, 6, 3)$. If we sort this segment, we get $(2, 3, 5, 6)$, the third number is $5$, and therefore the answer to the question is $5$. 简要翻译有一个长度为$n$的序列，有$m$次询问，每次问一个区间的第$k$小的数。 Input第一行包含两个整数$n$,$m$分别代表序列的长度和询问的个数。 第二行包含$n$个整数代表序列。 下面包含$m$行，每行包含三个数$i,j,k$，代表区间$[i,j]$第$k$小的数。 Output对每个询问输出一行一个整数表示答案。 Sample Input7 31 5 2 6 3 7 42 5 34 4 11 7 3 Sample Output563 Hint$1\le n,m\le 100,000$ $1\le a_i\le 10^9$ 对权值线段树进行可持久化。 从$a[1]$到$a[n]$加入每个数，询问时用第$r$棵线段树上减去第$l-1$棵线段树就能得到值域在一个区间内的数的个数。 也就是说对原数列的$[1,n]$每一个前缀$1,i$建立一棵线段树，线段树的每一个节点都存某个区间 $[L,R]$的数一共有几个。 当我们查找$[i,j]$第$k$大数时，设某节点$x$，那么$x.sum[j]-x.sum[i-1]$就是$[i,j]$中在节点$x$内的数字总数。而对每一个前缀都建一棵线段树，那么就会超出空间，观察到每个$[1,i]和[1,i-1]$只有一条路是不一样的，那么节点只要用前一棵线段树的节点就可以了。 时间和空间复杂度为$O((n+m)logn)$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int read()&#123; int x=0,w=0; char ch=0; while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return w? -x:x;&#125;const int N=1e5+10;struct seg_tree&#123; int l,r,s;&#125;t[N*20];struct data&#123; int x,id; friend bool operator &lt; (data a,data b) &#123; return a.x&lt;b.x; &#125;&#125;a[N];int rank_[N],rot[N];int root,n,m;void insert(int &amp;cnt,int &amp;tt,int l,int r)&#123; t[root++]=t[tt]; tt=root-1; ++t[tt].s; if(l==r) return; int mid=l+r&gt;&gt;1; if(cnt&lt;=mid) insert(cnt,t[tt].l,l,mid); else insert(cnt,t[tt].r,mid+1,r);&#125;int query(int i,int j,int v,int l,int r)&#123; if(l==r) return l; int tt=t[t[j].l].s-t[t[i].l].s; int mid=l+r&gt;&gt;1; if(v&lt;=tt) return query(t[i].l,t[j].l,v,l,mid); else return query(t[i].r,t[j].r,v-tt,mid+1,r);&#125;int main(int argc, char const *argv[])&#123; t[0].l=t[0].r=t[0].s=rot[0]=0; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; for(int i=1;i&lt;=n;++i) a[i].x=read(),a[i].id=i; sort(a+1,a+1+n); for(int i=1;i&lt;=n;++i) rank_[a[i].id]=i; root=1; for(int i=1;i&lt;=n;++i) &#123; rot[i]=rot[i-1]; insert(rank_[i],rot[i],1,n); &#125; while(m--) &#123; int i=read(),j=read(),k=read(); printf("%d\n",a[query(rot[i-1],rot[j],k,1,n)].x); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6096 String]]></title>
    <url>%2F2019%2F02%2F24%2FHDU-6096-String%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题#.String题面Bob has a dictionary with $N$ words in it. Now there is a list of words in which the middle part of the word has continuous letters disappeared. The middle part does not include the first and last character. We only know the prefix and suffix of each word, and the number of characters missing is uncertain, it could be $0​$. But the prefix and suffix of each word can not overlap. For each word in the list, Bob wants to determine which word is in the dictionary by prefix and suffix. There are probably many answers. You just have to figure out how many words may be the answer. 简要翻译给定$n$个串，有$m$次询问，每次询问给定串$a,b$，问$n$个串中有多少个能表示为$axb$，其中$x$为任意字符串。 Input第一行给出一个整数$T$，代表数据的组数。 每一组数据包含$2​$个整数$n​$和$q​$， 分别代表串的个数和询问个数。 以下$n$行每行包含一个字符串$W_i$。 以下$q$行每行包含两个串$a_i$串$b_i$。 保证所有的串都是小写字母。 Output对于每组数据，输出包含$q$行，每行包含一个整数代表答案。 Sample Input14 4abacdeacdefacdefa acd efac ace f Sample Output2110 Hint$T\le 5$ $0&lt; n,q\le 100,000$ $\sum S_i+P_i\le 500,000​$ $\sum W_i\le 500,000$ 条件等价于前缀为$a$，后缀为$b$，且长度$&gt;=|a|+|b|$的个数。 在不考虑长度的情况下，将正串和反串分别按字典序编号，一个询问对应了编号的一个区间，用$Trie$树或排序+二分+$hash​$求出区间，然后用主席树来求答案。 然后考虑减掉长度不足的，直接枚举长度就可以确定字符串。 时间复杂度为$O(slogs)$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x=0,w=0; char ch=0; while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return w? -x:x;&#125;const int N=2e6+5e5;const int NS=5e5+10;struct trie_tree&#123; int nxt[27],w;&#125;t[N];struct block&#123; int l,r; friend bool operator &lt; (block a,block b) &#123; return a.r-a.l&lt;b.r-b.l; &#125;&#125;a[NS];struct data&#123; int l,r,s; int ll,rr; friend bool operator &lt; (data a,data b) &#123; return a.r-a.l+a.rr-a.ll&lt;b.r-b.l+b.rr-b.ll; &#125;&#125;b[NS];#define DS(x) x-'a'int T,res,next_(1);char s1[NS],s2[NS];char s[NS],ss[NS];int n,m,ans[NS];int add()&#123; memset(&amp;t[next_],0,sizeof(trie_tree)); return next_++;&#125;void insert(char *c)&#123; int rot=0,len=strlen(c); for(int i=0;i&lt;len;++i) &#123; int k=DS(c[i]); ++t[rot].w; if(!t[rot].nxt[k]) t[rot].nxt[k]=add(); rot=t[rot].nxt[k]; &#125; ++t[rot].w;&#125;void sub1(int x)&#123; int l=a[x].l,r=a[x].r; int sum=0; for(int i=l;i&lt;r;++i) &#123; s[sum++]=ss[i]; s[sum++]=ss[r+l-i-1]; &#125; s[sum]=0;&#125;int sub2(int x)&#123; int le1=b[x].r-b[x].l,le2=b[x].rr-b[x].ll; int maxn=max(le1,le2); int sum=0; for(int i=0;i&lt;maxn;++i) &#123; if(i&lt;le1) s[sum++]=s1[i+b[x].l]; else s[sum++]='$'; if(le2-i-1&gt;=0) s[sum++]=s2[b[x].rr-i-1]; else s[sum++]='$'; &#125; s[sum]=0; res=0; return sum;&#125;void calc(int x,int lenth,int root)&#123; if(x==lenth) &#123; res+=t[root].w; return; &#125; if(s[x]=='$') &#123; for(int i=0;i&lt;26;++i) &#123; if(t[root].nxt[i]) calc(x+1,lenth,t[root].nxt[i]); &#125; &#125; else &#123; if(t[root].nxt[s[x]-'a']) calc(x+1,lenth,t[root].nxt[s[x]-'a']); &#125;&#125;int main()&#123; T=read(); while(T--) &#123; memset(&amp;t[0],0,sizeof(trie_tree)); next_=1; n=read(),m=read(); int sum=0; for(int i=0;i&lt;n;++i) &#123; scanf("%s",ss+sum); a[i].l=sum; sum+=strlen(ss+sum); a[i].r=sum; &#125; sort(a,a+n); int sum1=0,sum2=0; for(int i=0;i&lt;m;++i) &#123; scanf("%s %s",s1+sum1,s2+sum2); b[i].l=sum1,b[i].ll=sum2; sum1+=strlen(s1+sum1); sum2+=strlen(s2+sum2); b[i].r=sum1,b[i].rr=sum2; b[i].s=i; &#125; sort(b,b+m); int p=n-1; for(int i=m-1;~i;--i) &#123; while(a[p].r-a[p].l&gt;=b[i].r-b[i].l+b[i].rr-b[i].ll&amp;&amp;p&lt;n) &#123; sub1(p--); insert(s); &#125; sum=sub2(i); res=0; calc(0,sum,0); ans[b[i].s]=res; &#125; for(int i=0;i&lt;m;++i) printf("%d\n",ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治(淀粉质)]]></title>
    <url>%2F2019%2F02%2F20%2F%E7%82%B9%E5%88%86%E6%B2%BB-%E6%B7%80%E7%B2%89%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~(淀粉质)点分治推荐一道模板题。 我们选择任意一个根$root​$，将树变为一棵无根树。 那么我们对于树上任意两个点之间的路径必定被转化为经过$root$的路径，或是位于$root$某一棵子树中的路径。 所以我们就能够把一条路径分到几棵子树中分治求解。点分治后，每一层分别对$n$个点处理一次，递归$k$层的复杂度为$O(kn)$。 不过当树变为一条链之后，最坏的情况是当$root$取首尾节点时，有$k=n$，时间复杂度为$O(n^2)$。 那么我们选择$root​$时应该怎么选择呢？ 树的重心是个好的选择，它能使递归的层数减到最少。 我们记录每个点$i​$到根节点$root​$的距离$dis_i​$，那么从$u​$到$v​$的路径长度为$dis_u+dis_v​$。 同时设$max​$_$part[i]​$表示删除$i​$节点后，最大的子树的大小。 树的重心节点$g$一定是$max$_$part[g]=(max$_$part[i])_{min}$。 取重心也就保证了时间复杂度稳定在$O(nlogn)$左右。 是不是比原来$O(n^2)$的算法优秀了很多呢？ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 100010;struct edge &#123; int to, nxt, l;&#125; e[N];int linkk[N], len;void insert(int u, int v, int l)&#123; e[++len].to = v, e[len].l = l, e[len].nxt = linkk[u], linkk[u] = len; e[++len].to = u, e[len].l = l, e[len].nxt = linkk[v], linkk[v] = len;&#125;int size[N], max_part[N], tp[N];int tot, now_root, res[10000010], deep[N];int n, m, q[110], c;bool vis[N];void getroot(int x, int fa)&#123; size[x] = 1; max_part[x] = 0; for (int i = linkk[x]; i; i = e[i].nxt) &#123; int to = e[i].to; if (to == fa || vis[to]) continue; getroot(to, x); size[x] += size[to]; max_part[x] = max(max_part[x], size[to]); &#125; max_part[x] = max(max_part[x], tot - size[x]); if (max_part[now_root] &gt; max_part[x]) now_root = x;&#125;void getdeep(int x, int fa)&#123; tp[++c] = deep[x]; for (int i = linkk[x]; i; i = e[i].nxt) &#123; int to = e[i].to; if (to == fa || vis[to]) continue; deep[to] = deep[x] + e[i].l; getdeep(to, x); &#125;&#125;void calculate(int x, int dep, int del)&#123; c = 0, deep[x] = dep; getdeep(x, 0); for (int i = 1; i &lt;= c; ++i) for (int j = 1; j &lt;= c; ++j) res[tp[i] + tp[j]] += del;&#125;void solve(int x)&#123; calculate(x, 0, 1); vis[x] = 1; for (int i = linkk[x]; i; i = e[i].nxt) &#123; int to = e[i].to; if (vis[to]) continue; calculate(to, e[i].l, -1); tot = size[to], now_root = 0; getroot(to, 0); solve(to); &#125;&#125;int main()&#123; n = read(), m = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(), l = read(); insert(u, v, l); &#125; for (int i = 1; i &lt;= m; ++i) q[i] = read(); now_root = 0, max_part[now_root] = tot = n; getroot(1, 0); solve(now_root); for (int i = 1; i &lt;= m; ++i) if (res[q[i]]) puts("AYE"); else puts("NAY"); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Operation On Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.2.19寒假集训-元宵爆零赛]]></title>
    <url>%2F2019%2F02%2F19%2F2019-2-19%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD-%E5%85%83%E5%AE%B5%E7%88%86%E9%9B%B6%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~恭喜您获得ysy大爷的毒瘤题一套 恭喜您获得爆零的好成绩 题解tree： 首先不难发现，如果某一步是朝着t走的，那么一定不会走回来了；否则，一定会把整棵子树走完再回到当前点。 走到一个$s$到$t$路径上的点时，会随机选择一个儿子走下去，这等价于随机一个儿子们的排列，然后按这个顺序走。 那么$s$到$t$的路径上所有点显然一定会走到，以$s$为根时$t$子树中的点显然走不到，而其它点都有$\frac 12$的概率会走到。 时间复杂度$O(nlogn+m)$。 prime： $n$较小时，我们可以直接用线性筛/埃氏筛法求出每个数的最小质因数。 我们考虑进行容斥。对于每个质数$x$，我们需要求出$1$~$n/x$中不被比$x$小的质数整除的数的个数。一种简单的思路是，对于x&lt;=k的情况，我们进行常见的枚举子集容斥；对于$x&gt;k$的情况，$n/x$较小，我们就在$n/k$的范围内进行线性筛/埃氏筛法。 注意到进行子集容斥时，枚举子集后贡献形如$(-1)^i(n/S)$，而$n/S$只有$O(\sqrt n)$种取值，我们可以对这个进行记忆化。 时间复杂度$O(\frac{n^\frac34}{\sqrt {logn}})$ path： 这是课件里的例题。 点分治统计树上的情况，然后单独考虑经过剩下那条边的答案。 在环上按顺序枚举一个端点，用树状数组维护另一个端点到这条边的距离。 时间复杂度$O(nlogn)$。 以上是闫书弈大佬的题解 我的丑陋的代码(✿◡‿◡)：Tree: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;int a[500010], n, m, deep[500010], f[21][500010];vector&lt;int&gt; v[500010];int point;void dfs(int x)&#123; for (int i = 1; i &lt;= 20; ++i) f[i][x] = f[i - 1][f[i - 1][x]]; a[x] = 1; for (int i = 0; i &lt; v[x].size(); ++i) if (v[x][i] != f[0][x]) &#123; f[0][v[x][i]] = x; deep[v[x][i]] = deep[x] + 1; dfs(v[x][i]); a[x] += a[v[x][i]]; &#125;&#125;int LCA(int x, int y)&#123; if (deep[x] &lt; deep[y]) swap(x, y); if (deep[x] &gt; deep[y]) &#123; for (int i = 20; ~i; --i) if (deep[x] - (1 &lt;&lt; i) &gt; deep[y]) x = f[i][x]; if (f[0][x] == y) &#123; point = x; return y; &#125; x = f[0][x]; &#125; for (int i = 20; ~i; --i) if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y]; return f[0][x];&#125;int main(int argc, char const *argv[])&#123; freopen("tree.in", "r", stdin); freopen("tree.out", "w", stdout); n = read(), m = read(); for (int i = 1; i &lt; n; ++i) &#123; int from = read(), to = read(); v[from].push_back(to); v[to].push_back(from); &#125; deep[1] = 1; dfs(1); while (m--) &#123; int s = read(), t = read(), g, k; int lca = LCA(s, t); if (lca == t) k = n - a[point] - 1; else k = a[t] - 1; g = n + (deep[s] + deep[t] - 2 * deep[lca] + 1) - k; printf("%d.%d\n", g / 2, g % 2 * 5); &#125; return 0;&#125; Prime: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;#define ull unsigned long longull read()&#123; ull x = 0; char ch = 0; while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return x;&#125;const ull w = 1000;int prime[5000000], cnt;ull answer, n, k, sqr, s, c;bool notprime[200000010];ull g[510][8010];ull fastpow(ull a, ull b = k)&#123; ull res = 1; // cerr&lt;&lt;"YEP"&lt;&lt;endl; while (b) &#123; if (b &amp; 1ull) res *= a; a *= a; b &gt;&gt;= 1ull; &#125; // cerr&lt;&lt;"NOP"&lt;&lt;endl; return res;&#125;ull f(ull N, int p)&#123; if (N &lt;= 8000ull &amp;&amp; g[p][N]) return g[p][N]; ull res = N / prime[p]; for (int i = 1; i &lt; p; ++i) &#123; if (1ull * prime[i]*prime[p] &gt; N) break; res -= f(N / prime[p], i); &#125; if (N &lt;= 8000) g[p][N] = res; return res;&#125;void Prime()&#123; notprime[1] = 1; for (int i = 2; i &lt;= sqr; ++i) &#123; if (!notprime[i]) prime[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; 1ull * i * prime[j] &lt;= sqr; ++j) &#123; notprime[i * prime[j]] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; freopen("prime.in", "r", stdin); freopen("prime.out", "w", stdout); n = read(), k = read(), sqr = sqrt((long double)n); Prime(); fill(notprime, notprime + sqr + 50, 0); s = n / w - 1; for (int i = 1; i &lt;= cnt; ++i) &#123; if ((ull)prime[i] &lt;= w) &#123; answer += (f(n, i) - 1) * fastpow(prime[i]); &#125; else &#123; for (ull j = n / prime[i] + 1; j &lt;= c; ++j) if (!notprime[j]) --s; answer += s * fastpow(prime[i]); &#125; // cerr&lt;&lt;"NOP"&lt;&lt;endl; if ((ull)prime[i] &lt; w) c = n / w; else c = n / prime[i]; for (ull j = prime[i]; j &lt;= c; j += prime[i]) if (!notprime[j]) notprime[j] = 1, --s; &#125; printf("%llu", answer); return 0;&#125; Path: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 100010;int tree[N &lt;&lt; 2];struct edge &#123; int to, nxt;&#125; e[N &lt;&lt; 1];int linkk[N &lt;&lt; 1], len(1), pos, bit[N], check[N], fa[N];int n, m, c, Pathcnt, k;long long ans;void insert(int u, int v)&#123; e[++len].to = v, e[len].nxt = linkk[u], linkk[u] = len; e[++len].to = u, e[len].nxt = linkk[v], linkk[v] = len; check[len - 1] = check[len] = 1;&#125;int lowbit(int x)&#123; return x &amp; -x;&#125;void change(int x, int flag)&#123; if (flag == 1) while (x &lt;= n) &#123; if (tree[x] != pos) tree[x] = pos, bit[x] = 1; else ++bit[x]; x += lowbit(x); &#125; else while (x &lt;= n) &#123; --bit[x]; x += lowbit(x); &#125;&#125;long long sum(int x)&#123; if (x &lt; 0) return 0; int ans = 0; while (x) &#123; if (tree[x] == pos) ans += bit[x]; x -= lowbit(x); &#125; return ans;&#125;int getfa(int x)&#123; return fa[x] == x ? x : fa[x] = getfa(fa[x]);&#125;int size[N], max_part[N];int tot, now_root, deep[N], to[N];int Path_[N];bool vis[N], is_main[N];int point_u, point_v;void getroot(int x, int fa)&#123; size[x] = 1; max_part[x] = 0; for (int i = linkk[x]; i; i = e[i].nxt) &#123; int to = e[i].to; if (to == fa || !check[i]) continue; getroot(to, x); size[x] += size[to]; max_part[x] = max(max_part[x], size[to]); &#125; max_part[x] = max(max_part[x], tot - size[x]); if (max_part[now_root] &gt; max_part[x]) now_root = x;&#125;void Ncalc(int x, int fa, int dep)&#123; ans += sum(n) - sum(k - dep - 1); for (int i = linkk[x]; i; i = e[i].nxt) &#123; if (!check[i] || e[i].to == fa) continue; Ncalc(e[i].to, x, dep + 1); &#125;&#125;void Nadd(int x, int fa, int dep)&#123; change(dep + 1, 1); for (int i = linkk[x]; i; i = e[i].nxt) &#123; if (!check[i] || e[i].to == fa) continue; Nadd(e[i].to, x, dep + 1); &#125;&#125;void FindPath(int x, int fa, int dep)&#123; to[x] = fa, deep[x] = dep; change(deep[x], 1); for (int i = linkk[x]; i; i = e[i].nxt) &#123; if (e[i].to == fa) continue; FindPath(e[i].to, x, dep + 1); &#125;&#125;void solve(int x)&#123; ++pos; change(1, 1); for (int i = linkk[x]; i; i = e[i].nxt) &#123; if (!check[i]) continue; Ncalc(e[i].to, x, 1); Nadd(e[i].to, x, 1); &#125; for (int i = linkk[x]; i; i = e[i].nxt) &#123; if (!check[i]) continue; check[i ^ 1] = 0; max_part[0] = tot = size[e[i].to]; now_root = 0; getroot(e[i].to, 0); solve(now_root); &#125;&#125;void del_on_tree(int x, int fa)&#123; change(deep[x], -1); for (int i = linkk[x]; i; i = e[i].nxt) &#123; if (e[i].to == fa || is_main[e[i].to]) continue; del_on_tree(e[i].to, x); &#125;&#125;void calc_on_tree(int x, int fa, int dep)&#123; ans += sum(n) - sum(k - dep - 1); for (int i = linkk[x]; i; i = e[i].nxt) &#123; if (e[i].to == fa || is_main[e[i].to]) continue; calc_on_tree(e[i].to, x, dep + 1); &#125;&#125;int main()&#123; freopen("path.in", "r", stdin); freopen("path.out", "w", stdout); n = read(), m = read(), k = read(); for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(); if (getfa(u) == getfa(v)) point_u = u, point_v = v; else fa[fa[u]] = fa[v], insert(u, v); &#125; now_root = 0, max_part[now_root] = tot = n; getroot(1, 0); solve(now_root); if (point_u) &#123; ++pos; FindPath(point_u, 0, 1); for (int i = point_v; i; i = to[i]) Path_[++Pathcnt] = i, is_main[i] = 1; for (int i = 1; i &lt; Pathcnt; ++i) &#123; del_on_tree(Path_[i], 0); calc_on_tree(Path_[i], 0, i); &#125; &#125; printf("%lld", ans); return 0;&#125; 小福利数据下载请戳我(*╹▽╹*) (Click Me For data.rar)]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#715 C.Digit Tree]]></title>
    <url>%2F2019%2F02%2F18%2FCodeForces-715-C-Digit-Tree%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题E.Digit Tree题面ZS the Coder has a large tree. It can be represented as an undirected connected graph of $n$ vertices numbered from $0$ to $n - 1$ and $n - 1$ edges between them. There is a single nonzero digit written on each edge. One day, ZS the Coder was bored and decided to investigate some properties of the tree. He chose a positive integer $M$, which is coprime to $10$, $i.e$. $gcd(M,10)=1$. ZS consider an ordered pair of distinct vertices $(u, v)$ interesting when if he would follow the shortest path from vertex $u$ to vertex $v$ and write down all the digits he encounters on his path in the same order, he will get a decimal representaion of an integer divisible by $M$. Formally, ZS consider an ordered pair of distinct vertices $(u, v)$ interesting if the following states true: Let $a_1 = u, a_2, …, a_k = v$ be the sequence of vertices on the shortest path from $u$ to $v$ in the order of encountering them; Let $d_i$ ($1 ≤ i &lt; k$) be the digit written on the edge between vertices $a_i$ and $a_i$ + 1; The integer $\overline{d_1d_2d_3…d_{k-1}}=\sum_{i=1}^{k-1}d_i·10^{k-1-i}$ is divisible by $M$. Help ZS the Coder find the number of interesting pairs! 简要翻译给定一个有$N$个点的树，问其中有多少条路径满足他们的边权连成的数对$M$取余为$0$。 其中$gcd(M,10)=1$。 Input第一行包含两个整数$n$和$M$。 下面包含$n-1$行，每行包含$3$个整数。第$i$行包含$u_i,v_i,w_i$分别代表一条边的出点，入点，权值。 Output输出一行一个整数表示数对个数。 Sample Input 16 70 1 24 2 42 0 13 0 92 5 7 Sample Output 17 Sample Input 25 111 2 32 0 33 0 34 3 3 Sample Output 28 Hint$2\le n\le 100,000,1\le M\le 10^9,gcd(M,10)=1$。 $0\le u_i,v_i\le n,1\le w_i\le 9$。 Sample Explain在第一个例子中，所求数对是$(0,4),(1.2),(1.5),(3,2),(2.5),(5,2),(3,5)$，由这些数对组成的数分别是$14,21,217,91,7,7,917$，都是$7$的倍数。注意$(2,5)$和$(5,2)$是不同的数对。 在第二个例子中，所求数对是$(4,0),(0,4),(3,2),(2,3),(0,1),(1,0),(4,1),(1,4)$，其中6对给出了数字$33$而其中$2$对给出了数字$3333$，它们都是$11​$的倍数。 我们点分治套路一波。 然后分析一下如何统计答案。 对于$x→y$的路径，等价于$x→root→y$，我们要处理出$dis[x]$和$dis[y]$分别表示$x$到$root$,$root$到$y$连成的数对$mod$取模后的结果。 在合并时，我们知道，如果路径是合法的，那么肯定满足$dis[x]×10^{deep[y]}+dis[y]≡0\ \pmod{M}​$ 也就是$dis[x]≡-dis[y]×10^{-deep[y]}\pmod{M}$ 用$dfs​$来统计答案即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//本代码来自"睿智"的大佬yyd，本蒟蒻太菜被他踩爆了，本博客右侧有他的博客地址yo~#include&lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int N=0,C=0;char tf=getchar(); for(;!isdigit(tf);tf=getchar())C|=tf=='-'; for(;isdigit(tf);tf=getchar())N=(N&lt;&lt;1)+(N&lt;&lt;3)+(tf^48); return C?-N:N;&#125;const int N=100010,INF=0x7fffffff;int n,p,m,x,y,z;int siz[N],mx[N],rt,All,dep[N];long long a[N],P[N],ans;pair&lt;long long,long long&gt;b[N];//&lt; b ,deep &gt;pair&lt;long long,long long&gt;g[N];//&lt; rt-&gt;x ,x-&gt;rt &gt;int len,lin[N];struct nc&#123;int y,nxt,v;&#125;e[N&lt;&lt;1];bool v[N];#define fi first#define se second#define mp make_pairinline void ins(int x,int y,int v)&#123; e[++len].nxt=lin[x]; lin[x]=len; e[len].y=y; e[len].v=v;&#125;void exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(!b)&#123;x=1,y=0;return;&#125; exgcd(b,a%b,y,x); y-=a/b*x;&#125;inline int inv(int a)&#123; int x,y; exgcd(a,p,x,y); return (x%p+p)%p;&#125;void dfs_rt(int x,int f)&#123; siz[x]=1,mx[x]=0; for(int i=lin[x];i;i=e[i].nxt) &#123; int y=e[i].y; if(y==f||v[y])continue; dfs_rt(y,x); siz[x]+=siz[y]; mx[x]=max(mx[x],siz[y]); &#125; mx[x]=max(mx[x],All-siz[x]); if(mx[x]&lt;mx[rt])rt=x;&#125;void dfs_ab(int x,int f)&#123; a[++m]=g[x].se,b[m]=mp(g[x].fi,dep[x]); for(int i=lin[x];i;i=e[i].nxt) &#123; int y=e[i].y; if(y==f||v[y])continue; dep[y]=dep[x]+1; g[y]=mp((g[x].fi*10+e[i].v)%p,(g[x].se+P[dep[x]]*e[i].v)%p); dfs_ab(y,x); &#125;&#125;inline void cal(int x,int c)&#123; sort(a+1,a+m+1); for(int i=1;i&lt;=m;++i) &#123; long long aa=1LL*(p-b[i].fi)*inv(P[b[i].se])%p; ans+=(upper_bound(a+1,a+m+1,aa)-lower_bound(a+1,a+m+1,aa))*c; &#125;&#125;void solve(int x)&#123; v[x]=1,dep[x]=0; g[x].fi=g[x].se=0; m=0,dfs_ab(x,0),cal(x,1);//多算一个 x-&gt;x for(int i=lin[x];i;i=e[i].nxt) &#123; int y=e[i].y; if(v[y])continue; dep[y]=1,g[y].fi=g[y].se=e[i].v; m=0,dfs_ab(y,0),cal(y,-1);//减去子数内答案 All=siz[y],rt=0,dfs_rt(y,0); solve(rt);//点分治 &#125;&#125;int main()&#123; n=read(),p=read(),P[0]=1; for(int i=1;i&lt;n;++i) &#123; x=read()+1,y=read()+1,z=read()%p; ins(x,y,z),ins(y,x,z); P[i]=P[i-1]*10%p; &#125; mx[0]=INF,All=n,dfs_rt(1,0),solve(rt); printf("%lld\n",ans-n); return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4025 二分图]]></title>
    <url>%2F2019%2F02%2F18%2Fbzoj-4025-%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题B.二分图题面神犇有一个$n$个节点的图。因为神犇是神犇，所以在T时间内一些边会出现后消失。神犇要求出每一时间段内这个图是否是二分图。这么简单的问题神犇当然会做了，于是他想考考你。 Input输入数据的第一行是三个整数$n,m,T$。 第$2$行到第$m+1$行，每行$4$个整数$u,v,start,end$。第$i+1$行的四个整数表示第i条边连接$u,v$两个点，这条边在$start$时刻出现，在第$end$时刻消失。 Output输出包含$T$行。在第$i$行中，如果第$i$时间段内这个图是二分图，那么输出“$Yes$”，否则输出“$No$”，不含引号。 Sample Input3 3 31 2 0 22 3 0 31 3 1 2 Sample OutputYesNoYes Hint$1\le n\le 100000，1\le m\le 200000，1\le T\le 100000，1\le u,v\le n，0\le start\le end\le T。$ Sample Explain 0时刻，出现两条边1-2和2-3。 第1时间段内，这个图是二分图，输出Yes。 1时刻，出现一条边1-3。 第2时间段内，这个图不是二分图，输出No。 2时刻，1-2和1-3两条边消失。 第3时间段内，只有一条边2-3，这个图是二分图，输出Yes。 如题：二分图的话，就等价于不存在奇环，我们直接线段树分治，用并查集维护每个点与根节点间的距离即可。 我们建立一棵线段树，用时间轴来当做线段树的左右端点，每一条边出现消失的时间区间就对应着线段树上的一对$[l,r]$，将每一条边插到对应的时间区间中，最后统计答案时，只要用线段树分治，从$[1,r_{max}]$各个点都依次访问,存储答案，最后输出。 当然了，由于我们要支持撤销操作，所以不能将并查集路径压缩，这样就没有办法撤销了。 具体操作见代码吧。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x=0,w=0; char ch=0; while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return w? -x:x;&#125;const int N=100010;struct edge&#123; int u,v;&#125;;vector&lt;edge&gt; t[N&lt;&lt;2];bool Answer[N];int fa[N],sz[N],dist[N],n,m;int q;int getfa(int x)&#123; while(x!=fa[x]) x=fa[x]; return x;&#125;int dis(int x)&#123; int d=0; while(x!=fa[x]) d^=dist[x],x=fa[x]; return d;&#125;void change(int root,int l,int r,int ll,int rr,edge e)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123;t[root].push_back(e);return;&#125; int mid=l+r&gt;&gt;1; if(ll&lt;=mid) change(root&lt;&lt;1,l,mid,ll,rr,e); if(rr&gt;mid) change(root&lt;&lt;1|1,mid+1,r,ll,rr,e);&#125;void divide_(int root,int l,int r)&#123; vector&lt;edge&gt; p; p.clear(); int mid=l+r&gt;&gt;1; bool have_ans=0; for(int i=0,len=t[root].size();i&lt;len;++i) &#123; int u=t[root][i].u,v=t[root][i].v; int a=getfa(u),b=getfa(v); if(a==b) if((dis(u)^dis(v))==0) &#123; have_ans=1; break; &#125;else; else &#123; if(sz[a]&gt;sz[b]) swap(a,b),swap(u,v); sz[b]+=sz[a],dist[a]=dist[u]^dist[v]^1; fa[a]=b; p.push_back((edge)&#123;a,b&#125;); &#125; &#125; if(!have_ans) &#123; if(l==r) Answer[l]=1; else &#123; divide_(root&lt;&lt;1,l,mid); divide_(root&lt;&lt;1|1,mid+1,r); &#125; &#125; for(int i=p.size()-1;~i;--i) &#123; int u=p[i].u,v=p[i].v; sz[v]-=sz[u]; dist[u]=0,fa[u]=u; &#125;&#125;int main(int argc, char const *argv[])&#123; n=read(),m=read(),q=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); edge e=(edge)&#123;u,v&#125;; int l=read(),r=read(); if(l&lt;r) change(1,1,q,l+1,r,e); &#125; for(int i=1;i&lt;=n;++i) fa[i]=i,sz[i]=1; divide_(1,1,q); for(int i=1;i&lt;=q;++i) if(Answer[i]) puts("Yes"); else puts("No"); return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曼哈顿距离-欧式距离]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB-%E6%AC%A7%E5%BC%8F%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~ 1、曼哈顿距离又叫马氏距离。 简单来说就是点与点之间在$n$维空间上的坐标差的绝对值。 以二维平面为例子：则$Manhattan\ distance=|x_1-x_2|+|y_1-y_2|$。 2、欧式距离又叫欧几里得距离。 简单来说就是点与点在空间上的直线距离。 以二维平面为例子：则$Euclidean\ Metric=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。 度娘百科里有这么一个图。 那么绿色代表欧式距离，蓝、红、黄其实求出的都是曼哈顿距离。]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Math Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树分治-陈丹琪(cdq)分治]]></title>
    <url>%2F2019%2F02%2F18%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB-%E9%99%88%E4%B8%B9%E7%90%AA-cdq-%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~我们先来了解一下线段树分治很显然，我们在进行操作的时候，把所有操作都放在一棵树里面，就像遍历一棵树一样遍历一整棵树，这个算法与回溯+$dfs$不同的地方在于一层递归中有可能横跨多个节点。如果一个操作需要用到多个节点，那么就把这个操作拆开，分治这个操作，最多能分成$log$级别数量的操作。 模仿线段树，将这个操作覆盖整个区间，然后进行拆分操作，递归子树求解。 例题—BZOJ4025二分图 我们再了解一下CDQ分治CDQ分治它只支持离线操作，但是它的常数比较小，能替代一部分比较复杂的数据结构。 二维偏序（CDQ分治太烦了，学习中……） 更多详情请点击Coco_T_大佬的blog。]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Operation On Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[启发式合并]]></title>
    <url>%2F2019%2F02%2F18%2F%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~一、启发式合并的算法原理我们常用路径压缩的方法来减少内存消耗，但是过程中会损失掉很多的数据信息，如果用冰茶几来维护又会消耗很多时间，这时候我们需要用到启发式合并。 我们用并查集时，很多时间都浪费在了$getfa()$这个函数上面，我们考虑对$getfa()$进行优化。启发式合并使它的时间复杂度能尽可能控制在$O(logn)$左右。 并查集是树型的数据结构，有深度这一概念，如果我们把深度大的树的根节点接在深度小的树上，那么深度反而会增大，时间消耗就会更多。 那启发式合并就是把小的树的根节点接在大的树上，那么深度就是$max(h_小+1,h_大)$，这就是启发式合并的原理。 二、我们借图来理解一下。 一开始有两棵树高度分别为3和5 如果是并查集的$getfa()$操作，那么树会变成这样 而进行了启发式合并的树是这样的 三、Code12345678910111213void qfs_union(int x,int y)&#123; int a=find(x); int b=find(y); if(height[a]&gt;height[b]) fa[b]=a; else if(height[a]&lt;height[b]) fa[a]=b; else&#123; fa[a]=b; height[b]++; &#125;&#125; 123456int find(x)&#123; while(fa[x]!=0) x=fa[x]; return x;&#125;]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Operation On Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图专题]]></title>
    <url>%2F2019%2F02%2F18%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~我对二分图简直自闭，决定再次学习一波，唉。 一、二分图的定义 简单的说，如果图中的点可以被分为两组，并且所有的边的两端不在同一组内，也就是说都连通两个组，那么这就是一个二分图。 二分图还有另一个定义，如果把一个图的顶点划分为两个不相交集，使每一条边分别连接两集中的顶点，那么这就是一个二分图。 Fig1是一个二分图，看起来不方便，就画成Fig2。 二、匹配的定义 简单地说，就是一个边集，且满足其中任意两边都没有公共顶点。 如图，Fig3、Fig4是Fig2 的匹配： 匹配中还有一些定义：匹配点，匹配边，未匹配点，非匹配边。比如Fig3中的1,4,5,7是匹配点，1-5,4-7是匹配边。 最大匹配：一个图的所有匹配中，所含匹配边最多的匹配，称为该图的最大匹配。Fig4是一个最大匹配。 完美匹配：如果一个匹配内，所有的点都是匹配点，那么这个匹配就是一个完美匹配，显然有，完美匹配一定是最大匹配。但是并不是所有的图都存在完美匹配。 三、另一些定义（匈牙利算法） 交替路：从一个未匹配点出发，依次经过非匹配边，匹配边，非匹配边，匹配边……如此形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点，但不能算出发点，那么这条路叫做增广路。如图，Fig5中的增广路为Fig6： 增广路有一个特点：非匹配边一定比匹配边多一条。 → 由此，只要把增广路中的匹配边和非匹配边身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数比原来多1条，其实如果交替路以非匹配点结束，那么该交替路就是一条增广路。 四、匈牙利算法 1、基本思想： 通过寻找增广路，把增广路的匹配边和非匹配边身份交换，多出一条匹配边，直到不能找到增广路为止。 Code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define MAXN 9999using namespace std;int nx,ny;//nx表示二分图左边顶点的个数，ny表示二分图右边顶点的个数int m;//m代表边的条数int cx[MAXN],cy[MAXN];//如果有cx[i]=j，则必有cy[j]=i，说明i点和j点能够匹配int x,y;//x点到y点有边int e[MAXN][MAXN];//邻接矩阵int visited[MAXN];//标记数组，标记的永远是二分图右边的顶点int ret;//最后结果int point(int u)//这个函数的作用是寻找增广路和更新cx，xy数组，如果找到了增广路，函数返回1，找不到，函数返回0。&#123; for(int v=1;v&lt;=ny;v++)//依次遍历右边的所有顶点 &#123; if(e[u][v]&amp;&amp;!visited[v])//条件一：左边的u顶点和右边的v顶点有连通边，条件二：右边的v顶点在没有被访问过，这两个条件必须同时满足 &#123; visited[v]=1;//将v顶点标记为访问过的 if(cy[v]==-1||point(cy[v]))//条件一：右边的v顶点没有左边对应的匹配的点，条件二：以v顶点在左边的匹配点为起点能够找到一条增广路（如果能够到达条件二，说明v顶点在左边一定有对应的匹配点）。 &#123; cx[u]=v;//更新cx，cy数组 cy[v]=u; return 1; &#125; &#125; &#125; return 0;//如果程序到达了这里，说明对右边所有的顶点都访问完了，没有满足条件的。&#125;int main()&#123; while (cin&gt;&gt;m&gt;&gt;nx&gt;&gt;ny) &#123; memset(cx,-1,sizeof(cx));//初始化cx，cy数组的值为-1 memset(cy,-1,sizeof(cy)); memset(e,0,sizeof(e));//初始化邻接矩阵 ret=0; while (m--)//输入边的信息和更新邻接矩阵 &#123; cin&gt;&gt;x&gt;&gt;y; e[x][y]=1; &#125; for(int i=1;i&lt;=nx;i++)//对二分图左边的所有顶点进行遍历 &#123; if(cx[i]==-1)//如果左边的i顶点还没有匹配的点，就对i顶点进行匹配 &#123; memset(visited,0,sizeof(visited));//每次进行point时，都要对visited数组进行初始化 ret+=point(i);//point函数传入的参数永远是二分图左边的点 &#125; &#125; cout&lt;&lt;ret&lt;&lt;endl; &#125; &#125;//%%%%%%%%%%%%//来自csdn--栾琪//%%%%%%%%%%%% 2、分析 我们拿出Fig2来分析一波： 分析一下$point()$函数的运行过程，第一次以$1$顶点为起点进入$point(1)$函数，然后5号顶点满足条件，更新$cx[1]，cy[5]$，返回$1$。此时$1→5$这条边为匹配边，$1$号，$5$号顶点为匹配顶点。 然后以$2$顶点为其实点进入$point(1)$函数，然后访问到$5$号节点，然后以$5$号节点的匹配点$1$号节点为起始点再次进入$point(2)$函数，找到了$7$号点，这时说明找到了增广路，然后更新$cx[1],cy[7]$，然后返回$1$，更新$cx[2],cy[5]$，返回$1$，函数结束。 然后以$3$号顶点为起始点进入$point(1)$函数，然后访问到$5$号节点，然后以$5$号节点的匹配点$2$号节点为起始点再次进入$point(2)$函数，找不到点了，返回$0$，到达$point(1)$函数，继续访问其他的节点。然后访问到$6$号顶点，满足条件，更新$cx[3],cy[6]$，返回$1$，函数结束。 然后以$4$号顶点为起始点进入$point(1)$函数，然后访问到$7$号节点，然后以$7$号节点的匹配点$1$号节点为起始点再次进入$point(2)$函数，然后找到$5$号节点，然后以$5$号节点的匹配点$2$号节点为起始点再次进入$point(3)$函数，找不到点了，返回$0$，到达$point(2)$函数，继续访问其他的节点，没有点了，返回$0$，到达$point(1)$函数，继续访问其他的节点，到达了$8$号节点，满足，然后更新$cx[4],cy[8]$，返回$1$，函数结束。 这样我们就找到了所有的匹配边。 五、KM算法见blog: https://www.cnblogs.com/wenruo/p/5264235.html https://www.cnblogs.com/logosG/p/logos.html?tdsourcetag=s_pcqq_aiomsg Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;limits.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cassert&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;list&gt;#include&lt;set&gt;#define INT 9654234#define mod 1000000007typedef long long ll;using namespace std;const int MAXN = 305;int N;int ex_gir[MAXN];//每个妹子的期望值int ex_boy[MAXN];//每个男生的期望值bool vis_gir[MAXN];//记录每一轮匹配过的女生bool vis_boy[MAXN];//记录每一轮匹配过的男生 每进行新的一轮，都要重新初始化这两个数组int match[MAXN];//match[i]代表和i男生匹配的女生的编号int slack[MAXN];//slack[i]代表i男生如果要获得女生的芳心，至少需要增加的期待值int love[MAXN][MAXN];//记录每个妹子和男生的好感度bool dfs(int gir)//dfs函数求的是编号为gir的女孩能否匹配到男生，如果能，返回true，否则，返回false&#123; vis_gir[gir]=true;//标记 for(int i=1;i&lt;=N;i++) &#123; if(vis_boy[i])//我们规定每次匹配对于某个男生只访问一遍，如果先前访问过了，就换个男生 continue ; int gap=ex_gir[gir]+ex_boy[i]-love[gir][i]; if(gap==0)//如果这个条件满足，说明编号为gir女孩和编号为i的男孩可能能够匹配成功 &#123; vis_boy[i]=true;//标记 if(match[i]==-1||dfs(match[i]))//如果这两个条件满足其中一个，说明编号为gir女孩和编号为i的男孩匹配成功 &#123; match[i]=gir; return true; &#125; &#125; else slack[i]=min(slack[i],gap);//如果gap不等于0，说明当前状态编号为gir女孩和编号为i的男孩不可能匹配成功，更新slack[i]。 &#125; return false;&#125;int km()&#123; memset(match,-1,sizeof(match)); memset(ex_boy,0,sizeof(ex_boy)); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) ex_gir[i]=max(love[i][j],ex_gir[i]);//初始化ex_gir数组 for(int i=1;i&lt;=N;i++) &#123; fill(slack,slack+N+1,INT); while (1)//这个while循环结束的条件是直到让编号为i的女生找到可以匹配的男生后 &#123; memset(vis_gir,false,sizeof(vis_gir)); memset(vis_boy,false,sizeof(vis_gir)); if(dfs(i))//如果这个条件满足，说明编号为i的女生找到了匹配的男生，换下一个女生,如果这个条件不满足，说明这个女生没有匹配到男生，让这个女生降低期望值后继续匹配 break ; int t=INT; for(int j=1;j&lt;=N;j++)//寻找在这一轮匹配中没有匹配到的男生如果要获得女生芳心所需要增加的期待值的最小值 if(!vis_boy[j]) t=min(t,slack[j]); for(int i=1;i&lt;=N;i++)//让在这一轮匹配中匹配过的女生的期待值减小，匹配过的男生的期待值增加 &#123; if(vis_gir[i]) ex_gir[i]-=t; if(vis_boy[i]) ex_boy[i]+=t; else slack[i]-=t;//因为有些女生的期待值减小了，所以这一轮没有被匹配过的男生得到女生的芳心所需要增加的期待值就变小了，所以slack数组中的相应的值要变小 &#125; &#125; &#125; int res=0;//计算好感和 for(int i=1;i&lt;=N;i++) res+=love[match[i]][i]; return res;&#125;int main()&#123; cin&gt;&gt;N; for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) cin&gt;&gt;love[i][j]; cout&lt;&lt;km()&lt;&lt;endl;&#125;//%%%%%%%%%%%%//来自csdn--栾琪//%%%%%%%%%%%% 六、Gale-Shapley—-婚姻匹配算法算法见blog: https://blog.csdn.net/Air_hjj/article/details/70828937 https://blog.csdn.net/lc_miao/article/details/78116064 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;limits.h&gt;#include &lt;sstream&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cassert&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;list&gt;#include&lt;set&gt;#define mod 1000000007#define MAXN 1000typedef long long ll;using namespace std;int ManArray[MAXN][MAXN],GirArray[MAXN][MAXN];//ManArray[i][j]代表编号为i的男生的第j位心仪女生是几号,GirArray[i][j]代表编号为i的女生的第j位心仪男生是几号int Man[MAXN],Gir[MAXN];//Man[i]代表i号男生所匹配到的女生是几号，Gir[i]代表i号女生所匹配到的男生是几号int ManStarPos[MAXN];//ManStarPos[i]代表i号男生现在匹配到的女生是他心目中的第几号心仪女生int n;stack &lt; int &gt;q;//始终存放没有匹配成功的男生的编号int GetPositionFromLaday(int GirI,int ManI)//这个函数求的是编号为ManI的男生在编号为GirI的女生的心中的排名顺序&#123; for(int i=0;i&lt;n;i++) if(GirArray[GirI][i]==ManI) return i;//返回这个顺序 return -1;&#125;void ManLookGir(int ManI)//为编号为ManI的男生匹配女生&#123; int NowGir=ManArray[ManI][ManStarPos[ManI]];//得到这个男生应该匹配的女生的编号 if(Gir[NowGir]==-1)//如果这个条件满足，说明这个女生没有和她对应匹配的男生，那么就匹配上 &#123; Man[ManI]=NowGir; Gir[NowGir]=ManI; &#125; else//这个女生现在已经有男朋友了 &#123; int OldMan=GetPositionFromLaday(NowGir,Gir[NowGir]);//得到现男友在这个女孩心中的排名 int NowMan=GetPositionFromLaday(NowGir,ManI);//得到我们要匹配的男生在这个女孩心中的排名 if(OldMan&lt;NowMan)//如果这个条件满足，说明这个女孩的现男友在这个女孩心中的排名要高于我们要匹配的这个男生的排名，这个女孩不换男朋友 &#123; ManStarPos[ManI]++; q.push(ManI); &#125; else//这个女孩更喜欢我们要匹配的这个男生，换男朋友 &#123; ManStarPos[Gir[NowGir]]++;//这是一个优化 q.push(Gir[NowGir]); Man[ManI]=NowGir; Gir[NowGir]=ManI; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; memset(Man,-1,sizeof(Man));//初始化这三个数组 memset(Gir,-1,sizeof(Gir)); memset(ManStarPos,0,sizeof(ManStarPos)); for(int i=0;i&lt;n;i++)//输入每个男生心目中对女生的排序 for(int j=0;j&lt;n;j++) cin&gt;&gt;ManArray[i][j]; for(int i=0;i&lt;n;i++)//输入每个女生心目中对男生的排序 for(int j=0;j&lt;n;j++) cin&gt;&gt;GirArray[i][j]; for(int i=0;i&lt;n;i++)//刚开始对每个男生都进行一次匹配，从每个男生最心仪的女生开始匹配。如果从程序这个地方进入ManLookGir函数，那么每个男生都会和自己最心仪的女生进行一次匹配，因为是ManStarPos数组决定的，至于能否匹配成功，这就不一定了 ManLookGir(i); while(!q.empty()) &#123; int i=q.top(); q.pop(); ManLookGir(i); &#125; for(int i=0;i&lt;n;i++) cout&lt;&lt;"Man NO.: "&lt;&lt;i&lt;&lt;" Laday NO.: "&lt;&lt;Man[i]&lt;&lt;endl;&#125;//%%%%%%%%%%%%//来自csdn--栾琪//%%%%%%%%%%%% 什么？你说为什么我后面都没了？都只挂了一个（不不不，其实是两个）博客地址呢？ 那还用说！我不会啊_(¦3」∠)_]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#323 C.Two permutations]]></title>
    <url>%2F2019%2F02%2F17%2FCodeForces-323-C-Two-permutations%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题B.Two Permutations题面这次我不想搬英文题面了，我懒一次吧，毕竟是fateice大佬给的翻译 简要翻译给你两个长度为n的排列，多次询问在第一个排列的[l1,r1]和第二个排列的[l2,r2]同时出现的数有多少个。 Input第一行包含一个整数$n$，即两个排列中的元素数。下一行包含$n$个整数，用空格分隔: $p_1, p_2 … p_n$ ，代表序列$1$。下一行包含$n$个整数，用空格分隔:$q_1,q_2…q_n$，代表序列$2$。 下面一行包含一个整数$m$，代表询问的次数。 下面的m行包含一行查询的描述。第i个询问的描述由4个整数组成:$a,b,c, d$。查询参数$l_1、r_1、1_2、r_2$由数字$a,b,c,d$通过以下算法得到 引入变量$x$。如果它是第一个查询，那么变量$x=0$，否则它等于前一个查询的值加上$1$。 引入函数$f(z) =((z-1+c)\ mod\ n)+1$。 假设$l_1 = min (f (a), f (b)), r_1 = max(f (a), f (b)), l_2 = min (f (c), f (d)), r_2=max(f (c), f (d))$ Output对于每个查询输出一行一个整数代表答案。 Sample Input 133 1 23 2 111 2 3 3 Sample Output 11 Sample Input 244 3 2 12 3 4 131 2 3 41 3 2 11 4 2 3 Sample Output 21 1 2 Hint$1\le n\le 10^6$，$1 \le m \le 2×10^5$。 $1\le p_i\le n$，$1\le a,b,c,d\le n$。 我们求出第二个排列的数在第一个排列中所对应的位置。 用可持久化的权值线段树来维护。 时间复杂度$O(mlogm)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N=1e6+10;const int M=2e5+10;struct seg_tree&#123; int l,r; int s;&#125;t[N*22];int rot[M&lt;&lt;4],cnt,n,q,answer,pos[M&lt;&lt;4],a[M&lt;&lt;4];void insert(int &amp;root,int l,int r,int posi,int last)&#123; root=++cnt; t[root].l=t[last].l,t[root].r=t[last].r; t[root].s=t[last].s+1; if(l==r) return; int mid=l+r&gt;&gt;1; if(posi&lt;=mid) insert(t[root].l,l,mid,posi,t[last].l); if(posi&gt;mid) insert(t[root].r,mid+1,r,posi,t[last].r);&#125;int query(int root,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) return t[root].s; int mid=l+r&gt;&gt;1,A=0; if(ll&lt;=mid) A+=query(t[root].l,l,mid,ll,rr); if(rr&gt;mid) A+=query(t[root].r,mid+1,r,ll,rr); return A;&#125;int get_read()&#123; return (read()+answer-1)%n+1;&#125;int main(int argc, char const *argv[])&#123; n=read(); for(register int i=1,x;i&lt;=n;++i) x=read(),pos[x]=i; for(register int i=1,x;i&lt;=n;++i) x=read(),a[i]=pos[x]; for(register int i=1;i&lt;=n;++i) insert(rot[i],1,n,a[i],rot[i-1]); q=read(); while(q--) &#123; int A=get_read(),B=get_read(),C=get_read(),D=get_read(); if(A&gt;B) swap(A,B); if(C&gt;D) swap(C,D); printf("%d\n",answer=query(rot[D],1,n,A,B)-query(rot[C-1],1,n,A,B)); ++answer; &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#558 E.A Simple Task]]></title>
    <url>%2F2019%2F02%2F16%2FCodeForces-558-E-A-Simple-Task%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题E.A Simple Task题面This task is very simple. Given a string $S$ of length $n$ and $q$ queries each query is on the format $i\ j\ k$ which means sort the substring consisting of the characters from $i$ to $j$ in non-decreasing order if $k=1$ or in non-increasing order if $k=0$ . Output the final string after applying the queries. 简要翻译给定一个长度不超过$10^5$的字符串（小写英文字母），和不超过$5×10^4$个操作。 每个操作 $L\ R\ K$ 表示给区间$[L,R]$的字符串排序，$K=1$为升序，$K=0$为降序。 最后输出最终的字符串。 Input第一行包含两个整数$n,q$，$n$代表字符串的长度，$q$代表询问的个数。 第二行包含一个字符串$S$。$S$只包含小写英文字母。 以下$q$行每行包含三个整数$i\ j\ k$。 Output输出一行表示经过$q$次操作之后的字符串$S$。 Sample Input 110 5abacdabcda7 10 05 8 11 4 03 6 07 10 1 Sample Output 1cbcaaaabdd Sample Input 210 1agjucbvdfk1 10 1 Sample Output 2abcdfgjkuv Hint$1\le n\le 10^5$，$0\le q\le 50,000$。 $1\le i\le j\le n$，$k∈\{0,1\}$。 样例解释1abacdabcda → abacdadcba abacdadcba → abacacddba abacacddba → cbaaacddba cbaaacddba → cbcaaaddba cbcaaaddba → cbcaaaabdd 我们用线段树来维护’$a$’-‘$c$’，我们可以用数字$1$~$26$代替。 我们每次改变序列时，先查询该区间内$1$~$26$每个数出现的次数，排完序后，我们可以知道该区间一定是连续的一段区间。 如果是升序，我们就对整个区间从小到大覆盖。 如果是降序，那就从大到小覆盖。 最后遍历一遍线段树输出即可。 总时间复杂度为$O(26nlogn)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N=100010;struct seg_tree&#123; bool is_changed[28]; int letter[28]; int l,r;&#125;t[N&lt;&lt;2];struct node&#123; int g[28];&#125;;void clear(node &amp;g)&#123; for(int i=1;i&lt;=26;++i) g.g[i]=0;&#125;int n,q,a[N];char c[N];void pushup(int root)&#123; for(int i=1;i&lt;=26;++i) t[root].letter[i]=t[root&lt;&lt;1].letter[i]+t[root&lt;&lt;1|1].letter[i];&#125;void build(int root,int l,int r)&#123; t[root].l=l,t[root].r=r; if(l==r) &#123; ++t[root].letter[a[l]]; return; &#125; int mid=l+r&gt;&gt;1; build(root&lt;&lt;1,l,mid); build(root&lt;&lt;1|1,mid+1,r); pushup(root);&#125;void pushdown(int root,int l,int r)&#123; if(t[root].l==t[root].r) return; for(int i=1;i&lt;=26;++i) if(t[root].is_changed[i]) &#123; for(int j=1;j&lt;=26;++j) &#123; t[root&lt;&lt;1].is_changed[j]=0; t[root&lt;&lt;1].letter[j]=0; t[root&lt;&lt;1|1].is_changed[j]=0; t[root&lt;&lt;1|1].letter[j]=0; &#125; t[root&lt;&lt;1].is_changed[i]=1; t[root&lt;&lt;1].letter[i]=t[root&lt;&lt;1].r-t[root&lt;&lt;1].l+1; t[root&lt;&lt;1|1].is_changed[i]=1; t[root&lt;&lt;1|1].letter[i]=t[root&lt;&lt;1|1].r-t[root&lt;&lt;1|1].l+1; t[root].is_changed[i]=0; &#125;&#125;node add(node a,node b)&#123; node g; clear(g); for(int i=1;i&lt;=26;++i) g.g[i]=a.g[i]+b.g[i]; return g;&#125;node query(int root,int l,int r,int ll,int rr)&#123; if(r&lt;ll||l&gt;rr) &#123; node g; clear(g); return g; &#125; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123; node g; clear(g); for(int i=1;i&lt;=26;++i) g.g[i]=t[root].letter[i]; return g; &#125; pushdown(root,l,r); int mid=l+r&gt;&gt;1; node g; clear(g); if(ll&lt;=mid) g=add(g,query(root&lt;&lt;1,l,mid,ll,rr)); if(rr&gt;mid) g=add(g,query(root&lt;&lt;1|1,mid+1,r,ll,rr)); return g;&#125;void change(int root,int l,int r,int ll,int rr,int k)&#123; if(r&lt;ll||l&gt;rr) return; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123; for(int i=1;i&lt;=26;++i) t[root].letter[i]=t[root].is_changed[i]=0; t[root].is_changed[k]=1; t[root].letter[k]=t[root].r-t[root].l+1; return; &#125; pushdown(root,l,r); int mid=l+r&gt;&gt;1; if(ll&lt;=mid) change(root&lt;&lt;1,l,mid,ll,rr,k); if(rr&gt;mid) change(root&lt;&lt;1|1,mid+1,r,ll,rr,k); pushup(root);&#125;void push_all_down(int root,int l,int r)&#123; pushdown(root,l,r); if(l==r) return; int mid=l+r&gt;&gt;1; push_all_down(root&lt;&lt;1,l,mid); push_all_down(root&lt;&lt;1|1,mid+1,r);&#125;void print(int root,int l,int r)&#123; if(l==r) &#123; for(int i=1;i&lt;=26;++i) if(t[root].letter[i]) &#123; putchar((char)((int)'a'+i-1)); return; &#125; &#125; int mid=l+r&gt;&gt;1; print(root&lt;&lt;1,l,mid); print(root&lt;&lt;1|1,mid+1,r);&#125;int main(int argc, char const *argv[])&#123; n=read(),q=read(); scanf("%s",c+1); for(int i=1;i&lt;=n;++i) a[i]=c[i]-'a'+1; build(1,1,n); while(q--) &#123; int l=read(),r=read(),k=read(); node g=query(1,1,n,l,r); for(int i=(k==1? 1:26);(k==1? i&lt;=26:i&gt;=1);l+=g.g[(k==1? i++:i--)]) change(1,1,n,l,l+g.g[i]-1,i); &#125; push_all_down(1,1,n); print(1,1,n); return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Regular Contest#068 E.Snuke Line]]></title>
    <url>%2F2019%2F02%2F16%2FAtcoder-Regular-Contest-068-E-Snuke-Line%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题E.Snuke Line题面Snuke has decided to play a game, where the player runs a railway company. There are $M+1$ stations on Snuke Line, numbered $0$ through $M$. A train on Snuke Line stops at station $0$ and every $d$-th station thereafter, where $d$ is a predetermined constant for each train. For example, if $d=3$, the train stops at station $0, 3, 6, 9$, and so forth. There are $N​$ kinds of souvenirs sold in areas around Snuke Line. The $i​$-th kind of souvenirs can be purchased when the train stops at one of the following stations: stations $l_i,l_i+1,l_i+2,…r_i​$. There are M values of d, the interval between two stops, for trains on Snuke Line: $1, 2, 3, …, M$. For each of these $M$ values, find the number of the kinds of souvenirs that can be purchased if one takes a train with that value of d at station $0$. Here, assume that it is not allowed to change trains. 简要翻译有$m$个点集，第$i$个点集包含$0$至$m$中编号是$i$的倍数的点。 给定$n$个区间，对于每个点集，求出有多少个区间包含点集内的至少一个点。 或者说是：有$n$个区间，现在询问你对于$1\le i\le m$的每个$i$，有多少个区间至少包含一个$i$的倍数？ Input输入的标准格式如下： 1234N Ml1 r1:lN rN Output输出答案$M$行。第$i$-th行包含停在$d$站的答案。 Sample Input 13 31 22 33 3 Sample Output 1322 Sample Input 27 91 75 95 75 91 16 83 4 Sample Output 2766545532 Hint$1\le M\le 10^5$ $1\le N\le 3×10^5$ $1\le l_i\le r_i\le M$ 我们如果按题目去题意去做，我也不知道怎么想。 我们反着思考，如果一个区间中没有$i​$的倍数，那么它一定是被相邻的两个$i​$的倍数夹在中间了，或是在最大的$i​$的倍数的右边了。 所以我们可以先读入所有的数据再用可持久化线段树离线处理啦！ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int M=100010;const int N=300010;struct seg_tree&#123; int cnt,l,r;&#125;t[N&lt;&lt;5];int cnt_sgt,p[M],n,m;struct rg&#123; int l,r; friend bool operator &lt; (rg a,rg b) &#123; return a.l&lt;b.l; &#125;&#125;rg[N];void pushup(int root)&#123; t[root].cnt=t[t[root].l].cnt+t[t[root].r].cnt;&#125;void insert(int &amp;root,int l,int r,int x)&#123; t[++cnt_sgt]=t[root],root=cnt_sgt; if(l==r) &#123; t[root].cnt++; return; &#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid) insert(t[root].l,l,mid,x); else insert(t[root].r,mid+1,r,x); pushup(root);&#125;int query(int root1,int root2,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) return t[root2].cnt-t[root1].cnt; int mid=l+r&gt;&gt;1; int s=0; if(ll&lt;=mid) s+=query(t[root1].l,t[root2].l,l,mid,ll,rr); if(rr&gt;mid) s+=query(t[root1].r,t[root2].r,mid+1,r,ll,rr); return s;&#125;int main(int argc, char const *argv[])&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) rg[i].l=read(),rg[i].r=read(); sort(rg+1,rg+1+n); int q=1; for(int i=1;i&lt;=m;++i) &#123; p[i]=p[i-1]; while(rg[q].l==i) insert(p[i],1,m,rg[q++].r); &#125; printf("%d\n",n); for(int i=2;i&lt;=m;++i) &#123; int answer=n,j; for(j=i;j&lt;=m;j+=i) answer-=query(p[j-i],p[j-1],1,m,j-i+1,j-1); if(j-i+1&lt;=m) answer-=query(p[j-i],p[m],1,m,j-i+1,m); printf("%d\n",answer); &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO2018.FEB Snow Boots S]]></title>
    <url>%2F2019%2F02%2F16%2FUSACO2018-FEB-Snow-Boots-S%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题#.Snow Boots S题面到冬天了，这意味着下雪了！从农舍到牛棚的路上有$N$块地砖，方便起见编号为$1…N$，第i块地砖上积了$f_i$英尺的雪 。在$Farmer John$的农舍的地窖中，总共有$B$双靴子，编号为$1…B$。其中某些比另一些结实，某些比另一些轻便。具体地说，第i双靴子能够让$FJ$在至多$s_i$英尺深的积雪中行走，能够让$FJ$每步至多前进$d_i$。$Farmer John$从$1$号地砖出发，他必须到达$N$号地砖才能叫醒奶牛们。$1$号地砖在农舍的屋檐下，$N$号地砖在牛棚的屋檐下，所以这两块地砖都没有积雪。帮助$Farmer John$求出哪些靴子可以帮助他走完这段艰辛的路程。 Input第一行包含两个空格分隔的整数$N$和$B$。 第二行包含$N​$个空格分隔的整数；第$i​$个整数为$f_i​$，即$i​$号地砖的积雪深度。 下面$B$行，每行包含两个空格分隔的整数。第$i+2$行的第一个数为$s_i$，表示第$i$双靴子能够承受的最大积雪深度。 第$i+2$行的第二个数为$d_i$，表示第$i$双靴子的最大步长。 Output输出包含$N$行。第$i行$包含一个整数：如果$FarmerJohn$能够穿着第$i$双靴子从$1$号地砖走到$N$号地砖，为$1$，否则为$0$。 Sample Input8 7 0 3 8 5 6 9 0 0 0 5 0 6 6 2 8 1 10 1 5 3 150 7 Sample Output0 1 1 0 1 1 1 Hint输入保证$f_1=f_N=0​$ ，$0≤s_i≤10^9​$。 $1≤d_i≤N-1$，$0≤f_i≤10^9$。 $1≤N,B≤10^5​$。 我先弃个坑。 12]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#438 D.The Child and Sequence]]></title>
    <url>%2F2019%2F02%2F16%2FCodeForces-438-D-The-Child-and-Sequence%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题#.The Child and Sequence题面At the children’s day, the child came to Picks’s house, and messed his house up. Picks was angry at him. A lot of important things were lost, in particular the favorite sequence of Picks. Fortunately, Picks remembers how to repair the sequence. Initially he should create an integer array $a[1],a[2],…,a[n]$ . Then he should perform a sequence of $m$ operations. An operation can be one of the following: Print operation $l,r$ . Picks should write down the value of $\sum_{i=l}^ra[i]$. Modulo operation $l,r,x$ . Picks should perform assignment $ a[i]=a[i]\ mod\ x $ for each $i$ $(l\le i\le r) $ . Set operation $k,x$ . Picks should set the value of $a[k]$ to $x$ (in other words perform an assignment $a[k]=x$ ). Can you help Picks to perform the whole sequence of op erations? 简要翻译给定你一个数列，要求支持区间和查询，区间取模，单点修改。 Input第一行包含两个整数$n,m$。 第二行包含用空格隔开的$n$个整数，$a[1],a[2],a[3]…a[n]$代表序列的值。 下面包含$m$行。每行开头包含一个整数$type$表示操作类型。 若$type=1$，后面跟着两个整数$l,r$，求$sum[l,r]$ 若$type=2$，后面跟着三个整数$l,r,x$，表示区间$[l,r]$对$x$取模。 若$type=3$，后面跟着两个整数$k,x$，表示将$a[k]$修改为$x$。 Output对于每个操作$1$，输出一个整数表示答案。 注意，答案可能会超出$int$。 Sample Input 15 51 2 3 4 52 3 5 43 3 51 2 52 1 3 31 1 3 Sample Output 18 5 Sample Input 210 106 9 6 7 6 1 10 10 9 51 3 92 7 10 92 5 10 81 4 73 3 72 7 9 91 2 41 6 61 5 93 1 10 Sample Output 249152319 Hint$1\le n,m\le 10^5,1\le a[i]\le 10^9$。 $type∈\{1,2,3\}$。 操作$1$中，$1\le l\le r\le n$。 操作$2$中，$1\le l\le r\le n,1\le x\le 10^9$。 操作$3$中，$1\le k\le n,1\le x\le 10^9$。 样例解释Σ(⊙▽⊙”a需要解释嘛？好吧还是解释一下吧www，只解释样例一哦 一开始,$a=1,2,3,4,5$。 第$1$次操作，$a=1,2,3,0,1$。 第$2$次操作，$a=1,2,5,0,1$。 第$3$次操作，$Ans=2+5+0+1=8$。 第$4$次操作，$a=1,2,2,0,1$。 第$5$次操作，$Ans=1+2+2=5$。 这道题啊，操作$1$和$3​$都是模板题吧？ 那么，操作$2$怎么办呢？ 对于操作$2$我们想： 如果我们原来的$a_i&lt;x$的话呢？那么我们就不需要取模了，这样就可以节约时间。 若果我们原来的$a_i&gt;=x$的话，我们就可以暴力维护。因为我们可以证明，一个数最多被模$log\ a_i$次，不懂得话就自己手推一波吧，很快的。 所以说，我们只需要维护区间最大值，如果最大值小于$x$的话，那么我们就直接在$change$里直接$return$就好了。 线段树本身时间复杂度$O(nlog\ n)$，乘$log \ a_i$，所以总时间复杂度为$O(nlog(n)loga_(i))​$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;int n,m;const int N=100010;struct seg_tree&#123; long long s; long long Max;&#125;t[N&lt;&lt;2];int a[N];void pushup(int root)&#123; t[root].s=t[root&lt;&lt;1].s+t[root&lt;&lt;1|1].s; t[root].Max=max(t[root&lt;&lt;1].Max,t[root&lt;&lt;1|1].Max);&#125;void build(int root,int l,int r)&#123; if(l==r) &#123; t[root].s=t[root].Max=a[l]; return; &#125; int mid=l+r&gt;&gt;1; build(root&lt;&lt;1,l,mid); build(root&lt;&lt;1|1,mid+1,r); pushup(root);&#125;void change(int root,int l,int r,int pos,int k)&#123; if(l==r) &#123; t[root].s=t[root].Max=k; return; &#125; int mid=l+r&gt;&gt;1; if(pos&lt;=mid) change(root&lt;&lt;1,l,mid,pos,k); if(pos&gt;mid) change(root&lt;&lt;1|1,mid+1,r,pos,k); pushup(root);&#125;void mod_it(int root,int l,int r,int ll,int rr,int mod)&#123; if(t[root].Max&lt;mod) return; if(l==r) &#123; t[root].s%=mod; t[root].Max%=mod; return; &#125; int mid=l+r&gt;&gt;1; if(ll&lt;=mid) mod_it(root&lt;&lt;1,l,mid,ll,rr,mod); if(rr&gt;mid) mod_it(root&lt;&lt;1|1,mid+1,r,ll,rr,mod); pushup(root);&#125;long long query(int root,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) return t[root].s; int mid=l+r&gt;&gt;1; long long t=0; if(ll&lt;=mid) t+=query(root&lt;&lt;1,l,mid,ll,rr); if(rr&gt;mid) t+=query(root&lt;&lt;1|1,mid+1,r,ll,rr); return t;&#125;int main(int argc, char const *argv[])&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); build(1,1,n); while(m--) &#123; int type=read(); if(type==1) &#123; int l=read(),r=read(); printf("%lld\n",query(1,1,n,l,r)); &#125; else if(type==2) &#123; int l=read(),r=read(),mod=read(); mod_it(1,1,n,l,r,mod); &#125; else &#123; int pos=read(),k=read(); change(1,1,n,pos,k); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#12 D.Ball]]></title>
    <url>%2F2019%2F02%2F15%2FCodeForces-12-D-Ball%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题#.Ball题面$N​$ ladies attend the ball in the King’s palace. Every lady can bedescribed with three values: beauty, intellect and richness. King’s Master of Ceremonies knows that ladies are very special creatures. If some lady understands that there is other lady at the ball which is more beautiful, smarter and more rich, she can jump out of the window. He knows values of all ladies and wants to find out how many probable self-murderers will be on the ball. Lets denote beauty of the $i​$-th lady by $B_i​$ , her intellect by $I_i​$ and her richness by $R_i​$ . Then $i​$-th lady is a probable self-murderer if there is some $j​$-th lady that $B_i&lt;B_j,I_i&lt;I_j,R_i&lt;R_j​$ . Find the number of probable self-murderers. 简要翻译有N个女士去参加舞会。每个女士有三个值a[i],b[i],c[i]。如果一位女士发现有其它女士的这三个值都比自己高的话就会去跳楼.求有多少跳楼的女士。 Input第一行包含一个整数$N$。 第二行包含$N​$个整数$B_i​$。 第三行包含$N​$个整数$I_i​$。 第四行包含$N$个整数$R_i$。 Output输出一个整数表示答案。 Sample Input31 4 24 3 22 5 3 Sample Output1 Hint$1\leq N\leq 500,000,0\leq B_i,I_i,R_i\leq 10^9$。 这题相当于给了你$n$个三元组，我们先将一维离散化乘线段树的下标，然后对剩下两维中的一维降序排序，最后用线段树来处理剩下一维。就非常ok了！ Code12]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1024 Max Sum Plus Plus]]></title>
    <url>%2F2019%2F02%2F15%2FHDU-1024-Max-Sum-Plus-Plus%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题C.Max Sum Plus Plus题面Now I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem. Given a consecutive number sequence $S_1,S_2,S_3,S_4…S_x,…S_n$. We define a function $sum(i,j)=S_i+…+S_j$($1\leq i\leq j\leq n​$). Now given an integer m ($m &gt; 0$), your task is to find $m$ pairs of $i$ and $j$ which make $sum(i_1,j_1)+sum(i_2,j_2)+…+sum(i_m,j_m)$ maximal ($i_x\leq i_y\leq j_x\ or\ \ i_x\leq j_y\leq j_x$ is not allowed). But I’m lazy, I don’t want to write a special-judge module, so you don’t have to output $m$ pairs of $i$ and $j$, just output the maximal summation of $sum(i_x,j_x)$($1\leq x\leq m$) instead. 简要翻译给出一列数$\{a_n\}​$ ，从中选出$𝑚​$个互不相交的子段，使得和最大，求这个最大值。 Input对于每组数据，都占一行。 每一行前面有两个整数$m,n$，之后又$n$个整数$S_1,S_2,S_3…S_n​$直到文件结束。 Output每组数据输出一个数表示答案。 Sample Input1 3 1 2 3 2 6 -1 4 -2 3 -2 3 Sample Output6 8 Hint输入数据很大，$scanf​$什么的可能会被卡掉哦~ $1\leq m\leq n\leq 1,000,000,-32768\leq S_x\leq32767$ 如果正整数的个数小于$m$个，那么只要选取前$m$大的数即可。 我们就能够由这样的思想来想到用线段树维护这个序列，每一次选取整个序列的最大子段，将和累加到答案中。 然后我们把这段正题都$×(-1)$，下次再次选中，那么就去掉原来所选的部分，这样就很巧妙的采用了题意。 我们操作$m$次，如果遇到了负数，那么就已经可以停止了(负数只会使答案更小)，因为此时我们已经得到了答案。 如果正整数的个数大于等于$m$，那么最终选取的段数一定大于$m$，那么我们就能够拆成$m$段。 所以我们就需要维护区间最大、最小值，区间前缀最大、最小值，区间后缀最大、最小值(我们$×(-1)$的操作需要维护最小值)。 总时间复杂度为$O(m\ logn)$。 Code1//我我我…………懒得打…………]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#242 E.XOR on Segment]]></title>
    <url>%2F2019%2F02%2F15%2FCodeForces-242-E-XOR-on-Segment%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题A.XOR on Segment题面You’ve got an array $a$ , consisting of $n$ integers $a_1$,$a_2$,…,$a_n$. You are allowed to perform two operations on this array: Calculate the sum of current array elements on the segment $[l,r]$ , that is, count value $a_l+a_{l+1}+…+a_r$ . Apply the $xor$ operation with $a$ given number $x$ to each array element on the segment $[l,r]$ , that is, execute . This operation changes exactly $r-l+1$ array elements. Expression means applying bitwise xor operation to numbers $x$ and $y$ . The given operation exists in all modern programming languages, for example in language $C++$ and Java it is marked as “^”, in Pascal — as “$xor$”. You’ve got a list of m m m operations of the indicated type. Your task is to perform all given operations, for each sum query you should print the result you get. 简要翻译给定一个长为$n$($n\leq10^5$)的数组 数组里的数不超过$10^6$ 有两种操作： 1:求$sum[l,r]$; 2:对$[l,r]$中的所有数和$x$异或 Input第一行包含一个整数$n$，表示数组的长度。 第二行包含用空格隔开的$n$个整数，$a_1,a_2,a_3,…,a_n$表示数组。 第三行包含一个整数$m$，表示操作的个数。 下面包含$m$行，每行包含一个整数$t_i$，表示操作的类型。 当$t_i=1$时，之后包含2个整数$l,r$，求$sum[l,r]$。 当$t_i=2$时，之后包含3个整数$l,r,x$，对$[l,r]$的数与$x$进行异或操作。 Output对于每个操作$1$，输出一行一个整数代表答案。 请不要使用”$\%lld​$”去读入或输出$long\ long​$；你最好使用”$cin​$,$cout​$”或者”$\%I64d​$”。 Sample Input 154 10 3 13 781 2 42 1 3 31 2 41 3 32 2 5 51 1 52 1 2 101 2 3 Sample Output 126 22 0 34 11 Sample Input 264 7 4 0 7 352 2 3 81 1 52 3 5 12 4 5 61 2 3 Sample Output 238 28 Hint$1\leq n\leq 10^5，0\leq a_i\leq 10^6$。 $1\leq m\leq 5×10^4$，$t=1\ or\ 2$。 $1\leq l_i\leq r_i\leq n$，$1\leq x_i\leq 10^6$。 区间的异或难以维护。 我们可以把所有的数拆成二进制的，那么由数据范围可知，每个数的二进制位数不超过20位，我们可以建20棵线段树。 每一棵线段树维护区间取反，$0→1$或$1→0$；区间求和。 所以用一个标记即可解决。 时间复杂度为$O(nklogn)$，$k$为二进制转化的位数，即所需线段树个数，$k\leq20$。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N=100010;const int mod=1e9+7;const int inf=0x3f3f3f3f;int n,m;struct seg_tree&#123; int s,Xor;&#125;t[N&lt;&lt;2][22];void pushdown(int root,int len,int bit)&#123; if(!t[root][bit].Xor) return; t[root&lt;&lt;1][bit].s=(len-(len&gt;&gt;1))-t[root&lt;&lt;1][bit].s; t[root&lt;&lt;1|1][bit].s=(len&gt;&gt;1)-t[root&lt;&lt;1|1][bit].s; t[root&lt;&lt;1][bit].Xor^=1,t[root&lt;&lt;1|1][bit].Xor^=1; t[root][bit].Xor=0;&#125;void pushup(int root,int bit)&#123; t[root][bit].s=t[root&lt;&lt;1][bit].s+t[root&lt;&lt;1|1][bit].s;&#125;void change(int root,int l,int r,int ll,int rr,int bit)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123; t[root][bit].Xor^=1; t[root][bit].s=(r-l+1)-t[root][bit].s; return; &#125; pushdown(root,r-l+1,bit); int mid=l+r&gt;&gt;1; if(ll&lt;=mid) change(root&lt;&lt;1,l,mid,ll,rr,bit); if(rr&gt;mid) change(root&lt;&lt;1|1,mid+1,r,ll,rr,bit); pushup(root,bit);&#125;int query(int root,int l,int r,int ll,int rr,int bit)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) return t[root][bit].s; pushdown(root,r-l+1,bit); int mid=l+r&gt;&gt;1,tot=0; if(ll&lt;=mid) tot+=query(root&lt;&lt;1,l,mid,ll,rr,bit); if(rr&gt;mid) tot+=query(root&lt;&lt;1|1,mid+1,r,ll,rr,bit); return tot;&#125;int main(int argc, char const *argv[])&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; int x=read(); for(int j=0;j&lt;=20;++j) if((1&lt;&lt;j)&amp;x) change(1,1,n,i,i,j); &#125; m=read(); while(m--) &#123; int type=read(); if(type==1) &#123; long long ans=0; int l=read(),r=read(); for(int i=20;~i;--i) ans=(ans&lt;&lt;1)+query(1,1,n,l,r,i); cout&lt;&lt;ans&lt;&lt;endl; &#125; else &#123; int l=read(),r=read(),x=read(); for(int i=0;i&lt;=20;++i) if((1&lt;&lt;i)&amp;x) change(1,1,n,l,r,i); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[究极的最大流算法ISAP与HLPP——钱逸凡]]></title>
    <url>%2F2019%2F02%2F15%2F%E7%A9%B6%E6%9E%81%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AE%97%E6%B3%95ISAP%E4%B8%8EHLPP__%E9%92%B1%E9%80%B8%E5%87%A1%2F</url>
    <content type="text"><![CDATA[本文搬运自洛谷大佬钱逸凡的博客 究级的最大流算法：ISAP与HLPP最大流的定义及基础解法这里就不再赘述了 有需要的可以看之前写的劣质文章EK与Dinic求解最大流的方法了 前言最大流算法目前有增广路算法和预流推进算法两种，增广路算法的思想是不断地寻找增广路来增大最大流，而预流推进算法的思想是……后面再讲。 先从最熟悉的增广路算法开始讲。 ISAP(Improved Shortest Augumenting Path）：其实Dinic已经足够高效了，但那些（闲着没事干）的计算机科学家们对Dinic的效率仍不满足，于是就有了ISAP算法。 在Dinic中我们每次增广前都进行了一次bfs来初始化每个点的深度，虽然一次标号增广了很多条路，但是我们还是很有可能要跑很多遍bfs导致效率不高。 那有没有什么办法只跑一次bfs呢?那就是ISAP算法了！ISAP运行过程：1.从t到s跑一遍bfs，标记深度（为什么是从t到s呢？后面会讲） 2.从s到t跑dfs，和Dinic类似，只是当一个点跑完后，如果从上一个点传过来的flow比该点的used大（对于该点当前的深度来说，该点在该点以后的路上已经废了），则把它的深度加1，如果出现断层（某个深度没有点），结束算法 3.如果操作2没有结束算法，重复操作2 好抽象啊。什么原理呢？ ISAP其实与Dinic差不多，但是它只跑一遍bfs，但是每个点的层数随着dfs的进行而不断提高（这样就不用反复跑bfs重新分层了），当s的深度大于n时（这就是为什么bfs要从t到s），结束算法。 先给一些数组定义： 12int dep[13000],gap[13000];//dep[i]表示节点i的深度，gap[i]表示深度为i的点的数量 bfs部分: 1234567891011121314151617181920void bfs()&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); dep[t]=0; gap[0]=1;// queue&lt;int&gt;q; q.push(t); while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=node[i].next)&#123; int v=node[i].v; if(dep[v]!=-1)continue;//防止重复改某个点 q.push(v); dep[v]=dep[u]+1; gap[dep[v]]++; &#125; &#125; return;&#125;//初始化bfs，从t到s搜出每个点初始深度 可以看出ISAP里的bfs对 边权!=0 这一条件并没有限制，只要在后面的dfs里判断边权就好了。 接下来是dfs： 1234567891011121314151617181920212223242526272829int dfs(int u,int flow)&#123; if(u==t)&#123;//可以到达t maxflow+=flow; return flow; &#125; int used=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;dep[d]+1==dep[u])&#123; int mi=dfs(d,min(node[i].val,flow-used)); if(mi)&#123; node[i].val-=mi; node[i^1].val+=mi; used+=mi; &#125; if(used==flow)return used; &#125; &#125; //前半段和Dinic一模一样 //如果已经到了这里，说明该点出去的所有点都已经流过了 //并且从前面点传过来的流量还有剩余 //则此时，要对该点更改dep //使得该点与该点出去的点分隔开 --gap[dep[u]]; if(gap[dep[u]]==0)dep[s]=n+1;//出现断层，无法到达t了 dep[u]++;//层++ gap[dep[u]]++;//层数对应个数++ return used; &#125; 感觉和Dinic差不多。 只是多几句话来统计深度对应的点数。 这里要解释一下为什么要统计每个深度的节点数：为了优化！统计每个深度对应点数只为了这句话： 1if(gap[dep[u]]==0)dep[s]=n+1; 因为我们是按照深度来往前走的，路径上的点的深度一定是连续的，而t的深度为0，如果某个深度的点不存在，那么我们就无法到达t了此时直接结束算法可以大大节省时间。 接下来是主函数： 123456int ISAP()&#123; maxflow=0; bfs(); while(dep[s]&lt;n)dfs(s,inf); return maxflow;&#125; 由于dfs部分（有点）相当抽象，可以结合图示理解。以下图为例：（反向边没有画，但是有反向边） 先 bfs 分层：（蓝色字体表示层数） 按照深度，我们只能走S-&gt;1-&gt;5-&gt;6-&gt;t这条增广路，流量为3 在dfs过程中，从5传到6时$flow==4$而在6号点的$used==3$，所以此时不会直接返回（见上方的代码），而是把6号点的深度加1，同理s,1,5的也要加1，也就是说，跑了这条增广路后，图变成了： 看见了吗？s-&gt;1-&gt;5-&gt;6-&gt;t这条路被封了，但是s-&gt;1-&gt;2-&gt;3-&gt;4-&gt;t这条路却能走了 按照深度，这次肯定是走s-&gt;1-&gt;2-&gt;3-&gt;4-&gt;t这条路。 这次的情况和上次不同，由于从2传到3时的flow==3而之后的路径的used都是3，所以2,3,4号点的深度不会改变，而1,s的情况与上次的那些点相同，深度会改变。 跑了这条路之后，图变成了： 图中出现了断层（深度为4的点没有了），所以一定不存在增广路了，可以直接结束算法了。 刚才那张图如果用Dinic会怎么样？三遍bfs，两遍dfs！与之相比，ISAP真是太高效了！这里顺便说一下为什么终止条件是dep[s]&lt;n 从上面的过程可以看出：每走一遍增广路，s的层数就会加1，如果一直没有出现断层，最多跑n-dep（刚bfs完时s的深度）条增广路（因为一共就n个点） 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int inf=1&lt;&lt;30;int cnt=1,head[13000];int n,m,s,t;inline int Read()&#123; int x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;struct Node&#123; int v; int next; int val;&#125;node[250000];inline void addedge(int u,int v,int val)&#123; node[++cnt].v=v; node[cnt].val=val; node[cnt].next=head[u]; head[u]=cnt;&#125;int dep[13000],gap[13000];void bfs()&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); dep[t]=0; gap[0]=1; queue&lt;int&gt;q; q.push(t); while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=node[i].next)&#123; int v=node[i].v; if(dep[v]!=-1)continue; q.push(v); dep[v]=dep[u]+1; gap[dep[v]]++; &#125; &#125; return;&#125;int maxflow;int dfs(int u,int flow)&#123; if(u==t)&#123; maxflow+=flow; return flow; &#125; int used=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;dep[d]+1==dep[u])&#123; int mi=dfs(d,min(node[i].val,flow-used)); if(mi)&#123; node[i].val-=mi; node[i^1].val+=mi; used+=mi; &#125; if(used==flow)return used; &#125; &#125; --gap[dep[u]]; if(gap[dep[u]]==0)dep[s]=n+1; dep[u]++; gap[dep[u]]++; return used; &#125;int ISAP()&#123; maxflow=0; bfs(); while(dep[s]&lt;n)dfs(s,inf); return maxflow;&#125;int main()&#123; int i=1; n=Read(),m=Read(),s=Read(),t=Read(); int u,v,w; for(i=1;i&lt;=m;i++)u=Read(),v=Read(),w=Read(),addedge(u,v,w),addedge(v,u,0); printf("%d",ISAP()); return 0;&#125; 当然，这东西也可以当前弧优化（原理见 Dinic ）只需要改一点即可： 1234while(dep[s]&lt;n)&#123; memcpy(cur,head,sizeof(head)); dfs(s,inf); &#125; dfs部分的修改就不放代码了，应该都会。 接下来就是相当抽象的预流推进算法了 在讲解算法之前，我们先来回顾一下最大流是干嘛的： 水流从一个源点s通过很多路径，经过很多点，到达汇点t，问你最多能有多少水能够到达t点。 在刚面对这个问题时，你或许会有这样的思路： 先从s往相邻点拼命灌水，然后让水不停地向t流，能流多少是多少。 这就是预流推进：能推流，就推流，最终t有多少水，最大流就是多少。 预流推进算法的思想：在讲思想之前，先引入一个概念： 余流： 听名字就知道是什么意思了，即每个点当前有多少水。 预留推进算法的思想是： 1.先假装s有无限多的水(余流)，从s向周围点推流（把该点的余流推给周围点，注意：推的流量不能超过边的容量也不能超过该点余流），并让周围点入队（ 注意：s和t不能入队 ） 2.不断地取队首元素，对队首元素推流 3.队列为空时结束算法，t点的余流即为最大流。 上述思路是不是看起来很简单，也感觉是完全正确的？ 但是这个思路有一个问题，就是可能会出现两个点不停地来回推流的情况，一直推到TLE。 怎么解决这个问题呢？ 给每个点一个高度，水只会从高处往低处流。在算法运行时， 不断地对有余流的点更改高度 ，直到这些点全部没有余流为止。 为什么这样就不会出现来回推流的情况了呢？ 当两个点开始来回推流时，它们的高度会不断上升，当它们的高度大于s时，会把余流还给s。 所以在开始预流推进前要先把s的高度改为n（点数），免得一开始s周围那些点就急着把余流还给s。 先用图解来表示算法的运行过程：以下图为例（反向边没画出来） 我们用深蓝色的字表示每个点的余流，用淡蓝色的字表示每个点的高度。 刚开始肯定是： 我们把s点的高度改成6（一共6个点） 然后从往s拼命地灌水，水流会顺着还没满的边向周围的节点流 此时1,3节点还有余流，于是更新1,3号点高度，更新为与它相邻且最低的点的高度+1。 此时我们对1号节点推流。 更新有余流的1,2号节点的高度 为什么1的高度变成了7呢？因为1与s有反向边，因为刚才推过流，反向边有了边权，与1连通的最低的点就是s。 然后是对3节点推流（更新高度是同时进行的只是刚才为了便于理解而分开画了） 然后是2号点推流，注意t点不能更新高度（否则好不容易流过去的水就会往回流了） 4号点推流 2号点推流 3号点推流 除了s和t以外，所有节点都无余流，算法结束，最大流就是t的余流。 完整代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// luogu-judger-enable-o2//效率相当低，吸氧气都过不了模板#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int inf=1&lt;&lt;30;;int n,m,s,t;struct Node&#123; int v; int val; int next;&#125;node[205202];int top=1;int inque[13000];int head[13000];int h[13000];int e[13000];//每个点的高度，每个点的剩余（多余）流量inline int Read()&#123; int x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;//读入优化 inline int min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline void addedge(int u,int v,int val)&#123; node[++top].v=v; node[top].val=val; node[top].next=head[u]; head[u]=top;&#125;inline void add(int u,int v,int val)&#123; addedge(u,v,val); addedge(v,u,0);&#125;int maxflow;inline void push_(int u,int i)&#123; int mi=min(e[u],node[i].val); node[i].val-=mi; node[i^1].val+=mi; e[u]-=mi; e[node[i].v]+=mi;&#125;//从u到v推流,i为u与v相连的那一条边的编号 inline bool relabel(int u)&#123; int mh=inf; register int i; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val)&#123; mh=min(mh,h[d]); &#125; &#125; if(mh==inf)return 0;//无可以流的路径 h[u]=mh+1;//把u点拉到可流点以上（使水流能从u流向周围的点） return 1; &#125;//判断点u是否能流向周围点int push_relabel()&#123; queue&lt;int&gt;q; h[s]=n;//把源点的高度设成n（图中的点数） for(register int i=head[s];i;i=node[i].next)&#123; int d=node[i].v; int val=node[i].val; if(val)&#123; node[i].val-=val; node[i^1].val+=val; e[s]-=val; e[d]+=val; if(inque[d]==0&amp;&amp;d!=t&amp;&amp;d!=s&amp;&amp;relabel(d))&#123; q.push(d); inque[d]=1; &#125; &#125;//给所有与s相连的点推入满流 &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); inque[u]=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(e[u]==0)break; if(node[i].val==0)continue; if(h[u]==h[d]+1) push_(u,i); if(e[d]!=0&amp;&amp;d!=t&amp;&amp;d!=s)&#123; if(inque[d]==0&amp;&amp;relabel(d))&#123; q.push(d); inque[d]=1; &#125; &#125; &#125; if(e[u]&amp;&amp;inque[u]==0&amp;&amp;relabel(u))&#123; q.push(u); inque[u]=1; &#125; &#125; return e[t];&#125;//push_relabelint main()&#123; n=Read(),m=Read(),s=Read(),t=Read(); register int i; int u,v,val; for(i=1;i&lt;=m;i++)u=Read(),v=Read(),val=Read(),add(u,v,val); printf("%d",push_relabel()); return 0;&#125; 这个预流推进算法相当慢，至于P4722 【模板】最大流 加强版 / 预流推进（毒瘤题）更没希望。 那为什么这么慢，我们还要学呢？ 为了下面的讲解做铺垫。 最高标号预流推进（HLPP）算法步骤： 1.先从t到s反向bfs，使每个点有一个初始高度 2.从s开始向外推流，将有余流的点放入优先队列 3.不断从优先队列里取出高度最高的点进行推流操作 4.若推完还有余流，更新高度标号，重新放入优先队列 5.当优先队列为空时结束算法，最大流即为t的余流 与基础的余流推进相比的优势： 通过bfs预先处理了高度标号，并利用优先队列（闲着没事可以手写堆）使得每次推流都是高度最高的顶点，以此减少推流的次数和重标号的次数。 优化： 和ISAP一样的gap优化，如果某个高度不存在，将所有比该高度高的节点标记为不可到达（使它的高度为n+1，这样就会直接向s推流了）。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;inline int Read()&#123; int x=0; char c=getchar(); while(c&gt;'9'||c&lt;'0')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;const int inf=1&lt;&lt;30;int top=1,head[10100];int n,m,s,t;int e[10100],h[10100],cnth[20100];//每个点对应的余流，高度；每个高度有多少个点 struct cmp&#123; inline bool operator () (int a,int b) const&#123; return h[a]&lt;h[b]; &#125;&#125;;struct Node&#123; int v; int val; int next;&#125;node[400100];inline void addedge(int u,int v,int val)&#123; node[++top].v=v; node[top].val=val; node[top].next=head[u]; head[u]=top;&#125;inline void add(int u,int v,int val)&#123; addedge(u,v,val); addedge(v,u,0);&#125;int inque[11000];void bfs()&#123; memset(h,0x3f,sizeof(h)); h[t]=0; queue&lt;int&gt;qu; qu.push(t); while(!qu.empty())&#123; int u=qu.front(); qu.pop(); inque[u]=0; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i^1].val&amp;&amp;h[d]&gt;h[u]+1)&#123;//反向跑 h[d]=h[u]+1; if(inque[d]==0)&#123; qu.push(d); inque[d]=1; &#125; &#125; &#125; &#125; return;&#125;priority_queue&lt;int,vector&lt;int&gt;,cmp&gt;q;inline void push_(int u)&#123; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;h[d]+1==h[u])&#123;//可以推流 int mi=min(node[i].val,e[u]); node[i].val-=mi; node[i^1].val+=mi; e[u]-=mi; e[d]+=mi; if(inque[d]==0&amp;&amp;d!=t&amp;&amp;d!=s)&#123; q.push(d); inque[d]=1; &#125; if(e[u]==0)break;//已经推完了 &#125; &#125;&#125;//推流 inline void relabel(int u)&#123; h[u]=inf; for(int i=head[u];i;i=node[i].next)&#123; int d=node[i].v; if(node[i].val&amp;&amp;h[d]+1&lt;h[u])&#123; h[u]=h[d]+1; &#125; &#125;&#125;//把u的高度更改为与u相邻的最低的点的高度加1 int hlpp()&#123; register int i; bfs(); if(h[s]==0x3f3f3f3f)return 0;//s与t不连通 h[s]=n; for(i=1;i&lt;=n;i++)if(h[i]&lt;0x3f3f3f3f)cnth[h[i]]++;//统计各个高度的点数，注意不要让下标越界 for(i=head[s];i;i=node[i].next)&#123; int d=node[i].v; int mi=node[i].val; if(mi)&#123; e[s]-=mi; e[d]+=mi; node[i].val-=mi; node[i^1].val+=mi; if(d!=t&amp;&amp;inque[d]==0&amp;&amp;d!=s)&#123; q.push(d); inque[d]=1; &#125; &#125; &#125;//从s向周围点推流 while(!q.empty())&#123; int u=q.top(); inque[u]=0; q.pop(); push_(u); if(e[u])&#123;//还有余流 cnth[h[u]]--; if(cnth[h[u]]==0)&#123; for(int i=1;i&lt;=n;i++)&#123; if(i!=s&amp;&amp;i!=t&amp;&amp;h[i]&gt;h[u]&amp;&amp;h[i]&lt;n+1)&#123; h[i]=n+1;//标记无法到达 &#125; &#125; &#125;//gap优化 relabel(u); cnth[h[u]]++; q.push(u); inque[u]=1; &#125; &#125; return e[t];&#125; int main()&#123; n=Read(),m=Read(),s=Read(),t=Read(); register int i; int u,v,val; for(i=1;i&lt;=m;i++)u=Read(),v=Read(),val=Read(),add(u,v,val); printf("%d",hlpp()); return 0;&#125; 这次终于可以过掉那道毒瘤题了。 总结：ISAP的时间复杂度为O(n^2m),而HLPP的时间复杂度O(n^2sqrt(m)),但由于HLPP常数过大，在纯随机数据（模板题）下跑得还没有ISAP快，一般来说，用ISAP就够了。 最后感谢钱逸凡大佬的经验共享QWQ]]></content>
      <categories>
        <category>更多优秀的算法</category>
      </categories>
      <tags>
        <tag>Magical Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Grand Contest#016 F.Games on DAG]]></title>
    <url>%2F2019%2F02%2F14%2FAtcoder-Grand-Contest-016-F-Games-on-DAG%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题G.Games on DAG题面There is a directed graph $G$ with $N$ vertices and $M$ edges. The vertices are numbered $1$ through $M$. Edge $i$ is directed from $x_i$ to $y_i$ holds. Alse, there are no multiple edges in $G$. Consider selecting a subset of the set of the $M$ edges in $G$, and removing these edges from $G$ to obtain another graph $G’$. There are $2^M$ different possible graphs as $G’$. Alice and Bob play against each other in the following game played on $G’$. First, place two pieces on vertices $1$ and $2$, one on each. Then, starting from Alice, Alice and Bob alternately perform the following operation: Select an edge $i$ such that there is a piece placed on vertex $x_i$, and move the piece to vertex $y_i$(if there are two pieces on vertex $x_i$, only move one). The two pieces are allowed to be placed on the same vertex. The player loses when he(or she) becomes unable to perform the operation. We assume that both players play optimally. Among the $2^M$ different possible graphs as $G’$, how many lead to Alice’s victory? Find the count modulo $10^9+7$.]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#254 C.DZY Loves Colors]]></title>
    <url>%2F2019%2F02%2F14%2FCodeForces-254-C-DZY-Loves-Colors%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题F.DZY Loves Colors题面$DZY$ loves colors, and he enjoys painting. On a colorful day, $DZY$ gets a colorful ribbon, which consists of $n$ units (they are numbered from $1$ to $n$ from left to right). The color of the $i$-th unit of the ribbon is $i$ at first. It is colorful enough, but we still consider that the colorfulness of each unit is $0​$ at first. $DZY$ loves painting, we know. He takes up a paintbrush with color $x$ and uses it to draw a line on the ribbon. In such a case some contiguous units are painted. Imagine that the color of unit $i$ currently is $y$. When it is painted by this paintbrush, the color of the unit becomes $x$, and the colorfulness of the unit increases by $|x - y|$. $DZY$ wants to perform $m$ operations, each operation can be one of the following: Paint all the units with numbers between $l$ and $r$ (both inclusive) with color $x$. Ask the sum of colorfulness of the units between $l$ and $r​$ (both inclusive). Can you help $DZY$? 简要翻译$DZY$喜欢色彩，他热爱绘画。 在一个多姿多彩的日子里，$DZY$得到了一个彩色的缎带，它由$N$个单元组成（从左到右从$1$到$n$编号）。色带的第$i$个单位的最初颜色是$i$。虽然颜色足够丰富，但我们仍然认为每个单元的颜色数量最初是$0$。 $DZY$热衷于绘画，我们知道。他拿起一把彩色$X$笔，用它在缎带上画一条线。在这种情况下，他就绘制了一段连续的单元。想象一下，单位$i$被涂之前颜色是$Y$。被涂之后时，单元的颜色变为$X$，令单位的颜色增加了 $∣X−Y∣$。 $DZY$想要执行$M$个操作，每个操作可以是下列操作之一： $1$、将区间 [$L,R$] 内单元绘制为颜色$X$。 $2$、询问 [$L,R$] 之间的单位颜色的总和（包括两者）。 你能帮助$DZY$吗？ Input第一行包含两个整数$n,m$。 下面$m$行中每一行以一个整数$type$开头，表示操作类型。 若$type=1$，那么该行接下来有3个整数$L,R,X$，描述操作$1$； 若$type=2$，那么该行接下来有2个整数$L,R$，描述操作$2$。 Output对于每个操作$2$，输出一行，包含着色数量之和。 Sample Input 13 31 1 2 41 2 3 52 1 3 Sample Output 18 Sample Input 23 41 1 3 42 1 12 2 22 3 3 Sample Output 23 2 1 Sample Input 310 61 1 5 31 2 7 91 10 10 111 3 8 121 1 10 32 1 10 Sample Output 3129 Hint$1\leq n,m,\leq 10^5$ $1\leq type\leq 2$ $1\leq l\leq r\leq n$，$1\leq x\leq 10^8$。 本题的题意非常的明了，一开始的$a[i]=i,b[i]=0$，使区间 $[l,r]$的$b[i]+=|x-a[i]|$，$a[i]=x$，并查询 $[l,r]$ 的$b[i]$和。 我们用一个线段树就可以很容易地维护他们了。 不多说，直接上代码吧。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N=500010;struct seg_tree&#123; long long lazy,s,flag;&#125;t[N&lt;&lt;2];int n,m;void build(int root,int l,int r)&#123; if(l==r) &#123; t[root].flag=l; return; &#125; int mid=l+r&gt;&gt;1; build(root&lt;&lt;1,l,mid); build(root&lt;&lt;1|1,mid+1,r); // pushup(root);&#125;long long query(int root,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) return t[root].s; int mid=l+r&gt;&gt;1; long long ans=0; if(ll&lt;=mid) ans+=query(root&lt;&lt;1,l,mid,ll,rr); if(rr&gt;mid) ans+=query(root&lt;&lt;1|1,mid+1,r,ll,rr); return ans+max(0,min(r,rr)-max(l,ll)+1)*t[root].lazy;&#125;void empty(int root,int l,int r,int s)&#123; if(t[root].flag) &#123; t[root].lazy+=abs(t[root].flag-s); t[root].s+=abs(t[root].flag-s)*(r-l+1); t[root].flag=0; return; &#125; if(l==r) return; int mid=l+r&gt;&gt;1; empty(root&lt;&lt;1,l,mid,s); empty(root&lt;&lt;1|1,mid+1,r,s); t[root].s=t[root&lt;&lt;1].s+t[root&lt;&lt;1|1].s+t[root].lazy*(r-l+1);&#125;void pushdown(int root)&#123; if(!t[root].flag) return; t[root&lt;&lt;1].flag=t[root&lt;&lt;1|1].flag=t[root].flag; t[root].flag=0;&#125;void change(int root,int l,int r,int ll,int rr,int s)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123; empty(root,l,r,s); t[root].flag=s; return; &#125; int mid=l+r&gt;&gt;1; pushdown(root); if(ll&lt;=mid) change(root&lt;&lt;1,l,mid,ll,rr,s); if(rr&gt;mid) change(root&lt;&lt;1|1,mid+1,r,ll,rr,s); t[root].s=t[root&lt;&lt;1].s+t[root&lt;&lt;1|1].s+t[root].lazy*(r-l+1);&#125;int main(int argc, char const *argv[])&#123; n=read(),m=read(); build(1,1,n); while(m--) &#123; int type=read(); if(type==1) &#123; int l=read(),r=read(),x=read(); change(1,1,n,l,r,x); &#125; else &#123; int l=read(),r=read(); printf("%lld\n",query(1,1,n,l,r)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#271 F.Ant Colony]]></title>
    <url>%2F2019%2F02%2F14%2FCodeForces-271-F-Ant-Colony%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题D.Ant Colony题面Mole is hungry again. He found one ant colony, consisting of $n$ ants, ordered in a row. Each ant $i$ ($1\leq i\leq n$) has a strength $s_i$. In order to make his dinner more interesting, Mole organizes a version of «Hunger Games» for the ants. He chooses two numbers $l$ and $r$ ($1\leq l\leq r\leq n$) and each pair of ants with indices between $l$ and $r$ (inclusively) will fight. When two ants $i$ and $j$ fight, ant $s_i$ gets one battle point only if $s_i$ divides $s_j$ (also, ant $j$ gets one battle point only if $s_j$ divides $s_i$). After all fights have been finished, Mole makes the ranking. An ant $i​$, with $v_i​$ battle points obtained, is going to be freed only if $v_i=r-l​$, or in other words only if it took a point in every fight it participated. After that, Mole eats the rest of the ants. Note that there can be many ants freed or even none. In order to choose the best sequence, Mole gives you $t$ segments $[l_i,r_i]$ and asks for each of them how many ants is he going to eat if those ants fight. 简要翻译给定一个长度为$𝑛$的序列，$𝑞$个询问。 每次给定区间$ 𝑙,𝑟 $，将$ 𝑙,𝑟 $中所有数两两比较。 如果$𝑎,𝑏 ∈ 𝑙,𝑟 $，$𝑎|𝑏$则$𝑎$得一分，$𝑏|𝑎$则$𝑏$得一分。 问有多少个数没有得到满分。 Input第一行包含一个整数$n$，代表序列的大小。 第二行包含$n$个整数，$s_1,s_2,s_3…s_n$，代表序列的值。 第三行包含一个整数$t$，代表询问个数。 下面有$t$行，每行包含两个整数$l_i,r_i$描述一个询问。 Output输出包含$t$行。 第$i$行输出一个数表示 $[l_i,r_i]$ 中的没有满分的数的个数。 Sample Input5 1 3 2 4 2 4 1 5 2 5 3 5 4 5 Sample Output4 4 1 1 Note || （本来想搬样例解释的，不过既然是题解那就算了吧） Hint$1\leq n\leq 10^5$，$1\leq s_i\leq 10^9$。 $1\leq t\leq 10^5$，$1\leq l_i\leq r_i\leq n$。 我们可以比较显然的知道，能留下的数一定是区间的最小$gcd$，于是我们就只要找区间内与区间最小$gcd$相等的数的个数。 区间最小$gcd$一定小于等于区间$min$，我们只要判断最小值是否是区间最小$gcd$，如果是，就可以求出最小值的个数，也就能求出答案了。 根据数据范围和要求维护的数据，我们尝试用线段树来维护。 分别维护$gcd$，区间$min$，以及区间$min$的个数。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N=100010;struct seg_tree&#123; int min,gcd,cnt;&#125;t[N&lt;&lt;2];int a[N];int n,m;int minA,gcdA,cntA;int gcd(int a,int b)&#123; return !b? a:gcd(b,a%b);&#125;void pushup(int root)&#123; t[root].min=min(t[root&lt;&lt;1].min,t[root&lt;&lt;1|1].min); t[root].gcd=gcd(t[root&lt;&lt;1].gcd,t[root&lt;&lt;1|1].gcd); if(t[root&lt;&lt;1].min==t[root&lt;&lt;1|1].min) t[root].cnt=t[root&lt;&lt;1].cnt+t[root&lt;&lt;1|1].cnt; else if(t[root&lt;&lt;1].min&gt;t[root&lt;&lt;1|1].min) t[root].cnt=t[root&lt;&lt;1|1].cnt; else t[root].cnt=t[root&lt;&lt;1].cnt;&#125;void build(int root,int l,int r)&#123; if(l==r) &#123; t[root].min=t[root].gcd=a[l]; t[root].cnt=1; return; &#125; int mid=l+r&gt;&gt;1; build(root&lt;&lt;1,l,mid); build(root&lt;&lt;1|1,mid+1,r); pushup(root);&#125;void query(int root,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) &#123; gcdA=gcd(gcdA,t[root].gcd); if(minA==t[root].min) cntA+=t[root].cnt; else if(minA&gt;t[root].min) cntA=t[root].cnt,minA=t[root].min; return; &#125; int mid=l+r&gt;&gt;1; if(ll&lt;=mid) query(root&lt;&lt;1,l,mid,ll,rr); if(rr&gt;mid) query(root&lt;&lt;1|1,mid+1,r,ll,rr);&#125;int main(int argc, char const *argv[])&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); build(1,1,n); // cout&lt;&lt;"YES"&lt;&lt;endl; m=read(); while(m--) &#123; int l=read(),r=read(); minA=1000000001; gcdA=cntA=0; query(1,1,n,l,r); if(gcdA==minA) printf("%d\n",r-l+1-cntA); else printf("%d\n",r-l+1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[image]]></title>
    <url>%2F2019%2F02%2F14%2Fimage%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Photo Collection</category>
      </categories>
      <tags>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚁群算法(Ant Colony)]]></title>
    <url>%2F2019%2F02%2F14%2F%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天，我在网上翻到一个神奇的算法蚁群算法！某大佬的blog：https://blog.csdn.net/lyxleft/article/details/82980760 记得学哈~]]></content>
      <categories>
        <category>空闲时间的小点心</category>
      </categories>
      <tags>
        <tag>Magical Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1848 Fibonacci again and again]]></title>
    <url>%2F2019%2F02%2F13%2FHDU-1848-Fibonacci-again-and-again%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题#.Fibonacci again and again题面 任何一个大学生对菲波那契数列($Fibonacci numbers$)应该都不会陌生，它是这样定义的：$F(1)=1;$$F(2)=2;$$F(n)=F(n-1)+F(n-2)(n&gt;=3);$所以，$1,2,3,5,8,13$……就是菲波那契数列。在HDOJ上有不少相关的题目，比如$1005\ Fibonacci\ again\ and\ again$就是曾经的浙江省赛题。今天，又一个关于$Fibonacci$的题目出现了，它是一个小游戏，定义如下：1、 这是一个二人游戏;2、 一共有$3$堆石子，数量分别是$m, n, p$个；3、 两人轮流走;4、 每走一步可以选择任意一堆石子，然后取走$f$个；5、 $f$只能是菲波那契数列中的元素（即每次只能取$\ 1，2，3，5，8$…等数量）；6、 最先取光所有石子的人为胜者； 假设双方都使用最优策略，请判断先手的人会赢还是后手的人会赢。 Input输入数据包含多个测试用例，每个测试用例占一行，包含$3​$个整数$m,n,p​$。$m=n=p=0​$则表示输入结束。 Output 如果先手的人能赢，请输出“$Fibo$”，否则请输出“$Nacci$”，每个实例的输出占一行。 Sample Input1 1 1 1 4 1 0 0 0 Sample OutputFibo Nacci Hint$1\leq m,n,p\leq 1,000$ 来自$ACM\ Short\ Term\ Exam\ 2007/12/13$ (Html Address:http://acm.hdu.edu.cn/search.php?field=problem&amp;key=ACM+Short+Term+Exam_2007%2F12%2F13&amp;source=1&amp;searchmode=source) 这题啊！ 裸的SG函数呀！ 没学过的大佬们逛一波博客吧！ （maybe…几万年以后我也会写一篇的吧~） Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x=0,w=0; char ch=0; while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return w? -x:x;&#125;const int MAXN=1010;int f[MAXN],sg[MAXN];void Fibonacci()&#123; f[1]=1,f[2]=2; for(int i=3;i&lt;=200;++i) &#123; f[i]=f[i-1]+f[i-2]; if(f[i]&gt;1000) break; &#125;&#125;map&lt;int,int&gt; ma;void Build_Map(int lim)&#123; for(int i=1;i&lt;=lim;++i) &#123; ma.clear(); for(int j=1;f[j]&lt;=i;++j) ++ma[sg[i-f[j]]]; for(int j=0;j&lt;=lim;++j) if(!ma[j]) &#123; sg[i]=j; break; &#125; &#125;&#125;int a,b,c;int main()&#123; Fibonacci(); Build_Map(1000); while(1) &#123; a=read(),b=read(),c=read(); if(!a&amp;&amp;!b&amp;&amp;!c) return 0; int sum=0; sum^=sg[a]^sg[b]^sg[c]; if(!sum) puts("Nacci"); else puts("Fibo"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.2.13-Contest]]></title>
    <url>%2F2019%2F02%2F13%2F2019-2-13-Contest%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~本蒟蒻较懒，想直接贴pdf的图片。 于是下载了一个转化器，结果最后一张还带了水印。 (能看就行)]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 2640 Help Me Escape]]></title>
    <url>%2F2019%2F02%2F12%2FZOJ-2640-Help-Me-Excape%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题B.Help Me Escape背景If thou doest well, shalt thou not be accepted? and if thou doest not well, sin lieth at the door. And unto thee shall be his desire, and thou shalt rule over him. And Cain talked with Abel his brother: and it came to pass, when they were in the field, that Cain rose up against Abel his brother, and slew him. And the LORD said unto Cain, Where is Abel thy brother? And he said, I know not: Am I my brother’s keeper? And he said, What hast thou done? the voice of thy brother’s blood crieth unto me from the ground. And now art thou cursed from the earth, which hath opened her mouth to receive thy brother’s blood from thy hand; When thou tillest the ground, it shall not henceforth yield unto thee her strength; a fugitive and a vagabond shalt thou be in the earth. ​ $ —— Bible Chapter 4$ 题面 Now Cain is unexpectedly trapped in a cave with N paths. Due to LORD’s punishment, all the paths are zigzag and dangerous. The difficulty of the ith path is ci. Then we define f as the fighting capacity of Cain. Every day, Cain will be sent to one of the N paths randomly. Suppose Cain is in front of the ith path. He can successfully take ti days to escape from the cave as long as his fighting capacity f is larger than ci. Otherwise, he has to keep trying day after day. However, if Cain failed to escape, his fighting capacity would increase ci as the result of actual combat. (A kindly reminder: Cain will never died.) As for ti, we can easily draw a conclusion that ti is closely related to ci. Let’s use the following function to describe their relationship: t_i=\lfloor \frac{1+\sqrt 5}2×c_i^2\rfloor After D days, Cain finally escapes from the cave. Please output the expectation of D. 简要翻译有$n$个妖怪，每个妖怪有一个战斗力$c_j$。小A有一个初始战斗力$f_0$。 每天，小A随机选择一个妖怪决斗。设小A在第𝑖天的战斗力为$f_i$。 设当前为第$𝑖$天，如果打赢，即$𝑓_i &gt; 𝑐_j$，就可以逃出去，需要花$t_j$天。 如果打不赢，小A会让自己变强，$𝑓_{i+1} = 𝑓_i+ 𝑐_j$。 求小A逃出来需要的期望天数。 Input输入包含多组数据。 每组数据包括两行。第一行包含一个$n$和$f$，第二行包含$n$个整数$c_i$。 Output对于每组数据你要输出期望值，保留小数点后三位。 Sample Input3 1 1 2 3 Sample Output6.889 Hint$n\leq 100$，$f\leq 10,000$，$c_i\leq10,000，1\leq i\leq n$。 用$f(i)$表示战斗力为$i$时，所需要的期望天数。 那么有：若$i&gt;c_j$，则$f(i)=f(i)+\frac 1n(t_j)$； 若（$i\leq c_j$），则$f(i)=f(i)+\frac 1n(f(i+c_j)+1)$。 然后进行记忆化搜索。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;struct data&#123; int c, t;&#125;;bool vis[100010];vector&lt;data&gt; vs;int N, F;double dp[100010];double dfs(int f)&#123; if (vis[f]) return dp[f]; vis[f] = 1; double A = 0; for (int i = 0; i &lt; N; ++i) if (vs[i].c &gt;= f) A += (1 + dfs(f + vs[i].c)) / N; else A += 1.0 * vs[i].t / N; return dp[f] = A;&#125;int main()&#123; while (~scanf("%d%d", &amp;N, &amp;F)) &#123; vs.clear(); memset(vis, 0, sizeof(vis)); for (int i = 0, g; i &lt; N; ++i) &#123; g = read(); int p = (1 + sqrt(5)) / 2 * g * g; vs.push_back((data) &#123;g, p&#125;); &#125; printf("%.3lf\n", dfs(F)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2096 Collecting Bugs]]></title>
    <url>%2F2019%2F02%2F12%2FPOJ2096-Collecting-Bugs%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题A.Collecting Bugs（Html Address:http://poj.org/problem?id=2096）题面Ivan is fond of collecting. Unlike other people who collect post stamps,coins or other material stuff, he collects software bugs. When Ivan gets a new program, he classifies all possible bugs into n categories. Each day he discovers exactly one bug in the program and adds information about it and its category into a spreadsheet. When he finds bugs in all bug categories, he calls the program disgusting, publishes this spreadsheet on his home page, and forgets completely about the program. Two companies, Macrosoft and Microhard are in tight competition. Microhard wants to decrease sales of one Macrosoft program. They hire Ivan to prove that the program in question is disgusting. However, Ivan has a complicated problem. This new program has s subcomponents, and finding bugs of all types in each subcomponent would take too long before the target could be reached. So Ivan and Microhard agreed to use a simpler criteria —- Ivan should find at least one bug in each subsystem and at least one bug of each category. Macrosoft knows about these plans and it wants to estimate the time that is required for Ivan to call its program disgusting. It’s important because the company releases a new version soon, so it can correct its plans and release it quicker. Nobody would be interested in Ivan’s opinion about the reliability of the obsolete version. A bug found in the program can be of any category with equal probability. Similarly, the bug can be found in any given subsystem with equal probability. Any particular bug cannot belong to two different categories or happen simultaneously in two different subsystems. The number of bugs in the program is almost infinite, so the probability of finding a new bug of some category in some subsystem does not reduce after finding any number of bugs of that category in that subsystem. Find an average time (in days of Ivan’s work) required to name the program disgusting. 简要翻译一个软件有$s$个子系统，会产生$n$种$bug$。 你每天会发现一个$bug$，这个$bug$属于某个子系统，属于某种$bug$。 每天发现的$bug$，出现在每个子系统中的概率都是$\frac 1s$，属于每种$bug$的概率均为$\frac 1n$。 求找出所有的$n$种$bug$，且每个子系统都找到$bug$所需要的天数的期望。 Input输入两个整数$n,s$。 Output输出期望，保留小数点后四位小数。 Sample Input1 2 Sample Output3.0000 Hint$1&lt;n,s\leq 1,000$ 设$f(i,j)$表示已经找到$i$种$bug$，存在于$j$个子系统中的期望还要多少天。 那么$f(n,s)=0$，$f(0,0)$即为（正义）答案。 状态转移如下： $1.$发现了新$bug$种类，存在于新子系统，$p_1=\frac{n-i}n×\frac{s-j}s$，还需要$f(i+1,j+1)$天。 $2.$发现了新$bug$种类，存在于旧子系统，$p_2=\frac{n-i}n×\frac js$，还需要$f(i+1,j)$天。 $3.$发现了旧$bug$种类，存在于新子系统，$p_3=\frac in×\frac {s-j}s$，还需要$f(i,j+1)$天。 $4.$发现了旧$bug$种类，存在于旧子系统，$p_4=\frac in×\frac js$，还需要$f(i,j)$天。 所以期望的转移方程为： f(i,j)=p_1f(i+1,j+1)+p_2f(i+1,j)+p_3f(i,j+1)+p_4f(i,j)+1移项$f(i,j)$可得： f(i,j)=\frac{p_!f(i+1,j+1)+p_2f(i+1,j)+p_3f(i,j+1)+1}{1-p_4}​时间复杂度为$O(ns)$。 Code123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;int n, s;double f[1010][1010];int main(int argc, char const *argv[])&#123; while(~scanf("%d%d",&amp;n,&amp;s)) &#123; memset(f,0,sizeof(f)); for (int i = n; ~i; --i) for (int j = s; ~j; --j) &#123; if (i == n &amp;&amp; j == s) continue; double p1 = 1.0 * (n - i) / n * (s - j) / s; double p2 = 1.0 * (n - i) / n * j / s; double p3 = 1.0 * i / n * (s - j) / s; double p4 = 1.0 * i / n * j / s; f[i][j] = 1.0 * (p1 * f[i + 1][j + 1] + p2 * f[i + 1][j] + p3 * f[i][j + 1] + 1) / (1.0 - p4); &#125; printf("%.4f\n", f[0][0]); &#125; return 0;&#125; poj有毒啦！ 最后明明应该输出“$\%.4lf$”，结果强行”$\%.4f$”才过。 [○･｀Д´･ ○]！！！]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#301 D.Bad Luck Island]]></title>
    <url>%2F2019%2F02%2F12%2FCodeForces-301-D-Bad-Luck-Island%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题E.Bad Luck Island题面The Bad Luck Island is inhabited by three kinds of species: $r$ rocks, $s$ scissors and $p$ papers. At some moments of time two random individuals meet (all pairs of individuals can meet equiprobably), and if they belong to different species, then one individual kills the other one: a rock kills scissors,scissors kill paper, and paper kills a rock. Your task is to determine for each species what is the probability that this species will be the only one to inhabit this island after a long enough period of time. 简要题意在一个岛上，有 $𝑟 + 𝑠 + 𝑝$ 个人，其中有$𝑟$个人有石头，$𝑠$个人有剪刀，$𝑝$个人有布。 遵循石头剪刀布的原则，输的人就狗带了。每两个人遇到概率的相等。求每个人存活的概率。 显然有同种东西的人存活概率相等，你只需要输出有石头，剪刀，布的人的存活概率即可。 Input一行包括三个整数 $r,s,p$ ，如题意所示分别代表石头，剪刀，布。 Output输出三个实数，由空格隔开，分别代表石头，剪刀，布存活的概率，如果输出与答案的误差不超过$10^{-9}​$，则认为答案正确。 Sample Input 12 2 2 Sample Output 10.333333333333 0.333333333333 0.333333333333 Sample Input 22 1 2 Sample Output 20.150000000000 0.300000000000 0.550000000000 Sample Input 31 1 3 Sample Output 30.057142857143 0.657142857143 0.285714285714 Hint$1\leq r,s,p\leq100​$ 不解释了吧？ 一道期望$dp$，设$f[i][j][k]$，$i$为出石头的人，$j$为出剪刀的人，$k$为出布的人，组合一波即可。 初始状态为$f[r][s][p]=1$，转移方程见代码吧，基本相同。 Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 110;int r, s, p;double f[N][N][N], A1, A2, A3;long long calc(int x, int y, int z)&#123; return max(((x + y + z) * (x + y + z - 1) - x * (x - 1) - y * (y - 1) - z * (z - 1)) &gt;&gt; 1, 1);&#125;int main()&#123; r = read(), s = read(), p = read(); f[r][s][p] = 1; for (int i = r; ~i; --i) for (int j = s; ~j; --j) for (int k = p; ~k; --k) &#123; if (!i &amp;&amp; !j &amp;&amp; !k) continue; if (i == r &amp;&amp; j == s &amp;&amp; k == p) continue; f[i][j][k] += f[i + 1][j][k] * (1.0 * (i + 1) * k / calc(i + 1, j, k)); f[i][j][k] += f[i][j + 1][k] * (1.0 * (j + 1) * i / calc(i, j + 1, k)); f[i][j][k] += f[i][j][k + 1] * (1.0 * (k + 1) * j / calc(i, j, k + 1)); &#125; for (int i = 1; i &lt;= r; ++i) A1 += f[i][0][0]; for (int i = 1; i &lt;= s; ++i) A2 += f[0][i][0]; for (int i = 1; i &lt;= p; ++i) A3 += f[0][0][i]; printf("%.11lf %.11lf %.11lf", A1, A2, A3); return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu P1654 OSU!]]></title>
    <url>%2F2019%2F02%2F12%2Fluogu-P1654-OSU%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题D.OSU!题面 osu 是一款群众喜闻乐见的休闲软件。 我们可以把osu的规则简化与改编成以下的样子: 一共有n次操作，每次操作只有成功与失败之分，成功对应1，失败对应0，n次操作对应为1个长度为n的01串。在这个串中连续的 X个1可以贡献X^3 的分数，这x个1不能被其他连续的1所包含（也就是极长的一串1，具体见样例解释） 现在给出n，以及每个操作的成功率，请你输出期望分数，输出四舍五入后保留1位小数 Input 第一行有一个正整数n,表示操作个数。接下去n行每行有一个[0,1]之间的实数，表示每个操作的成功率。 Output 只有一个实数，表示答案。答案四舍五入后保留1位小数。 Sample Input30.50.50.5 Sample Output6.0 Hint 000分数为0，001分数为1，010分数为1，100分数为1，101分数为2，110分数为8，011分数为8，111分数为27，总和为48，期望为48/8=6.0 $N\leq 10^5$ 学习$luogu$上$hall_of_history$大佬简洁的题解。 首先，学过数学的幼儿园毕业生都知道$(x+1)^3=x^3+3x^2+3x+1​$ 每多增加一个1，则答案就变为原先的$(x+1)^3=x^3+3x^2+3x+1$， 也就是比原先多了$(x+1)^3-x^3=3x^2+3x+1$。 维护这个增加的期望，维护$x_1[i]$表示$x$的期望，维护$x_2[i]$表示$x^2$的期望。 则有$x_1[i]=(x_1[i-1]+1)×p[i]$，$x_2[i]=(x_2[i-1]+2×x_1[i-1]+1)×p[i]$。 所以有： $Ans[i]=Ans[i-1]+(3×x_2[i-1]+3×x_1[i-1]+1)×p[i]$。 我们求$Ans[n]$即可。 Code1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;long long read()&#123; long long x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e5 + 10;double p[N], x1[N], x2[N], Ans[N];long long n;int main()&#123; n = read(); for (int i = 1; i &lt;= n; ++i) scanf("%lf", &amp;p[i]); for (int i = 1; i &lt;= n; ++i) &#123; x1[i] = (x1[i - 1] + 1) * p[i]; x2[i] = (x2[i - 1] + 2 * x1[i - 1] + 1) * p[i]; Ans[i] = Ans[i - 1] + (3 * x2[i - 1] + 3 * x1[i - 1] + 1) * p[i]; &#125; printf("%.1lf", Ans[n]); return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6390 GUGUFISHTION]]></title>
    <url>%2F2019%2F02%2F11%2FHDU-6390-GUGUFISHTION%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题A.GUGUFISHTION题面给出$m,n,p$，求：$\sum_{a=1}^m\sum_{b=1}^n\frac {\phi(ab)}{\phi(a)\phi(b)}\ mod\ \ p$ Input第一行一个$T$代表组数。 之后的$T$行，每行包含三个整数$m,n,p$。 数据保证$p$是一个质数。 Output输出$T​$行，每行只有一个整数表示答案。 Sample Input1 5 7 23 Sample Output2 Hint$1\leq T \leq 3​$ $1\leq m,n\leq1,000,000$ $max(m,n)&lt; p \leq 10^9+7​$ 由欧拉函数的性质$\phi(p^k)=(p-1)×p^{k-1}(p为质数)$。 令$d=gcd(a,b)=p_1^{k_1}×p_2^{k_2}×…×p_n^{k_n}​$。 $G_u(a,b)=\frac {\phi(a,b)}{\phi(a)\phi(b)}=\frac{\phi(p_1^{2k_1}×p_2^{2k_2}×…×p_n^{2k_n})}{\phi(p_1^{k_1}×p_2^{k_2}×…×p_n^{k_n})^2}$ 由于欧拉函数为积性函数，且因为各项上下互质，展开约去。 $G_u(a,b)=\frac {(p_1-1)×(p_2-1)×(p_3-1)×…×(p_n-1)×p_1^{2k_1-1}×p_2^{2k_2-1}×…×p_n^{2k_n-1}}{(p_1-$1)^2×(p_2-1)^2×(p_3-1)^2×…×(p_n-1)^2×p_1^{k_1-1}×p_2^{k_2-1}×…×p_n^{k_n-1}}​$ $=\frac {p_1×p_2×p_3×…×p_n}{(p_1-1)×(p_2-1)×…×(p_n-1)}=\frac {p_1×p_2×p_3×…×p_n×p_1^{k_1-1}×p_2^{k_2-1}×…×p_n^{k_n-1}}{(p_1-1)×(p_2-1)×(p_3-1)×…×(p_n-1)×p_1^{k_1-1}×p_2^{k_2-2}×…×p_n^{k_n-1}}​$ $=\frac {p_1^{k_1}×p_2^{k_2}×…×p_n^{k_n}}{\phi(p_1^{k_1}×p_2^{k_2}×…×p_n^{k_n})}=\frac {d}{\phi{d}}​$ 令$a[i]=\frac i{\phi(i)}​$，$f(m,n)=\sum_{a=1}^m\sum_{b=1}^nG_u(a,b)=\sum_{a=1}^m\sum_{b=1}^na×d​$ $f(m,n)=\sum_{d=1}^{min(m,n)}\sum_{a=1}^m\sum_{b=1}^na[t]×[d==t]=\sum_{d=1}^{min(m,n)}\sum_{a=1}^{\lfloor \frac mt\rfloor}\sum_{b=1}^{\lfloor \frac nt\rfloor}a[t]×[d==1]$ $[到此处d的定义取消，懒得修改，写完发现不对了]​$╮(╯▽╰)╭ 令$g(m,n)=\sum_{a=1}^m\sum_{b=1}^n[d==1]=\sum_{a=1}^m\sum_{b=1}^n\sum_{d|gcd(a,b)}\mu(d)=\sum_{d=1}^{min(a,b)}\mu(d)×\frac md×\frac nd$ 因为有： $\sum_{d|n}\mu(d)=1\ \ (n==1)$ $\sum_{d|n}\mu(d)=0\ \ (n&gt;1)$ 当$gcd(a,b)==1$，则$\sum_{d|gcd(a,b)}\mu(d)=1$； 当$gcd(a,b)\ !\ =1​$，则$\sum_{d|gcd(a,b)}\mu(d)=0，=[gcd(a,b)==1]​$。 因为$\frac md$表示在$a∈[1,m]$中能被$d$整除的数的个数，$\frac nd$表示在$b∈[1,n]$中能被$d$整除的数的个数。 所以，可证等价。 所以有$f(m,n)=\sum_{d=1}^{min(m,n)}a[t]×(\sum_{a=1}^{\lfloor \frac mt\rfloor}\sum_{b=1}^{\lfloor \frac nt\rfloor}[d==1])=\sum_{d=1}^{min(m,n)}a[t]×g(\frac mt,\frac nt)$。 时间复杂度$\frac n1+\frac n2+\frac n3+\frac n4+…+\frac n{n-1}+\frac nn=nln(n)+C（C为欧拉函数）$ 没想平均时间复杂度为$O(ln(n))​$，所以总时间复杂度为$O(nln(n))​$。 CODE：因为总有$\phi(i)&lt;i$，预处理出$max(m,n)​$个逆元即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;long long read()&#123; long long x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e6 + 10;bool notprime[N];int mu[N], p[N], cnt;long long m, n, mod;long long phi[N], a[N], inv[N];void Prime()&#123; phi[1] = mu[1] = 1; notprime[1] = 1; for (int i = 2; i &lt;= 1000000; ++i) &#123; if (!notprime[i]) &#123; p[++cnt] = i; phi[i] = i - 1; mu[i] = -1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= 1000000; ++j) &#123; notprime[i * p[j]] = 1; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; else &#123; phi[i * p[j]] = phi[i] * (p[j] - 1); mu[i * p[j]] = -mu[i]; &#125; &#125; &#125;&#125;void inv_work(int lim)&#123; inv[1] = 1; for (int i = 2; i &lt;= lim; ++i) inv[i] = inv[mod % i] * (mod - mod / i) % mod; for (int i = 1; i &lt;= lim; ++i) a[i] = inv[phi[i]] * i % mod;&#125;int main()&#123; int T = read(); Prime(); while (T--) &#123; m = read(), n = read(), mod = read(); int lim = min(m, n); inv_work(lim); long long result = 0; for (int i = 1; i &lt;= lim; ++i) &#123; int pp = m / i, qq = n / i; long long t = 0; for (int j = 1; j &lt;= min(pp, qq); ++j) (t += 1ll * mu[j] * (pp / j) * (qq / j) + mod) %= mod; (result += a[i] * t % mod) %= mod; &#125; cout &lt;&lt; result &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4804 欧拉心算]]></title>
    <url>%2F2019%2F02%2F11%2Fbzoj-4804-%E6%AC%A7%E6%8B%89%E5%BF%83%E7%AE%97%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题C.欧拉心算题面给出一个数字N，求$\sum_{i=1}^n\sum_{j=1}^n\phi(gcd(i,j))$。 Input 第一行为一个正整数$T$，表示数据组数。 接下来$T$行为询问，每行包含一个正整数$N$。 Output 按读入顺序输出答案。 Sample Input1 10 Sample Output 136 Hint $T\leq5000,N\leq10^7$ 解析莫比乌斯反演一波可得： Ans=\sum_{i=1}^n\sum_{j=1}^n\phi(gcd(i,j))=\sum_{i=1}^n\phi(i)\sum_{d=1}^{\lfloor\frac ni\rfloor}\mu(d)\lfloor\frac n{id}\rfloor^2令$g(n)=\sum_{d=1}^n\mu(d)\lfloor\frac nd\rfloor^2​$ 因为$\lfloor\frac nd\rfloor-\lfloor\frac {n-1}d\rfloor=1$成立当且仅当$d|n$ 那么$g(n)=g(n-1)+\sum_{d|n}\mu(d)(2\frac {n}d-1)$ 因为$\sum_{d|n}\frac {\mu(d)}d=\frac {\phi(n)}n$ $g(n)=g(n-1)+2\phi(d)-[n==1]​$ 于是有$Ans=\sum_{i=1}^n\phi(i)g(\lfloor\frac ni\rfloor)$ 该算法时间复杂度为$O(T\sqrt N)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e7 + 10;int p[N], cnt, q[5010], T;long long phi[N], g[N];bool notprime[N];void work(int m, long long ans = 0)&#123; for (int i = 1, ne; i &lt;= m; i = ne + 1) &#123; ne = m / (m / i); ans += (phi[ne] - phi[i - 1]) * g[m / i]; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;void Prime()&#123; phi[1] = g[1] = 1, notprime[1] = 1; for (int i = 2; i &lt;= 10000000; ++i) &#123; if (!notprime[i]) &#123; p[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= 10000000; ++j) &#123; notprime[i * p[j]] = 1; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; else phi[i * p[j]] = phi[i] * (p[j] - 1); &#125; g[i] = g[i - 1] + 2 * phi[i]; &#125; for (int i = 2; i &lt;= 10000000; ++i) phi[i] += phi[i - 1];&#125;int main()&#123; T = read(); Prime(); while (T--) work(read()); return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3994/luogu P3327 约数个数和]]></title>
    <url>%2F2019%2F02%2F11%2Fbzoj-3994-luogu-P3327-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题D.约数个数和题面设d(x)为x的约数个数，给定N、M，求 $\sum_{i=1}^{N}\sum_{j=1}^{M}d(i×j)$. Input输入文件包含多组测试数据。 第一行，一个整数T，表示测试数据的组数。 接下来的T行，每行两个整数N、M。 OutputT行，每行一个整数，表示你所求的答案。 Sample Input27 45 6 Sample Output110 121 Hint$1\leq N,M \leq 50,000$ $1\leq T \leq 50,000$ 哎，今天fhj大佬讲课也是很无奈，莫比乌斯反演虽然是学了，但是确实不太会用哇。 公式恐惧症患者一枚…… 第一步​ 首先，我们证明一条结论：d(n×m)=\sum_{i|n}\sum_{j|m}[gcd(i,j)==1] ​ 证明：对于nm每一个质因子$p_i$，我们令$n={p_i}^{a_i}×n_x,m={p_i}^{b_i}×m_x$，则有d(n×m)=\Pi_i(a_i+b_i+1)​，设 $l$ 和 $t$ 互质且不含质因子$p_i$，那么$(l×{p_i}^{a_i},t),(l×{p_i}^{a_i-1})…(l,t)…(l,t×{p_i}^{b_i-1}),(l,t×{p_i}^{b_i})$都是互质的数对，而 $ l$ 和 $ t $ 的取法刚好是$\Pi_{k\neq i}(a_k+b_k+1)$种。 第二步​ 下面是公式恐惧症的“福利”？！ \sum_{i=1}^n\sum_{j=1}^md(i×j)=\sum_{i=1}^n\sum_{j=1}^m\sum_{k|i}\sum_{l|j}[gcd(k,l)==1]​​ 现在我们枚举每一个数对$(k,l)$,那么它们会被算多少遍呢？每一个$k$的倍数都会算一次$k$，每一个$l$的倍数又会算一次$l$,而用$\frac nk$来表示n以内k的倍数有多少个是显然的，所以： \sum_{k=1}^n\sum_{l=1}^m\frac nk×\frac ml[gcd(k,l)==1]​ 然后我们能够用莫比乌斯函数的性质： \sum_{d|n}\mu(d)=1\ (n==1)\sum_{d|n}\mu(d)=0\ (n>1)​ 那我们就可以得到： \sum_{k=1}^n\sum_{l=1}^m\frac nk×\frac ml\sum_{d|gcd(k,l)}\mu(d)​ 如果$gcd(k,l)==1$，此时后面的这些等于1，否则是0。 ​ 我们就能得到： \sum_{k=1}^n\sum_{l=1}^m\frac nk× \frac ml\sum_{d|k且d|l}\mu(d)​ 我们只要枚举$\mu(d)$，显然，我们只要枚举d的倍数来与$\mu(d)$相乘即可。 \sum_{d=1}^{min(n,m)}\mu(d)\sum_{i=1}^\frac nd\sum_{j=1}^\frac md\frac n{d_i}×\frac m{d_j}第三步​ 我们由第二步继续变形可得： \sum_{d=1}^{min(n,m)}\mu(d)×(\sum_{k=1}^{\frac nd}\frac n{dk})×(\sum_{l=1}^{\frac md}\frac m{dl})令$g(x)=\sum_{i=1}^x\frac xi​$ \sum_{d=1}^{min(n,m)}\mu(d)×g(\frac nd)×g(\frac md)我们预处理出$g(x)​$即可。 观察一下$g(x)$，就会发现其实式子可以这么理解：$x$以内有约数i的数的个数和，也就是可看作原题中$d(x)$的前缀和要求$d(x)$的前缀和，可以求出每一个$d(x)$,也就是用线性筛求啦，要记录一下$c(x)$:将$x$分解质因数后，最小质因数的指数。那么参见第一步，x的最小质因数对$d(x)$的贡献为$c(x)+1$。 第四步​ 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;int mu[500010],p[50010],cnt,n,m;long long a[500010],b[500010];bool notprime[500010];void Prime()&#123; mu[1]=a[1]=b[1]=1; for(int i=2;i&lt;=50000;++i) &#123; if(!notprime[i]) &#123; p[++cnt]=i; mu[i]=-1,a[i]=1,b[i]=2; &#125; for(int j=1;j&lt;=cnt&amp;&amp;i*p[j]&lt;=50000;++j) &#123; notprime[i*p[j]]=1; if(i%p[j]==0) &#123; b[i*p[j]]=b[i]/(a[i]+1)*(a[i]+2); a[i*p[j]]=a[i]+1; break; &#125; else &#123; b[i*p[j]]=b[i]*b[p[j]]; a[i*p[j]]=1; mu[i*p[j]]=-mu[i]; &#125; &#125; &#125; for(int i=2;i&lt;=50000;++i) &#123; b[i]+=b[i-1]; mu[i]+=mu[i-1]; &#125;&#125;int main()&#123; int T=read(); Prime(); while(T--) &#123; long long result=0; n=read(),m=read(); if(n&gt;m) swap(n,m); for(int i=1,j;i&lt;=n;i=j+1) &#123; j=min(n/(n/i),m/(m/i)); result+=(mu[j]-mu[i-1])*b[n/i]*b[m/i]; &#125; cout&lt;&lt;result&lt;&lt;endl; &#125; return 0;&#125; p.s.还有很重要的一点，如果初始化用这样a[N]={0,1}，会导致exe文件过大而无法提交，嘤嘤嘤，感谢vhosc巨佬……(/≧▽≦)/]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.5.30 集训总结]]></title>
    <url>%2F2018%2F05%2F30%2F2018-5-30%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~总结： 先从第一天的比赛开始看，其实光从题目来看，我排于第七名的成绩，也就是两道水题和一道比较熟练的BFS给的，后面几题是没有思路的（大佬们太强了啊），被完虐…… 我再从昨天的ACM欢乐赛开始说起————比赛第一个小时，从A题的水题十分钟完成的速度来看，稍稍放宽了心态，然而在B题上竟然栽了跟头。最初在第三个点WA了2遍，再在14点WA了好几遍，最后又卡在了35点。最后心态几乎爆炸（内心OS：这可是一道水题啊），同样，同组的大佬们，也没发现有什么问题。就这样纠结着，最后将一个双重判定换了方向的思维的另一种判定，于是，终于是A了……此时时间已经在两小时之后了（比赛半程刚过）。内心火急火燎得，也不知怎的其他两位大佬，竟然开始换顺序做，半小时过去，VHOS（太强了）竟然完成了G组题，然而不幸的是不能提交（辣鸡日本Vjudge）。这又是对我们心态的考验，于此同时半数以上的组早已经完成了3道了，我们的排名位置几乎已经可以看到榜底了。终于在最后的第三个小时————奇迹竟然出现了！三小时十分钟！C题！！AC！！三小时三十分！G题！！AC！！此时我们的排名已经挤到了前十，4道AC，最多的大神组早完成了5题，我心有不甘，继续奋战，此时只剩唯我一人奋笔疾书……周围的人早已懈怠，不，还不能那么早。努力的想着D题，dp方程却死也推不出来，最后十五分钟……！！！哦！！！突然有了想法，夺过键盘，最后13分钟！！！我知道这次我没有调试的时间了，只能要求自己一遍过，每个字都敲得小心翼翼，同时又得加快速度…………3min！2min！！敲完了！！！样例一过，直接提交，不敢浪费每一分钟！！！竟然成功AC了！！！！！同组的大佬高兴的欢呼！！我做到了！！！当自己平静下来时，我才发现自己的身体一直在颤抖，心跳十分的快。最后我们虽然罚时很久，但是最终也以唯一AC 6道的好成绩位居了榜首，十分不易啊！！ （P.S:最后从岳神和刘大佬的钱包里成功坑到一顿KFC）o(●ˇ∀ˇ●)o 下面是对这几天所学内容的总结，逐条枚举：（其实很多口胡一波，并不能上手当场码题） 1、$KMP$ （俗称“看*片算法”） （一%飞神）这是由三位大神同时发现的一种改进字符串匹配的算法（%%%），$KMP$算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个$next()$函数，函数本身包含了模式串的局部匹配信息。（强行解释一波失配函数）上波代码： 1234567891011121314151617181920int KMP(string W,string T)&#123; int i=1,j=1; while(i&lt;=n)&#123; while (j!=0&amp;&amp;W[j]!=T[i]) j=next[j]; if(j==m) return i-m+1;//匹配成功，返回匹配位置s else&#123;j++; i++;&#125; &#125; return -1;//匹配失败&#125;void GetNext(charT[],intnext[])&#123; next[1]=0; j=1;k=0; while(j&lt;T[0]) if((k==0)||(T[j]==T[k]))&#123; j++; k++; next[j]=k; &#125; else k=next[k];&#125; （其实并不太清楚它到底具体有什么用）=v= 2、数论、定理 （一堆奇奇怪怪的东西）（边打边复习）首先上场的是唯一分解和$lcm$、$gcd$（这货贼重要），由此引申的是欧几里得和扩展欧。 //威尔逊定理//：它给出了判定一个自然数是否为素数的充分必要条件，就是当且仅当$p$为素数时：$(p-1)!≡-1(mod p)$，但是由于阶乘是增长的速度实在是…………（所以结论对于实际操作意义不大，感觉说了废话） //小费马//：假如$p$是质数，且$gcd(a,p)=1$，那么$a(p-1)≡1(mod\ p)$（强制使用了一波$gcd$）（其中$gcd$为$1$代表互质）（结果证明出来了）（该同余式可以转为$ap≡p(mod\ p)$，不知道写的对不对，好像提到过） //欧拉函数与定理//：emmm，这玩意我实在不是很懂,认识了一下$φ$，还有欧拉定理：若$gcd(a,p)=1$，则$a^{φ(p)}≡1(mod\ p)$。 //关于这些定理的例题使用//：不太熟练，不献丑=w=，学习大神们的写法，费力的理解啊啊啊………… 3、$manacher$ （二%飞神）这个和$KMP$一样，是关于字符串的一种算法，主要针对回文串。以$O（n）$的时间复杂度以每个字符为中心，以回文串单程长度，将所取字符串扩展一倍。如果是奇数串就能顺利进行，如果偶数串，那必须插入奇怪的字符。但这种算法的神奇之处在于可以同时考虑奇串和偶串。（但不能拆坏原字符串）（代码好长，我决定不凑字数）(￣▽￣)” 4、状压$DP$好吧，我承认位运算我实在是烂透了，完全没记住，差点听成大弱智╮(╯-╰)╭ 。表示状压列举的子集既能完全枚举，还能节约不必要列举的时间……（来自萌新的神奇(⊙o⊙)） 5、树的$LCA$ （求树两点之间的最短路）先从树的$dfs$序入手，展开倍增（看得懂，表示不会写……），$tarjan$（竟然基于冰茶几（并查集）！！），$RMQ$，$emmm$（回去重新学习连通分量）。（不好随便口胡=-=，决定翻工学习） 6、差分 （一起讲了差分约束吧）差分所擅长做的就是把$a$数组中$l~r$范围内的数加上或减去某个$k$值，这样只要求前缀和，运用差分就只要求前缀和，就能在$O（n）$的时间内得到整个数组的值。差分约束嘛，是基于图论知识$SPFA$和判环的，比如我们得到$a[x]]]></content>
      <categories>
        <category>5/6月集训</category>
      </categories>
      <tags>
        <tag>Total Review</tag>
      </tags>
  </entry>
</search>
