<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[蒟蒻⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄报道 (置顶)(置顶)]]></title>
    <url>%2F2099%2F12%2F31%2F%E8%92%9F%E8%92%BB%E6%8A%A5%E9%81%93%2F</url>
    <content type="text"><![CDATA[这篇文章的出现，预示着时隔多年，我的博客终于要启用啦！撒花花]]></content>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[image]]></title>
    <url>%2F2019%2F02%2F14%2Fimage%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Photo Collection</category>
      </categories>
      <tags>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚁群算法(Ant Colony)]]></title>
    <url>%2F2019%2F02%2F14%2F%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天，我在网上翻到一个神奇的算法蚁群算法！某大佬的blog：https://blog.csdn.net/lyxleft/article/details/82980760 记得学哈~]]></content>
      <categories>
        <category>空闲时间的零碎知识</category>
      </categories>
      <tags>
        <tag>Spare-time&#39;s Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1848 Fibonacci again and again]]></title>
    <url>%2F2019%2F02%2F13%2FHDU-1848-Fibonacci-again-and-again%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题#.Fibonacci again and again题面 任何一个大学生对菲波那契数列($Fibonacci numbers$)应该都不会陌生，它是这样定义的：$F(1)=1;$$F(2)=2;$$F(n)=F(n-1)+F(n-2)(n&gt;=3);$所以，$1,2,3,5,8,13$……就是菲波那契数列。在HDOJ上有不少相关的题目，比如$1005\ Fibonacci\ again\ and\ again$就是曾经的浙江省赛题。今天，又一个关于$Fibonacci$的题目出现了，它是一个小游戏，定义如下：1、 这是一个二人游戏;2、 一共有$3$堆石子，数量分别是$m, n, p$个；3、 两人轮流走;4、 每走一步可以选择任意一堆石子，然后取走$f$个；5、 $f$只能是菲波那契数列中的元素（即每次只能取$\ 1，2，3，5，8$…等数量）；6、 最先取光所有石子的人为胜者； 假设双方都使用最优策略，请判断先手的人会赢还是后手的人会赢。 Input输入数据包含多个测试用例，每个测试用例占一行，包含$3​$个整数$m,n,p​$。$m=n=p=0​$则表示输入结束。 Output 如果先手的人能赢，请输出“$Fibo$”，否则请输出“$Nacci$”，每个实例的输出占一行。 Sample Input1 1 1 1 4 1 0 0 0 Sample OutputFibo Nacci Hint$1\leq m,n,p\leq 1,000$ 来自$ACM\ Short\ Term\ Exam\ 2007/12/13$ (Html Address:http://acm.hdu.edu.cn/search.php?field=problem&amp;key=ACM+Short+Term+Exam_2007%2F12%2F13&amp;source=1&amp;searchmode=source) 这题啊！ 裸的SG函数呀！ 没学过的大佬们逛一波博客吧！ （maybe…几万年以后我也会写一篇的吧~） Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x=0,w=0; char ch=0; while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return w? -x:x;&#125;const int MAXN=1010;int f[MAXN],sg[MAXN];void Fibonacci()&#123; f[1]=1,f[2]=2; for(int i=3;i&lt;=200;++i) &#123; f[i]=f[i-1]+f[i-2]; if(f[i]&gt;1000) break; &#125;&#125;map&lt;int,int&gt; ma;void Build_Map(int lim)&#123; for(int i=1;i&lt;=lim;++i) &#123; ma.clear(); for(int j=1;f[j]&lt;=i;++j) ++ma[sg[i-f[j]]]; for(int j=0;j&lt;=lim;++j) if(!ma[j]) &#123; sg[i]=j; break; &#125; &#125;&#125;int a,b,c;int main()&#123; Fibonacci(); Build_Map(1000); while(1) &#123; a=read(),b=read(),c=read(); if(!a&amp;&amp;!b&amp;&amp;!c) return 0; int sum=0; sum^=sg[a]^sg[b]^sg[c]; if(!sum) puts("Nacci"); else puts("Fibo"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.13-Contest]]></title>
    <url>%2F2019%2F02%2F13%2F2-13-Contest%2F</url>
    <content type="text"><![CDATA[本蒟蒻较懒，想直接贴pdf的图片。 于是下载了一个转化器，结果最后一张还带了水印。 (能看就行)]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ2640 Help Me Escape]]></title>
    <url>%2F2019%2F02%2F12%2FHelp-Me-Excape%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题B.Help Me Escape背景If thou doest well, shalt thou not be accepted? and if thou doest not well, sin lieth at the door. And unto thee shall be his desire, and thou shalt rule over him. And Cain talked with Abel his brother: and it came to pass, when they were in the field, that Cain rose up against Abel his brother, and slew him. And the LORD said unto Cain, Where is Abel thy brother? And he said, I know not: Am I my brother’s keeper? And he said, What hast thou done? the voice of thy brother’s blood crieth unto me from the ground. And now art thou cursed from the earth, which hath opened her mouth to receive thy brother’s blood from thy hand; When thou tillest the ground, it shall not henceforth yield unto thee her strength; a fugitive and a vagabond shalt thou be in the earth. ​ $ —— Bible Chapter 4$ 题面 Now Cain is unexpectedly trapped in a cave with N paths. Due to LORD’s punishment, all the paths are zigzag and dangerous. The difficulty of the ith path is ci. Then we define f as the fighting capacity of Cain. Every day, Cain will be sent to one of the N paths randomly. Suppose Cain is in front of the ith path. He can successfully take ti days to escape from the cave as long as his fighting capacity f is larger than ci. Otherwise, he has to keep trying day after day. However, if Cain failed to escape, his fighting capacity would increase ci as the result of actual combat. (A kindly reminder: Cain will never died.) As for ti, we can easily draw a conclusion that ti is closely related to ci. Let’s use the following function to describe their relationship: t_i=\lfloor \frac{1+\sqrt 5}2×c_i^2\rfloor After D days, Cain finally escapes from the cave. Please output the expectation of D. 简要翻译有$n$个妖怪，每个妖怪有一个战斗力$c_j$。小A有一个初始战斗力$f_0$。 每天，小A随机选择一个妖怪决斗。设小A在第𝑖天的战斗力为$f_i$。 设当前为第$𝑖$天，如果打赢，即$𝑓_i &gt; 𝑐_j$，就可以逃出去，需要花$t_j$天。 如果打不赢，小A会让自己变强，$𝑓_{i+1} = 𝑓_i+ 𝑐_j$。 求小A逃出来需要的期望天数。 Input输入包含多组数据。 每组数据包括两行。第一行包含一个$n$和$f$，第二行包含$n$个整数$c_i$。 Output对于每组数据你要输出期望值，保留小数点后三位。 Sample Input3 1 1 2 3 Sample Output6.889 Hint$n\leq 100$，$f\leq 10,000$，$c_i\leq10,000，1\leq i\leq n$。 用$f(i)$表示战斗力为$i$时，所需要的期望天数。 那么有：若$i&gt;c_j$，则$f(i)=f(i)+\frac 1n(t_j)$； 若（$i\leq c_j$），则$f(i)=f(i)+\frac 1n(f(i+c_j)+1)$。 然后进行记忆化搜索。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;struct data&#123; int c, t;&#125;;bool vis[100010];vector&lt;data&gt; vs;int N, F;double dp[100010];double dfs(int f)&#123; if (vis[f]) return dp[f]; vis[f] = 1; double A = 0; for (int i = 0; i &lt; N; ++i) if (vs[i].c &gt;= f) A += (1 + dfs(f + vs[i].c)) / N; else A += 1.0 * vs[i].t / N; return dp[f] = A;&#125;int main()&#123; while (~scanf("%d%d", &amp;N, &amp;F)) &#123; vs.clear(); memset(vis, 0, sizeof(vis)); for (int i = 0, g; i &lt; N; ++i) &#123; g = read(); int p = (1 + sqrt(5)) / 2 * g * g; vs.push_back((data) &#123;g, p&#125;); &#125; printf("%.3lf\n", dfs(F)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2096 Collecting Bugs]]></title>
    <url>%2F2019%2F02%2F12%2Fcollecting-bugs%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题A.Collecting Bugs（Html Address:http://poj.org/problem?id=2096）题面Ivan is fond of collecting. Unlike other people who collect post stamps,coins or other material stuff, he collects software bugs. When Ivan gets a new program, he classifies all possible bugs into n categories. Each day he discovers exactly one bug in the program and adds information about it and its category into a spreadsheet. When he finds bugs in all bug categories, he calls the program disgusting, publishes this spreadsheet on his home page, and forgets completely about the program. Two companies, Macrosoft and Microhard are in tight competition. Microhard wants to decrease sales of one Macrosoft program. They hire Ivan to prove that the program in question is disgusting. However, Ivan has a complicated problem. This new program has s subcomponents, and finding bugs of all types in each subcomponent would take too long before the target could be reached. So Ivan and Microhard agreed to use a simpler criteria —- Ivan should find at least one bug in each subsystem and at least one bug of each category. Macrosoft knows about these plans and it wants to estimate the time that is required for Ivan to call its program disgusting. It’s important because the company releases a new version soon, so it can correct its plans and release it quicker. Nobody would be interested in Ivan’s opinion about the reliability of the obsolete version. A bug found in the program can be of any category with equal probability. Similarly, the bug can be found in any given subsystem with equal probability. Any particular bug cannot belong to two different categories or happen simultaneously in two different subsystems. The number of bugs in the program is almost infinite, so the probability of finding a new bug of some category in some subsystem does not reduce after finding any number of bugs of that category in that subsystem. Find an average time (in days of Ivan’s work) required to name the program disgusting. 简要翻译一个软件有$s$个子系统，会产生$n$种$bug$。 你每天会发现一个$bug$，这个$bug$属于某个子系统，属于某种$bug$。 每天发现的$bug$，出现在每个子系统中的概率都是$\frac 1s$，属于每种$bug$的概率均为$\frac 1n$。 求找出所有的$n$种$bug$，且每个子系统都找到$bug$所需要的天数的期望。 Input输入两个整数$n,s$。 Output输出期望，保留小数点后四位小数。 Sample Input1 2 Sample Output3.0000 Hint$1&lt;n,s\leq 1,000$ 设$f(i,j)$表示已经找到$i$种$bug$，存在于$j$个子系统中的期望还要多少天。 那么$f(n,s)=0$，$f(0,0)$即为（正义）答案。 状态转移如下： $1.$发现了新$bug$种类，存在于新子系统，$p_1=\frac{n-i}n×\frac{s-j}s$，还需要$f(i+1,j+1)$天。 $2.$发现了新$bug$种类，存在于旧子系统，$p_2=\frac{n-i}n×\frac js$，还需要$f(i+1,j)$天。 $3.$发现了旧$bug$种类，存在于新子系统，$p_3=\frac in×\frac {s-j}s$，还需要$f(i,j+1)$天。 $4.$发现了旧$bug$种类，存在于旧子系统，$p_4=\frac in×\frac js$，还需要$f(i,j)$天。 所以期望的转移方程为： f(i,j)=p_1f(i+1,j+1)+p_2f(i+1,j)+p_3f(i,j+1)+p_4f(i,j)+1移项$f(i,j)$可得： f(i,j)=\frac{p_!f(i+1,j+1)+p_2f(i+1,j)+p_3f(i,j+1)+1}{1-p_4}​时间复杂度为$O(ns)$。 Code123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;int n, s;double f[1010][1010];int main(int argc, char const *argv[])&#123; while(~scanf("%d%d",&amp;n,&amp;s)) &#123; memset(f,0,sizeof(f)); for (int i = n; ~i; --i) for (int j = s; ~j; --j) &#123; if (i == n &amp;&amp; j == s) continue; double p1 = 1.0 * (n - i) / n * (s - j) / s; double p2 = 1.0 * (n - i) / n * j / s; double p3 = 1.0 * i / n * (s - j) / s; double p4 = 1.0 * i / n * j / s; f[i][j] = 1.0 * (p1 * f[i + 1][j + 1] + p2 * f[i + 1][j] + p3 * f[i][j + 1] + 1) / (1.0 - p4); &#125; printf("%.4f\n", f[0][0]); &#125; return 0;&#125; poj有毒啦！ 最后明明应该输出“$\%.4lf$”，结果强行”$\%.4f$”才过。 [○･｀Д´･ ○]！！！]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces#301 D.Bad Luck Island]]></title>
    <url>%2F2019%2F02%2F12%2FBad-Luck-Island%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题E.Bad Luck Island题面The Bad Luck Island is inhabited by three kinds of species: $r$ rocks, $s$ scissors and $p$ papers. At some moments of time two random individuals meet (all pairs of individuals can meet equiprobably), and if they belong to different species, then one individual kills the other one: a rock kills scissors,scissors kill paper, and paper kills a rock. Your task is to determine for each species what is the probability that this species will be the only one to inhabit this island after a long enough period of time. 简要题意在一个岛上，有 $𝑟 + 𝑠 + 𝑝$ 个人，其中有$𝑟$个人有石头，$𝑠$个人有剪刀，$𝑝$个人有布。 遵循石头剪刀布的原则，输的人就狗带了。每两个人遇到概率的相等。求每个人存活的概率。 显然有同种东西的人存活概率相等，你只需要输出有石头，剪刀，布的人的存活概率即可。 Input一行包括三个整数 $r,s,p$ ，如题意所示分别代表石头，剪刀，布。 Output输出三个实数，由空格隔开，分别代表石头，剪刀，布存活的概率，如果输出与答案的误差不超过$10^{-9}​$，则认为答案正确。 Sample Input 12 2 2 Sample Output 10.333333333333 0.333333333333 0.333333333333 Sample Input 22 1 2 Sample Output 20.150000000000 0.300000000000 0.550000000000 Sample Input 31 1 3 Sample Output 30.057142857143 0.657142857143 0.285714285714 Hint$1\leq r,s,p\leq100​$ 不解释了吧？ 一道期望$dp$，设$f[i][j][k]$，$i$为出石头的人，$j$为出剪刀的人，$k$为出布的人，组合一波即可。 初始状态为$f[r][s][p]=1$，转移方程见代码吧，基本相同。 Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 110;int r, s, p;double f[N][N][N], A1, A2, A3;long long calc(int x, int y, int z)&#123; return max(((x + y + z) * (x + y + z - 1) - x * (x - 1) - y * (y - 1) - z * (z - 1)) &gt;&gt; 1, 1);&#125;int main()&#123; r = read(), s = read(), p = read(); f[r][s][p] = 1; for (int i = r; ~i; --i) for (int j = s; ~j; --j) for (int k = p; ~k; --k) &#123; if (!i &amp;&amp; !j &amp;&amp; !k) continue; if (i == r &amp;&amp; j == s &amp;&amp; k == p) continue; f[i][j][k] += f[i + 1][j][k] * (1.0 * (i + 1) * k / calc(i + 1, j, k)); f[i][j][k] += f[i][j + 1][k] * (1.0 * (j + 1) * i / calc(i, j + 1, k)); f[i][j][k] += f[i][j][k + 1] * (1.0 * (k + 1) * j / calc(i, j, k + 1)); &#125; for (int i = 1; i &lt;= r; ++i) A1 += f[i][0][0]; for (int i = 1; i &lt;= s; ++i) A2 += f[0][i][0]; for (int i = 1; i &lt;= p; ++i) A3 += f[0][0][i]; printf("%.11lf %.11lf %.11lf", A1, A2, A3); return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguP1654 OSU!]]></title>
    <url>%2F2019%2F02%2F12%2FOSU%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题D.OSU!题面 osu 是一款群众喜闻乐见的休闲软件。 我们可以把osu的规则简化与改编成以下的样子: 一共有n次操作，每次操作只有成功与失败之分，成功对应1，失败对应0，n次操作对应为1个长度为n的01串。在这个串中连续的 X个1可以贡献X^3 的分数，这x个1不能被其他连续的1所包含（也就是极长的一串1，具体见样例解释） 现在给出n，以及每个操作的成功率，请你输出期望分数，输出四舍五入后保留1位小数 Input 第一行有一个正整数n,表示操作个数。接下去n行每行有一个[0,1]之间的实数，表示每个操作的成功率。 Output 只有一个实数，表示答案。答案四舍五入后保留1位小数。 Sample Input30.50.50.5 Sample Output6.0 Hint 000分数为0，001分数为1，010分数为1，100分数为1，101分数为2，110分数为8，011分数为8，111分数为27，总和为48，期望为48/8=6.0 $N\leq 10^5$ 学习$luogu$上$hall_of_history$大佬简洁的题解。 首先，学过数学的幼儿园毕业生都知道$(x+1)^3=x^3+3x^2+3x+1​$ 每多增加一个1，则答案就变为原先的$(x+1)^3=x^3+3x^2+3x+1$， 也就是比原先多了$(x+1)^3-x^3=3x^2+3x+1$。 维护这个增加的期望，维护$x_1[i]$表示$x$的期望，维护$x_2[i]$表示$x^2$的期望。 则有$x_1[i]=(x_1[i-1]+1)×p[i]$，$x_2[i]=(x_2[i-1]+2×x_1[i-1]+1)×p[i]$。 所以有： $Ans[i]=Ans[i-1]+(3×x_2[i-1]+3×x_1[i-1]+1)×p[i]$。 我们求$Ans[n]$即可。 Code1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;long long read()&#123; long long x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e5 + 10;double p[N], x1[N], x2[N], Ans[N];long long n;int main()&#123; n = read(); for (int i = 1; i &lt;= n; ++i) scanf("%lf", &amp;p[i]); for (int i = 1; i &lt;= n; ++i) &#123; x1[i] = (x1[i - 1] + 1) * p[i]; x2[i] = (x2[i - 1] + 2 * x1[i - 1] + 1) * p[i]; Ans[i] = Ans[i - 1] + (3 * x2[i - 1] + 3 * x1[i - 1] + 1) * p[i]; &#125; printf("%.1lf", Ans[n]); return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 6390 GUGUFISHTION]]></title>
    <url>%2F2019%2F02%2F11%2FGUGUFISHTION%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题A.GUGUFISHTION题面给出$m,n,p$，求：$\sum_{a=1}^m\sum_{b=1}^n\frac {\phi(ab)}{\phi(a)\phi(b)}\ mod\ \ p$ Input第一行一个$T$代表组数。 之后的$T$行，每行包含三个整数$m,n,p$。 数据保证$p$是一个质数。 Output输出$T​$行，每行只有一个整数表示答案。 Sample Input1 5 7 23 Sample Output2 Hint$1\leq T \leq 3​$ $1\leq m,n\leq1,000,000$ $max(m,n)&lt; p \leq 10^9+7​$ 由欧拉函数的性质$\phi(p^k)=(p-1)×p^{k-1}(p为质数)$。 令$d=gcd(a,b)=p_1^{k_1}×p_2^{k_2}×…×p_n^{k_n}​$。 $G_u(a,b)=\frac {\phi(a,b)}{\phi(a)\phi(b)}=\frac{\phi(p_1^{2k_1}×p_2^{2k_2}×…×p_n^{2k_n})}{\phi(p_1^{k_1}×p_2^{k_2}×…×p_n^{k_n})^2}$ 由于欧拉函数为积性函数，且因为各项上下互质，展开约去。 $G_u(a,b)=\frac {(p_1-1)×(p_2-1)×(p_3-1)×…×(p_n-1)×p_1^{2k_1-1}×p_2^{2k_2-1}×…×p_n^{2k_n-1}}{(p_1-$1)^2×(p_2-1)^2×(p_3-1)^2×…×(p_n-1)^2×p_1^{k_1-1}×p_2^{k_2-1}×…×p_n^{k_n-1}}​$ $=\frac {p_1×p_2×p_3×…×p_n}{(p_1-1)×(p_2-1)×…×(p_n-1)}=\frac {p_1×p_2×p_3×…×p_n×p_1^{k_1-1}×p_2^{k_2-1}×…×p_n^{k_n-1}}{(p_1-1)×(p_2-1)×(p_3-1)×…×(p_n-1)×p_1^{k_1-1}×p_2^{k_2-2}×…×p_n^{k_n-1}}​$ $=\frac {p_1^{k_1}×p_2^{k_2}×…×p_n^{k_n}}{\phi(p_1^{k_1}×p_2^{k_2}×…×p_n^{k_n})}=\frac {d}{\phi{d}}​$ 令$a[i]=\frac i{\phi(i)}​$，$f(m,n)=\sum_{a=1}^m\sum_{b=1}^nG_u(a,b)=\sum_{a=1}^m\sum_{b=1}^na×d​$ $f(m,n)=\sum_{d=1}^{min(m,n)}\sum_{a=1}^m\sum_{b=1}^na[t]×[d==t]=\sum_{d=1}^{min(m,n)}\sum_{a=1}^{\lfloor \frac mt\rfloor}\sum_{b=1}^{\lfloor \frac nt\rfloor}a[t]×[d==1]$ $[到此处d的定义取消，懒得修改，写完发现不对了]​$╮(╯▽╰)╭ 令$g(m,n)=\sum_{a=1}^m\sum_{b=1}^n[d==1]=\sum_{a=1}^m\sum_{b=1}^n\sum_{d|gcd(a,b)}\mu(d)=\sum_{d=1}^{min(a,b)}\mu(d)×\frac md×\frac nd$ 因为有： $\sum_{d|n}\mu(d)=1\ \ (n==1)$ $\sum_{d|n}\mu(d)=0\ \ (n&gt;1)$ 当$gcd(a,b)==1$，则$\sum_{d|gcd(a,b)}\mu(d)=1$； 当$gcd(a,b)\ !\ =1​$，则$\sum_{d|gcd(a,b)}\mu(d)=0，=[gcd(a,b)==1]​$。 因为$\frac md$表示在$a∈[1,m]$中能被$d$整除的数的个数，$\frac nd$表示在$b∈[1,n]$中能被$d$整除的数的个数。 所以，可证等价。 所以有$f(m,n)=\sum_{d=1}^{min(m,n)}a[t]×(\sum_{a=1}^{\lfloor \frac mt\rfloor}\sum_{b=1}^{\lfloor \frac nt\rfloor}[d==1])=\sum_{d=1}^{min(m,n)}a[t]×g(\frac mt,\frac nt)$。 时间复杂度$\frac n1+\frac n2+\frac n3+\frac n4+…+\frac n{n-1}+\frac nn=nln(n)+C（C为欧拉函数）$ 没想平均时间复杂度为$O(ln(n))​$，所以总时间复杂度为$O(nln(n))​$。 CODE：因为总有$\phi(i)&lt;i$，预处理出$max(m,n)​$个逆元即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;long long read()&#123; long long x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e6 + 10;bool notprime[N];int mu[N], p[N], cnt;long long m, n, mod;long long phi[N], a[N], inv[N];void Prime()&#123; phi[1] = mu[1] = 1; notprime[1] = 1; for (int i = 2; i &lt;= 1000000; ++i) &#123; if (!notprime[i]) &#123; p[++cnt] = i; phi[i] = i - 1; mu[i] = -1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= 1000000; ++j) &#123; notprime[i * p[j]] = 1; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; else &#123; phi[i * p[j]] = phi[i] * (p[j] - 1); mu[i * p[j]] = -mu[i]; &#125; &#125; &#125;&#125;void inv_work(int lim)&#123; inv[1] = 1; for (int i = 2; i &lt;= lim; ++i) inv[i] = inv[mod % i] * (mod - mod / i) % mod; for (int i = 1; i &lt;= lim; ++i) a[i] = inv[phi[i]] * i % mod;&#125;int main()&#123; int T = read(); Prime(); while (T--) &#123; m = read(), n = read(), mod = read(); int lim = min(m, n); inv_work(lim); long long result = 0; for (int i = 1; i &lt;= lim; ++i) &#123; int pp = m / i, qq = n / i; long long t = 0; for (int j = 1; j &lt;= min(pp, qq); ++j) (t += 1ll * mu[j] * (pp / j) * (qq / j) + mod) %= mod; (result += a[i] * t % mod) %= mod; &#125; cout &lt;&lt; result &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4804 欧拉心算]]></title>
    <url>%2F2019%2F02%2F11%2F%E6%AC%A7%E6%8B%89%E5%BF%83%E7%AE%97%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题C.欧拉心算题面给出一个数字N，求$\sum_{i=1}^n\sum_{j=1}^n\phi(gcd(i,j))$。 Input 第一行为一个正整数$T​$，表示数据组数。 接下来$T$行为询问，每行包含一个正整数$N$。 Output 按读入顺序输出答案。 Sample Input1 10 Sample Output 136 Hint $T\leq5000,N\leq10^7$ 解析莫比乌斯反演一波可得： Ans=\sum_{i=1}^n\sum_{j=1}^n\phi(gcd(i,j))=\sum_{i=1}^n\phi(i)\sum_{d=1}^{\lfloor\frac ni\rfloor}\mu(d)\lfloor\frac n{id}\rfloor^2令$g(n)=\sum_{d=1}^n\mu(d)\lfloor\frac nd\rfloor^2​$ 因为$\lfloor\frac nd\rfloor-\lfloor\frac {n-1}d\rfloor=1$成立当且仅当$d|n$ 那么$g(n)=g(n-1)+\sum_{d|n}\mu(d)(2\frac {n}d-1)$ 因为$\sum_{d|n}\frac {\mu(d)}d=\frac {\phi(n)}n$ $g(n)=g(n-1)+2\phi(d)-[n==1]​$ 于是有$Ans=\sum_{i=1}^n\phi(i)g(\lfloor\frac ni\rfloor)$ 该算法时间复杂度为$O(T\sqrt N)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;const int N = 1e7 + 10;int p[N], cnt, q[5010], T;long long phi[N], g[N];bool notprime[N];void work(int m, long long ans = 0)&#123; for (int i = 1, ne; i &lt;= m; i = ne + 1) &#123; ne = m / (m / i); ans += (phi[ne] - phi[i - 1]) * g[m / i]; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;void Prime()&#123; phi[1] = g[1] = 1, notprime[1] = 1; for (int i = 2; i &lt;= 10000000; ++i) &#123; if (!notprime[i]) &#123; p[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= 10000000; ++j) &#123; notprime[i * p[j]] = 1; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; else phi[i * p[j]] = phi[i] * (p[j] - 1); &#125; g[i] = g[i - 1] + 2 * phi[i]; &#125; for (int i = 2; i &lt;= 10000000; ++i) phi[i] += phi[i - 1];&#125;int main()&#123; T = read(); Prime(); while (T--) work(read()); return 0;&#125;]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3994/luogu P3327 约数个数和]]></title>
    <url>%2F2019%2F02%2F11%2FNote%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~2019寒假集训题D.约数个数和题面设d(x)为x的约数个数，给定N、M，求 $\sum_{i=1}^{N}\sum_{j=1}^{M}d(i×j)$. Input输入文件包含多组测试数据。 第一行，一个整数T，表示测试数据的组数。 接下来的T行，每行两个整数N、M。 OutputT行，每行一个整数，表示你所求的答案。 Sample Input27 45 6 Sample Output110 121 Hint$1\leq N,M \leq 50,000$ $1\leq T \leq 50,000$ 哎，今天fhj大佬讲课也是很无奈，莫比乌斯反演虽然是学了，但是确实不太会用哇。 公式恐惧症患者一枚…… 第一步​ 首先，我们证明一条结论：d(n×m)=\sum_{i|n}\sum_{j|m}[gcd(i,j)==1] ​ 证明：对于nm每一个质因子$p_i$，我们令$n={p_i}^{a_i}×n_x,m={p_i}^{b_i}×m_x$，则有d(n×m)=\Pi_i(a_i+b_i+1)​，设 $l$ 和 $t$ 互质且不含质因子$p_i$，那么$(l×{p_i}^{a_i},t),(l×{p_i}^{a_i-1})…(l,t)…(l,t×{p_i}^{b_i-1}),(l,t×{p_i}^{b_i})$都是互质的数对，而 $ l$ 和 $ t $ 的取法刚好是$\Pi_{k\neq i}(a_k+b_k+1)$种。 第二步​ 下面是公式恐惧症的“福利”？！ \sum_{i=1}^n\sum_{j=1}^md(i×j)=\sum_{i=1}^n\sum_{j=1}^m\sum_{k|i}\sum_{l|j}[gcd(k,l)==1]​​ 现在我们枚举每一个数对$(k,l)$,那么它们会被算多少遍呢？每一个$k$的倍数都会算一次$k$，每一个$l$的倍数又会算一次$l$,而用$\frac nk$来表示n以内k的倍数有多少个是显然的，所以： \sum_{k=1}^n\sum_{l=1}^m\frac nk×\frac ml[gcd(k,l)==1]​ 然后我们能够用莫比乌斯函数的性质： \sum_{d|n}\mu(d)=1\ (n==1)\sum_{d|n}\mu(d)=0\ (n>1)​ 那我们就可以得到： \sum_{k=1}^n\sum_{l=1}^m\frac nk×\frac ml\sum_{d|gcd(k,l)}\mu(d)​ 如果$gcd(k,l)==1$，此时后面的这些等于1，否则是0。 ​ 我们就能得到： \sum_{k=1}^n\sum_{l=1}^m\frac nk× \frac ml\sum_{d|k且d|l}\mu(d)​ 我们只要枚举$\mu(d)$，显然，我们只要枚举d的倍数来与$\mu(d)$相乘即可。 \sum_{d=1}^{min(n,m)}\mu(d)\sum_{i=1}^\frac nd\sum_{j=1}^\frac md\frac n{d_i}×\frac m{d_j}第三步​ 我们由第二步继续变形可得： \sum_{d=1}^{min(n,m)}\mu(d)×(\sum_{k=1}^{\frac nd}\frac n{dk})×(\sum_{l=1}^{\frac md}\frac m{dl})令$g(x)=\sum_{i=1}^x\frac xi​$ \sum_{d=1}^{min(n,m)}\mu(d)×g(\frac nd)×g(\frac md)我们预处理出$g(x)​$即可。 观察一下$g(x)$，就会发现其实式子可以这么理解：$x$以内有约数i的数的个数和，也就是可看作原题中$d(x)$的前缀和要求$d(x)$的前缀和，可以求出每一个$d(x)$,也就是用线性筛求啦，要记录一下$c(x)$:将$x$分解质因数后，最小质因数的指数。那么参见第一步，x的最小质因数对$d(x)$的贡献为$c(x)+1$。 第四步​ 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123;w |= ch == '-'; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0'; ch = getchar();&#125; return w ? -x : x;&#125;int mu[500010],p[50010],cnt,n,m;long long a[500010],b[500010];bool notprime[500010];void Prime()&#123; mu[1]=a[1]=b[1]=1; for(int i=2;i&lt;=50000;++i) &#123; if(!notprime[i]) &#123; p[++cnt]=i; mu[i]=-1,a[i]=1,b[i]=2; &#125; for(int j=1;j&lt;=cnt&amp;&amp;i*p[j]&lt;=50000;++j) &#123; notprime[i*p[j]]=1; if(i%p[j]==0) &#123; b[i*p[j]]=b[i]/(a[i]+1)*(a[i]+2); a[i*p[j]]=a[i]+1; break; &#125; else &#123; b[i*p[j]]=b[i]*b[p[j]]; a[i*p[j]]=1; mu[i*p[j]]=-mu[i]; &#125; &#125; &#125; for(int i=2;i&lt;=50000;++i) &#123; b[i]+=b[i-1]; mu[i]+=mu[i-1]; &#125;&#125;int main()&#123; int T=read(); Prime(); while(T--) &#123; long long result=0; n=read(),m=read(); if(n&gt;m) swap(n,m); for(int i=1,j;i&lt;=n;i=j+1) &#123; j=min(n/(n/i),m/(m/i)); result+=(mu[j]-mu[i-1])*b[n/i]*b[m/i]; &#125; cout&lt;&lt;result&lt;&lt;endl; &#125; return 0;&#125; p.s.还有很重要的一点，如果初始化用这样a[N]={0,1}，会导致exe文件过大而无法提交，嘤嘤嘤，感谢vhosc巨佬……(/≧▽≦)/]]></content>
      <categories>
        <category>寒假集训</category>
      </categories>
      <tags>
        <tag>Study Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.5.30 集训总结]]></title>
    <url>%2F2018%2F05%2F30%2F2018-5-30%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[~{→看不见LaTex格式的Dalao们请刷新本页Thanks♪(･ω･)ﾉ←}~总结：先从第一天的比赛开始看，其实光从题目来看，我排于第七名的成绩，也就是两道水题和一道比较熟练的BFS给的，后面几题是没有思路的（大佬们太强了啊），被完虐…… 我再从昨天的ACM欢乐赛开始说起————比赛第一个小时，从A题的水题十分钟完成的速度来看，稍稍放宽了心态，然而在B题上竟然栽了跟头。最初在第三个点WA了2遍，再在14点WA了好几遍，最后又卡在了35点。最后心态几乎爆炸（内心OS：这可是一道水题啊），同样，同组的大佬们，也没发现有什么问题。就这样纠结着，最后将一个双重判定换了方向的思维的另一种判定，于是，终于是A了……此时时间已经在两小时之后了（比赛半程刚过）。内心火急火燎得，也不知怎的其他两位大佬，竟然开始换顺序做，半小时过去，VHOS（太强了）竟然完成了G组题，然而不幸的是不能提交（辣鸡日本Vjudge）。这又是对我们心态的考验，于此同时半数以上的组早已经完成了3道了，我们的排名位置几乎已经可以看到榜底了。终于在最后的第三个小时————奇迹竟然出现了！三小时十分钟！C题！！AC！！三小时三十分！G题！！AC！！此时我们的排名已经挤到了前十，4道AC，最多的大神组早完成了5题，我心有不甘，继续奋战，此时只剩唯我一人奋笔疾书……周围的人早已懈怠，不，还不能那么早。努力的想着D题，dp方程却死也推不出来，最后十五分钟……！！！哦！！！突然有了想法，夺过键盘，最后13分钟！！！我知道这次我没有调试的时间了，只能要求自己一遍过，每个字都敲得小心翼翼，同时又得加快速度…………3min！2min！！敲完了！！！样例一过，直接提交，不敢浪费每一分钟！！！竟然成功AC了！！！！！同组的大佬高兴的欢呼！！我做到了！！！当自己平静下来时，我才发现自己的身体一直在颤抖，心跳十分的快。最后我们虽然罚时很久，但是最终也以唯一AC 6道的好成绩位居了榜首，十分不易啊！！ （P.S:最后从岳神和刘大佬的钱包里成功坑到一顿KFC）o(●ˇ∀ˇ●)o 下面是对这几天所学内容的总结，逐条枚举：（其实很多口胡一波，并不能上手当场码题）1、$KMP$ （俗称“看*片算法”） （一%飞神）这是由三位大神同时发现的一种改进字符串匹配的算法（%%%），$KMP$算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个$next()$函数，函数本身包含了模式串的局部匹配信息。（强行解释一波失配函数）上波代码： 1234567891011121314151617181920int KMP(string W,string T)&#123; int i=1,j=1; while(i&lt;=n)&#123; while (j!=0&amp;&amp;W[j]!=T[i]) j=next[j]; if(j==m) return i-m+1;//匹配成功，返回匹配位置s else&#123;j++; i++;&#125; &#125; return -1;//匹配失败&#125;void GetNext(charT[],intnext[])&#123; next[1]=0; j=1;k=0; while(j&lt;T[0]) if((k==0)||(T[j]==T[k]))&#123; j++; k++; next[j]=k; &#125; else k=next[k];&#125; （其实并不太清楚它到底具体有什么用）=v= 2、数论、定理 （一堆奇奇怪怪的东西）（边打边复习）首先上场的是唯一分解和$lcm$、$gcd$（这货贼重要），由此引申的是欧几里得和扩展欧。 //威尔逊定理//：它给出了判定一个自然数是否为素数的充分必要条件，就是当且仅当$p$为素数时：$(p-1)!≡-1(mod p)$，但是由于阶乘是增长的速度实在是…………（所以结论对于实际操作意义不大，感觉说了废话） //小费马//：假如$p$是质数，且$gcd(a,p)=1$，那么$a(p-1)≡1(mod\ p)$（强制使用了一波$gcd$）（其中$gcd$为$1$代表互质）（结果证明出来了）（该同余式可以转为$ap≡p(mod\ p)$，不知道写的对不对，好像提到过） //欧拉函数与定理//：emmm，这玩意我实在不是很懂,认识了一下$φ$，还有欧拉定理：若$gcd(a,p)=1$，则$a^{φ(p)}≡1(mod\ p)$。 //关于这些定理的例题使用//：不太熟练，不献丑=w=，学习大神们的写法，费力的理解啊啊啊………… 3、$manacher$ （二%飞神）这个和$KMP$一样，是关于字符串的一种算法，主要针对回文串。以$O（n）$的时间复杂度以每个字符为中心，以回文串单程长度，将所取字符串扩展一倍。如果是奇数串就能顺利进行，如果偶数串，那必须插入奇怪的字符。但这种算法的神奇之处在于可以同时考虑奇串和偶串。（但不能拆坏原字符串）（代码好长，我决定不凑字数）(￣▽￣)” 4、状压$DP$好吧，我承认位运算我实在是烂透了，完全没记住，差点听成大弱智╮(╯-╰)╭ 。表示状压列举的子集既能完全枚举，还能节约不必要列举的时间……（来自萌新的神奇(⊙o⊙)） 5、树的$LCA$ （求树两点之间的最短路）先从树的$dfs$序入手，展开倍增（看得懂，表示不会写……），$tarjan$（竟然基于冰茶几（并查集）！！），$RMQ$，$emmm$（回去重新学习连通分量）。（不好随便口胡=-=，决定翻工学习） 6、差分 （一起讲了差分约束吧）差分所擅长做的就是把$a$数组中$l~r$范围内的数加上或减去某个$k$值，这样只要求前缀和，运用差分就只要求前缀和，就能在$O（n）$的时间内得到整个数组的值。差分约束嘛，是基于图论知识$SPFA$和判环的，比如我们得到$a[x]]]></content>
      <categories>
        <category>5/6月集训</category>
      </categories>
      <tags>
        <tag>Total Review</tag>
      </tags>
  </entry>
</search>
